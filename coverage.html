
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-park-mail-ru/2025_1_Return_Zero/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/go-park-mail-ru/2025_1_Return_Zero/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/go-park-mail-ru/2025_1_Return_Zero/init/microservices/init.go (0.0%)</option>
				
				<option value="file3">github.com/go-park-mail-ru/2025_1_Return_Zero/init/postgres/postgres.go (0.0%)</option>
				
				<option value="file4">github.com/go-park-mail-ru/2025_1_Return_Zero/init/redis/redis.go (0.0%)</option>
				
				<option value="file5">github.com/go-park-mail-ru/2025_1_Return_Zero/init/s3/s3.go (0.0%)</option>
				
				<option value="file6">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/middleware/accesslog.go (0.0%)</option>
				
				<option value="file7">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file8">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/middleware/cors.go (0.0%)</option>
				
				<option value="file9">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/middleware/csrf.go (0.0%)</option>
				
				<option value="file10">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/middleware/logger.go (0.0%)</option>
				
				<option value="file11">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/middleware/metrics.go (0.0%)</option>
				
				<option value="file12">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/middleware/requestId.go (0.0%)</option>
				
				<option value="file13">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/album/delivery/http/handler.go (100.0%)</option>
				
				<option value="file14">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/album/usecase/usecase.go (90.2%)</option>
				
				<option value="file15">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/artist/delivery/http/handler.go (100.0%)</option>
				
				<option value="file16">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/artist/usecase/usecase.go (97.8%)</option>
				
				<option value="file17">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/auth/usecase/usecase.go (0.0%)</option>
				
				<option value="file18">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor/ctxExtractor.go (0.0%)</option>
				
				<option value="file19">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors/customErrors.go (0.0%)</option>
				
				<option value="file20">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customResponseWriter/customResponseWriter.go (0.0%)</option>
				
				<option value="file21">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/errorStatus/errorStatus.go (0.0%)</option>
				
				<option value="file22">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/json/json.go (0.0%)</option>
				
				<option value="file23">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger/logger.go (0.0%)</option>
				
				<option value="file24">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/metrics/metrics.go (0.0%)</option>
				
				<option value="file25">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/pagination/pagination.go (0.0%)</option>
				
				<option value="file26">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/query/query.go (0.0%)</option>
				
				<option value="file27">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/jam/delivery/http/handler.go (0.0%)</option>
				
				<option value="file28">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/jam/repository/redis.go (0.0%)</option>
				
				<option value="file29">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/jam/usecase/usecase.go (0.0%)</option>
				
				<option value="file30">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/label/delivery/http/handler.go (64.0%)</option>
				
				<option value="file31">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/label/repository/postgres.go (0.0%)</option>
				
				<option value="file32">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/label/usecase/usecase.go (0.0%)</option>
				
				<option value="file33">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/converters.go (79.3%)</option>
				
				<option value="file34">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/repository/pagination.go (0.0%)</option>
				
				<option value="file35">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/playlist/delivery/http/handler.go (80.5%)</option>
				
				<option value="file36">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/playlist/usecase/usecase.go (0.0%)</option>
				
				<option value="file37">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/track/delivery/http/handler.go (91.2%)</option>
				
				<option value="file38">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/track/usecase/usecase.go (68.0%)</option>
				
				<option value="file39">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/user/delivery/http/handler.go (0.0%)</option>
				
				<option value="file40">github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/user/usecase/usecase.go (74.3%)</option>
				
				<option value="file41">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/cmd/main.go (0.0%)</option>
				
				<option value="file42">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/delivery/grpc.go (0.0%)</option>
				
				<option value="file43">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/repository/postgres.go (54.3%)</option>
				
				<option value="file44">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/repository/s3.go (0.0%)</option>
				
				<option value="file45">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/usecase/usecase.go (0.0%)</option>
				
				<option value="file46">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model/converters.go (81.0%)</option>
				
				<option value="file47">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model/errors/errors.go (0.0%)</option>
				
				<option value="file48">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/cmd/main.go (0.0%)</option>
				
				<option value="file49">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/delivery/grpc.go (0.0%)</option>
				
				<option value="file50">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/repository/postgres.go (46.8%)</option>
				
				<option value="file51">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/repository/s3.go (0.0%)</option>
				
				<option value="file52">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/usecase/usecase.go (0.0%)</option>
				
				<option value="file53">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model/converters.go (84.8%)</option>
				
				<option value="file54">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model/errors/errors.go (0.0%)</option>
				
				<option value="file55">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/cmd/main.go (0.0%)</option>
				
				<option value="file56">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/internal/delivery/grpc.go (0.0%)</option>
				
				<option value="file57">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/internal/repository/redis.go (83.9%)</option>
				
				<option value="file58">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/internal/usecase/usecase.go (100.0%)</option>
				
				<option value="file59">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/model/converters.go (100.0%)</option>
				
				<option value="file60">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/model/errors/errors.go (0.0%)</option>
				
				<option value="file61">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/interceptors/access.go (0.0%)</option>
				
				<option value="file62">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics/metrics.go (0.0%)</option>
				
				<option value="file63">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics/mock.go (0.0%)</option>
				
				<option value="file64">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/cmd/main.go (0.0%)</option>
				
				<option value="file65">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/delivery/grpc.go (0.0%)</option>
				
				<option value="file66">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/repository/postgres.go (80.0%)</option>
				
				<option value="file67">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/repository/s3.go (0.0%)</option>
				
				<option value="file68">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/usecase/usecase.go (87.4%)</option>
				
				<option value="file69">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model/converters.go (100.0%)</option>
				
				<option value="file70">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model/errors/errors.go (0.0%)</option>
				
				<option value="file71">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/cmd/main.go (0.0%)</option>
				
				<option value="file72">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/delivery/grpc.go (0.0%)</option>
				
				<option value="file73">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/repository/postgres.go (53.5%)</option>
				
				<option value="file74">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/repository/s3.go (0.0%)</option>
				
				<option value="file75">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/usecase/usecase.go (71.1%)</option>
				
				<option value="file76">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model/converters.go (61.2%)</option>
				
				<option value="file77">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model/errors/errors.go (0.0%)</option>
				
				<option value="file78">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/cmd/main.go (0.0%)</option>
				
				<option value="file79">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/delivery/grpc.go (0.0%)</option>
				
				<option value="file80">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/repository/postgres.go (67.0%)</option>
				
				<option value="file81">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/repository/s3.go (0.0%)</option>
				
				<option value="file82">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/usecase/usecase.go (45.2%)</option>
				
				<option value="file83">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model/converters.go (72.4%)</option>
				
				<option value="file84">github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model/errors/errors.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "time"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        _ "github.com/go-park-mail-ru/2025_1_Return_Zero/docs"
        albumProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/album"
        artistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
        authProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/auth"
        playlistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/playlist"
        trackProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/track"
        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        grpc "github.com/go-park-mail-ru/2025_1_Return_Zero/init/microservices"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/postgres"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/redis"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/middleware"
        albumHttp "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/album/delivery/http"
        albumUsecase "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/album/usecase"
        artistHttp "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/artist/delivery/http"
        artistUsecase "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/artist/usecase"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        jamHttp "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/jam/delivery/http"
        jamRepository "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/jam/repository"
        jamUsecase "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/jam/usecase"
        playlistHttp "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/playlist/delivery/http"
        playlistUsecase "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/playlist/usecase"
        trackHttp "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/track/delivery/http"
        trackUsecase "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/track/usecase"
        userHttp "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/user/delivery/http"
        userUsecase "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/user/usecase"

        labelHttp "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/label/delivery/http"
        labelRepository "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/label/repository"
        labelUsecase "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/label/usecase"

        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        httpSwagger "github.com/swaggo/http-swagger"
        "go.uber.org/zap"

        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/metrics"
)

// @title Return Zero API
// @version 1.0
// @description This is the API server for Return Zero music app.
// @host returnzero.ru
// @BasePath /api/v1
func main() <span class="cov0" title="0">{
        logger, err := logger.NewZapLogger()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creating logger:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error loading config:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">redisPool := redis.NewRedisPool(cfg.Redis)
        defer func() </span><span class="cov0" title="0">{
                if err := redisPool.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing Redis:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">postgresConn, err := postgres.ConnectPostgres(cfg.Postgres)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error connecting to Postgres:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := postgresConn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing Postgres:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">r := mux.NewRouter()
        logger.Info("Server starting on port %s...", zap.String("port", fmt.Sprintf(":%d", cfg.Port)))

        r.PathPrefix("/api/v1/docs/").Handler(httpSwagger.Handler(
                httpSwagger.URL("/api/v1/docs/doc.json"),
                httpSwagger.DeepLinking(true),
                httpSwagger.DocExpansion("none"),
        ))

        clients, err := grpc.InitGrpc(&amp;cfg.Services, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initializing gRPC clients:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">reg := prometheus.NewRegistry()
        metrics := metrics.NewMetrics(reg, "api")
        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
                address := fmt.Sprintf(":%d", cfg.Prometheus.ApiPort)
                logger.Info(fmt.Sprintf("Serving metrics responds on port %d", cfg.Prometheus.ApiPort))
                if err := http.ListenAndServe(address, nil); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Error starting metrics server", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">artistClient := artistProto.NewArtistServiceClient(clients.ArtistClient)
        albumClient := albumProto.NewAlbumServiceClient(clients.AlbumClient)
        trackClient := trackProto.NewTrackServiceClient(clients.TrackClient)
        playlistClient := playlistProto.NewPlaylistServiceClient(clients.PlaylistClient)
        authClient := authProto.NewAuthServiceClient(clients.AuthClient)
        userClient := userProto.NewUserServiceClient(clients.UserClient)

        labelRepository := labelRepository.NewLabelPostgresRepository(postgresConn)
        labelUsecase := labelUsecase.NewLabelUsecase(labelRepository, userClient, artistClient, albumClient, trackClient)
        labelHandler := labelHttp.NewLabelHandler(labelUsecase, cfg)

        r.Use(middleware.LoggerMiddleware(logger))
        r.Use(middleware.RequestId)
        r.Use(middleware.AccessLog)
        r.Use(middleware.Auth(&amp;authClient, &amp;userClient))
        r.Use(middleware.CorsMiddleware(cfg.Cors))
        // r.Use(middleware.CSRFMiddleware(cfg.CSRF))
        r.Use(middleware.MetricsMiddleware(metrics))

        trackHandler := trackHttp.NewTrackHandler(trackUsecase.NewUsecase(trackClient, artistClient, albumClient, playlistClient, userClient), cfg)
        albumHandler := albumHttp.NewAlbumHandler(albumUsecase.NewUsecase(albumClient, artistClient), cfg)
        artistHandler := artistHttp.NewArtistHandler(artistUsecase.NewUsecase(artistClient, userClient), cfg)
        userHandler := userHttp.NewUserHandler(userUsecase.NewUserUsecase(&amp;userClient, &amp;authClient, &amp;artistClient, &amp;trackClient, &amp;playlistClient))
        playlistHandler := playlistHttp.NewPlaylistHandler(playlistUsecase.NewUsecase(&amp;playlistClient, &amp;userClient), cfg)
        jamHandler := jamHttp.NewJamHandler(jamUsecase.NewUsecase(jamRepository.NewJamRedisRepository(redisPool), userClient), cfg)

        r.HandleFunc("/api/v1/tracks", trackHandler.GetAllTracks).Methods("GET")
        r.HandleFunc("/api/v1/tracks/{id:[0-9]+}", trackHandler.GetTrackByID).Methods("GET")
        r.HandleFunc("/api/v1/tracks/{id:[0-9]+}/stream", trackHandler.CreateStream).Methods("POST")
        r.HandleFunc("/api/v1/tracks/{id:[0-9]+}/like", trackHandler.LikeTrack).Methods("POST")
        r.HandleFunc("/api/v1/tracks/search", trackHandler.SearchTracks).Methods("GET")
        r.HandleFunc("/api/v1/streams/{id:[0-9]+}", trackHandler.UpdateStreamDuration).Methods("PUT", "PATCH")
        r.HandleFunc("/api/v1/selection/{selection}", trackHandler.GetSelectionTracks).Methods("GET")

        r.HandleFunc("/api/v1/albums", albumHandler.GetAllAlbums).Methods("GET")
        r.HandleFunc("/api/v1/albums/{id:[0-9]+}", albumHandler.GetAlbumByID).Methods("GET")
        r.HandleFunc("/api/v1/albums/search", albumHandler.SearchAlbums).Methods("GET")
        r.HandleFunc("/api/v1/albums/{id:[0-9]+}/tracks", trackHandler.GetTracksByAlbumID).Methods("GET")
        r.HandleFunc("/api/v1/albums/{id:[0-9]+}/like", albumHandler.LikeAlbum).Methods("POST")

        r.HandleFunc("/api/v1/artists", artistHandler.GetAllArtists).Methods("GET")
        r.HandleFunc("/api/v1/artists/{id:[0-9]+}", artistHandler.GetArtistByID).Methods("GET")
        r.HandleFunc("/api/v1/artists/search", artistHandler.SearchArtists).Methods("GET")
        r.HandleFunc("/api/v1/artists/{id:[0-9]+}/tracks", trackHandler.GetTracksByArtistID).Methods("GET")
        r.HandleFunc("/api/v1/artists/{id:[0-9]+}/albums", albumHandler.GetAlbumsByArtistID).Methods("GET")
        r.HandleFunc("/api/v1/artists/{id:[0-9]+}/like", artistHandler.LikeArtist).Methods("POST")

        r.HandleFunc("/api/v1/playlists", playlistHandler.CreatePlaylist).Methods("POST")
        r.HandleFunc("/api/v1/playlists/{id:[0-9]+}", playlistHandler.UpdatePlaylist).Methods("PUT")
        r.HandleFunc("/api/v1/playlists/{id:[0-9]+}", playlistHandler.RemovePlaylist).Methods("DELETE")
        r.HandleFunc("/api/v1/playlists/to-add", playlistHandler.GetPlaylistsToAdd).Methods("GET")
        r.HandleFunc("/api/v1/playlists/me", playlistHandler.GetCombinedPlaylistsForCurrentUser).Methods("GET")
        r.HandleFunc("/api/v1/playlists/{id:[0-9]+}/tracks", playlistHandler.AddTrackToPlaylist).Methods("POST")
        r.HandleFunc("/api/v1/playlists/{id:[0-9]+}/tracks/{trackId:[0-9]+}", playlistHandler.RemoveTrackFromPlaylist).Methods("DELETE")
        r.HandleFunc("/api/v1/playlists/{id:[0-9]+}/tracks", trackHandler.GetPlaylistTracks).Methods("GET")
        r.HandleFunc("/api/v1/playlists/{id:[0-9]+}", playlistHandler.GetPlaylistByID).Methods("GET")
        r.HandleFunc("/api/v1/playlists/{id:[0-9]+}/like", playlistHandler.LikePlaylist).Methods("POST")
        r.HandleFunc("/api/v1/playlists/search", playlistHandler.SearchPlaylists).Methods("GET")

        r.HandleFunc("/api/v1/auth/signup", userHandler.Signup).Methods("POST")
        r.HandleFunc("/api/v1/auth/login", userHandler.Login).Methods("POST")
        r.HandleFunc("/api/v1/auth/logout", userHandler.Logout).Methods("POST")
        r.HandleFunc("/api/v1/auth/check", userHandler.CheckUser).Methods("GET")

        r.HandleFunc("/api/v1/user/me/avatar", userHandler.UploadAvatar).Methods("POST")
        r.HandleFunc("/api/v1/user/me", userHandler.ChangeUserData).Methods("PUT")
        r.HandleFunc("/api/v1/user/me", userHandler.DeleteUser).Methods("DELETE")
        r.HandleFunc("/api/v1/user/{username:[a-zA-Z0-9_]+}", userHandler.GetUserData).Methods("GET")
        r.HandleFunc("/api/v1/user/me/history", trackHandler.GetLastListenedTracks).Methods("GET")
        r.HandleFunc("/api/v1/user/{username:[a-zA-Z0-9_]+}/artists", artistHandler.GetFavoriteArtists).Methods("GET")
        r.HandleFunc("/api/v1/user/{username:[a-zA-Z0-9_]+}/tracks", trackHandler.GetFavoriteTracks).Methods("GET")
        r.HandleFunc("/api/v1/user/{username:[a-zA-Z0-9_]+}/playlists", playlistHandler.GetProfilePlaylists).Methods("GET")
        r.HandleFunc("/api/v1/user/me/albums", albumHandler.GetFavoriteAlbums).Methods("GET")

        r.HandleFunc("/api/v1/label", labelHandler.CreateLabel).Methods("POST")
        r.HandleFunc("/api/v1/label", labelHandler.UpdateLabel).Methods("PUT")
        r.HandleFunc("/api/v1/label/{id:[0-9]+}", labelHandler.GetLabel).Methods("GET")

        r.HandleFunc("/api/v1/label/artist", labelHandler.CreateArtist).Methods("POST")
        r.HandleFunc("/api/v1/label/artist", labelHandler.EditArtist).Methods("PUT")
        r.HandleFunc("/api/v1/label/artists", labelHandler.GetArtists).Methods("GET")
        r.HandleFunc("/api/v1/label/artist", labelHandler.DeleteArtist).Methods("DELETE")

        r.HandleFunc("/api/v1/label/album", labelHandler.CreateAlbum).Methods("POST")
        r.HandleFunc("/api/v1/label/album", labelHandler.DeleteAlbum).Methods("DELETE")
        r.HandleFunc("/api/v1/label/albums", labelHandler.GetAlbumsByLabelID).Methods("GET")

        r.HandleFunc("/api/v1/jams", jamHandler.CreateRoom).Methods("POST")
        r.HandleFunc("/api/v1/jams/{id}", jamHandler.WSHandler).Methods("GET")

        r.Handle("/api/v1/metrics", promhttp.Handler())

        srv := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", cfg.Port),
                Handler: r,
        }

        err = srv.ListenAndServe()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error starting server:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)
        &lt;-c

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        err = srv.Shutdown(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error shutting down server:", zap.Error(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("Composer server stopped")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "os"
        "time"

        "github.com/spf13/viper"
)

type CSRFConfig struct {
        CSRFHeaderName  string `mapstructure:"csrf_header_name"`
        CSRFCookieName  string `mapstructure:"csrf_cookie_name"`
        CSRFTokenLength int    `mapstructure:"csrf_token_length"`
}

type PostgresConfig struct {
        PostgresHost     string
        PostgresPort     string
        PostgresUser     string
        PostgresPassword string
        PostgresDB       string
        MaxOpenConns     int `mapstructure:"max_open_conns"`
        MaxIdleConns     int `mapstructure:"max_idle_conns"`
        MaxLifetime      int `mapstructure:"max_lifetime"`
}

type S3Config struct {
        S3Region       string
        S3Endpoint     string
        S3TracksBucket string
        S3ImagesBucket string
        S3AccessKey    string
        S3SecretKey    string
        S3Duration     time.Duration `mapstructure:"s3_duration"`
}

type RedisConfig struct {
        RedisHost string
        RedisPort string
}

type Cors struct {
        AllowedOrigins   []string `mapstructure:"allowed_origins"`
        AllowedMethods   []string `mapstructure:"allowed_methods"`
        AllowedHeaders   []string `mapstructure:"allowed_headers"`
        AllowCredentials bool     `mapstructure:"allow_credentials"`
        MaxAge           int      `mapstructure:"max_age"`
}

type ArtistService struct {
        Port int `mapstructure:"port"`
        Host string
}

type AlbumService struct {
        Port int `mapstructure:"port"`
        Host string
}

type TrackService struct {
        Port int `mapstructure:"port"`
        Host string
}

type PlaylistService struct {
        Port int `mapstructure:"port"`
        Host string
}

type AuthService struct {
        Port int `mapstructure:"port"`
        Host string
}

type UserService struct {
        Port int `mapstructure:"port"`
        Host string
}

type Services struct {
        ArtistService   ArtistService   `mapstructure:"artist_service"`
        AlbumService    AlbumService    `mapstructure:"album_service"`
        TrackService    TrackService    `mapstructure:"track_service"`
        AuthService     AuthService     `mapstructure:"auth_service"`
        UserService     UserService     `mapstructure:"user_service"`
        PlaylistService PlaylistService `mapstructure:"playlist_service"`
}

type PaginationConfig struct {
        MaxOffset     int `mapstructure:"max_offset"`
        MaxLimit      int `mapstructure:"max_limit"`
        DefaultOffset int `mapstructure:"default_offset"`
        DefaultLimit  int `mapstructure:"default_limit"`
}

type Prometheus struct {
        ArtistPort     int `mapstructure:"artist_port"`
        AlbumPort      int `mapstructure:"album_port"`
        TrackPort      int `mapstructure:"track_port"`
        AuthPort       int `mapstructure:"auth_port"`
        UserPort       int `mapstructure:"user_port"`
        PlaylistPort   int `mapstructure:"playlist_port"`
        PrometheusPort int `mapstructure:"prometheus_port"`
        ApiPort        int `mapstructure:"api_port"`
}

type Config struct {
        Cors       Cors
        Port       int `mapstructure:"port"`
        Pagination PaginationConfig
        Postgres   PostgresConfig
        S3         S3Config
        Redis      RedisConfig
        CSRF       CSRFConfig
        Services   Services
        Prometheus Prometheus
}

func LoadConfig() (*Config, error) <span class="cov0" title="0">{
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(".")

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">config.Postgres.PostgresHost = os.Getenv("POSTGRES_HOST")
        config.Postgres.PostgresPort = os.Getenv("POSTGRES_PORT")
        config.Postgres.PostgresUser = os.Getenv("POSTGRES_USER")
        config.Postgres.PostgresPassword = os.Getenv("POSTGRES_PASSWORD")
        config.Postgres.PostgresDB = os.Getenv("POSTGRES_DB")

        config.S3.S3AccessKey = os.Getenv("S3_ACCESS_KEY")
        config.S3.S3SecretKey = os.Getenv("S3_SECRET_KEY")
        config.S3.S3Region = os.Getenv("S3_REGION")
        config.S3.S3Endpoint = os.Getenv("S3_ENDPOINT")
        config.S3.S3TracksBucket = os.Getenv("S3_TRACKS_BUCKET")
        config.S3.S3ImagesBucket = os.Getenv("S3_IMAGES_BUCKET")

        config.Redis.RedisHost = os.Getenv("REDIS_HOST")
        config.Redis.RedisPort = os.Getenv("REDIS_PORT")

        config.Services.ArtistService.Host = os.Getenv("ARTIST_SERVICE_HOST")
        config.Services.AlbumService.Host = os.Getenv("ALBUM_SERVICE_HOST")
        config.Services.TrackService.Host = os.Getenv("TRACK_SERVICE_HOST")
        config.Services.AuthService.Host = os.Getenv("AUTH_SERVICE_HOST")
        config.Services.UserService.Host = os.Getenv("USER_SERVICE_HOST")
        config.Services.PlaylistService.Host = os.Getenv("PLAYLIST_SERVICE_HOST")
        return &amp;config, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package grpc

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/metadata"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/middleware"
)

type Clients struct {
        ArtistClient   *grpc.ClientConn
        AlbumClient    *grpc.ClientConn
        TrackClient    *grpc.ClientConn
        AuthClient     *grpc.ClientConn
        UserClient     *grpc.ClientConn
        PlaylistClient *grpc.ClientConn
}

func requestIdUnaryClientInterceptor(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error <span class="cov0" title="0">{
        requestId := ctx.Value(middleware.RequestIDKey{}).(string)
        md := metadata.New(map[string]string{
                "request_id": requestId,
        })
        return invoker(metadata.NewOutgoingContext(ctx, md), method, req, reply, cc, opts...)
}</span>

func InitGrpc(cfg *config.Services, logger *zap.SugaredLogger) (*Clients, error) <span class="cov0" title="0">{
        artistClient, err := grpc.NewClient(fmt.Sprintf("%s:%d", cfg.ArtistService.Host, cfg.ArtistService.Port), grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithUnaryInterceptor(requestIdUnaryClientInterceptor))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error creating artist client:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">albumClient, err := grpc.NewClient(fmt.Sprintf("%s:%d", cfg.AlbumService.Host, cfg.AlbumService.Port), grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithUnaryInterceptor(requestIdUnaryClientInterceptor))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error creating album client:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">trackClient, err := grpc.NewClient(fmt.Sprintf("%s:%d", cfg.TrackService.Host, cfg.TrackService.Port), grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithUnaryInterceptor(requestIdUnaryClientInterceptor), grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(50*1024*1024), grpc.MaxCallSendMsgSize(50*1024*1024)))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error creating track client:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">playlistClient, err := grpc.NewClient(fmt.Sprintf("%s:%d", cfg.PlaylistService.Host, cfg.PlaylistService.Port), grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithUnaryInterceptor(requestIdUnaryClientInterceptor))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error creating playlist client:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">authClient, err := grpc.NewClient(fmt.Sprintf("%s:%d", cfg.AuthService.Host, cfg.AuthService.Port), grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithUnaryInterceptor(requestIdUnaryClientInterceptor))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error creating auth client:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">userClient, err := grpc.NewClient(fmt.Sprintf("%s:%d", cfg.UserService.Host, cfg.UserService.Port), grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithUnaryInterceptor(requestIdUnaryClientInterceptor))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error creating user client:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return &amp;Clients{
                ArtistClient:   artistClient,
                AlbumClient:    albumClient,
                TrackClient:    trackClient,
                PlaylistClient: playlistClient,
                AuthClient:     authClient,
                UserClient:     userClient,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package postgres

import (
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        _ "github.com/jackc/pgx/v5/stdlib"
)

func ConnectPostgres(cfg config.PostgresConfig) (*sql.DB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", cfg.PostgresHost, cfg.PostgresPort, cfg.PostgresUser, cfg.PostgresPassword, cfg.PostgresDB)

        db, err := sql.Open("pgx", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fmt.Println("Connected to Postgres")

        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package redis

import (
        "fmt"
        "time"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/gomodule/redigo/redis"
)

func NewRedisPool(cfg config.RedisConfig) *redis.Pool <span class="cov0" title="0">{
        address := fmt.Sprintf("%s:%s", cfg.RedisHost, cfg.RedisPort)

        return &amp;redis.Pool{
                Dial: func() (redis.Conn, error) </span><span class="cov0" title="0">{
                        c, err := redis.Dial("tcp", address)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return c, nil</span>
                },
                TestOnBorrow: func(c redis.Conn, t time.Time) error <span class="cov0" title="0">{
                        if time.Since(t) &lt; time.Minute </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">_, err := c.Do("PING")
                        return err</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package s3

import (
        "fmt"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
)

func InitS3(cfg config.S3Config) (*s3.S3, error) <span class="cov0" title="0">{
        s3Config := &amp;aws.Config{
                Region:           aws.String(cfg.S3Region),
                Credentials:      credentials.NewStaticCredentials(cfg.S3AccessKey, cfg.S3SecretKey, ""),
                Endpoint:         aws.String(cfg.S3Endpoint),
                S3ForcePathStyle: aws.Bool(false),
        }

        newSession, err := session.NewSession(s3Config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fmt.Println("Connected to S3")

        return s3.New(newSession), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "bufio"
        "net"
        "net/http"
        "time"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "go.uber.org/zap"
)

type statusResponseWriter struct {
        http.ResponseWriter
        status int
}

func (w *statusResponseWriter) WriteHeader(status int) <span class="cov0" title="0">{
        w.status = status
        w.ResponseWriter.WriteHeader(status)
}</span>

// Hijack implements the http.Hijacker interface to support WebSocket connections
func (w *statusResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov0" title="0">{
        if hijacker, ok := w.ResponseWriter.(http.Hijacker); ok </span><span class="cov0" title="0">{
                return hijacker.Hijack()
        }</span>
        <span class="cov0" title="0">return nil, nil, http.ErrNotSupported</span>
}

func AccessLog(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                logger := logger.LoggerFromContext(r.Context())
                defer func() </span><span class="cov0" title="0">{
                        if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to sync logger", zap.Error(err))
                        }</span>
                }()

                <span class="cov0" title="0">if websocketRequest := r.Header.Get("Upgrade"); websocketRequest == "websocket" </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">start := time.Now()

                sw := &amp;statusResponseWriter{ResponseWriter: w}
                next.ServeHTTP(sw, r)

                logger.Infow(
                        "access",
                        "method", r.Method,
                        "url", r.URL.String(),
                        "ip", r.RemoteAddr,
                        "user-agent", r.UserAgent(),
                        "status", sw.status,
                        "duration", time.Since(start),
                )</span>
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "context"
        "net/http"

        authProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/auth"
        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
)

func Auth(authClient *authProto.AuthServiceClient, userClient *userProto.UserServiceClient) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        sessionCookie, err := r.Cookie("session_id")
                        if err != nil </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">sessionID := sessionCookie.Value
                        userIDProto, err := (*authClient).GetSession(r.Context(), model.SessionIDFromUsecaseToProto(sessionID))
                        if err != nil </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">userID := model.UserIDFromProtoToUsecase(userIDProto)
                        ctx := context.WithValue(r.Context(), ctxExtractor.UserContextKey{}, userID)
                        if userID == 1 </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, ctxExtractor.AdminContextKey{}, userID)
                        }</span>
                        <span class="cov0" title="0">labelIDProto, err := (*userClient).GetLabelIDByUserID(r.Context(), model.UserIDFromUsecaseToProtoUser(userID))
                        if err != nil </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>
                        <span class="cov0" title="0">labelID := model.LabelIDFromProtoToUsecase(labelIDProto)
                        ctx = context.WithValue(ctx, ctxExtractor.LabelContextKey{}, labelID)

                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
)

func CorsMiddleware(cfg config.Cors) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        origin := r.Header.Get("Origin")
                        if origin == "" </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">var allowedOrigin string

                        for _, o := range cfg.AllowedOrigins </span><span class="cov0" title="0">{
                                if o == "*" </span><span class="cov0" title="0">{
                                        if cfg.AllowCredentials </span><span class="cov0" title="0">{
                                                allowedOrigin = origin
                                        }</span> else<span class="cov0" title="0"> {
                                                allowedOrigin = "*"
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                                <span class="cov0" title="0">if o == origin </span><span class="cov0" title="0">{
                                        allowedOrigin = o
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if allowedOrigin == "" </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">if r.Method == http.MethodOptions &amp;&amp; r.Header.Get("Access-Control-Request-Method") != "" </span><span class="cov0" title="0">{
                                w.Header().Set("Access-Control-Allow-Origin", allowedOrigin)
                                w.Header().Set("Access-Control-Allow-Methods", strings.Join(cfg.AllowedMethods, ","))
                                w.Header().Set("Access-Control-Allow-Headers", strings.Join(cfg.AllowedHeaders, ","))

                                w.Header().Set("Access-Control-Max-Age", strconv.Itoa(cfg.MaxAge))

                                if cfg.AllowCredentials </span><span class="cov0" title="0">{
                                        w.Header().Set("Access-Control-Allow-Credentials", "true")
                                }</span>

                                <span class="cov0" title="0">w.Header().Add("Vary", "Origin")

                                w.WriteHeader(http.StatusNoContent)
                                return</span>
                        }

                        <span class="cov0" title="0">w.Header().Set("Access-Control-Allow-Origin", allowedOrigin)
                        if cfg.AllowCredentials </span><span class="cov0" title="0">{
                                w.Header().Set("Access-Control-Allow-Credentials", "true")
                        }</span>

                        <span class="cov0" title="0">w.Header().Add("Vary", "Origin")
                        next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "crypto/rand"
        "encoding/base64"
        "errors"
        "net/http"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/json"
)

func generateCSRFToken(tokenLength int) (string, error) <span class="cov0" title="0">{
        b := make([]byte, tokenLength)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.RawStdEncoding.EncodeToString(b), nil</span>
}

func CSRFMiddleware(cfg config.CSRFConfig) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if r.Method == http.MethodGet || r.Method == http.MethodHead || r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                                var token string
                                cookie, err := r.Cookie(cfg.CSRFCookieName)
                                if err != nil || cookie.Value == "" </span><span class="cov0" title="0">{
                                        newToken, err := generateCSRFToken(cfg.CSRFTokenLength)
                                        if err != nil </span><span class="cov0" title="0">{
                                                json.WriteErrorResponse(w, http.StatusInternalServerError, "Failed to generate CSRF token", nil)
                                                return
                                        }</span>
                                        <span class="cov0" title="0">token = newToken
                                        cookie = &amp;http.Cookie{
                                                Name:     cfg.CSRFCookieName,
                                                Value:    token,
                                                Path:     "/",
                                                HttpOnly: true,
                                                Secure:   false,
                                        }
                                        http.SetCookie(w, cookie)</span>
                                } else<span class="cov0" title="0"> {
                                        token = cookie.Value
                                }</span>

                                <span class="cov0" title="0">w.Header().Set(cfg.CSRFHeaderName, token)
                                next.ServeHTTP(w, r)
                                return</span>
                        }

                        <span class="cov0" title="0">cookie, err := r.Cookie(cfg.CSRFCookieName)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, http.ErrNoCookie) </span><span class="cov0" title="0">{
                                        json.WriteErrorResponse(w, http.StatusForbidden, "CSRF token missing", nil)
                                        return
                                }</span>
                                <span class="cov0" title="0">json.WriteErrorResponse(w, http.StatusInternalServerError, "Error reading CSRF cookie", nil)
                                return</span>
                        }
                        <span class="cov0" title="0">if cookie.Value == "" </span><span class="cov0" title="0">{
                                json.WriteErrorResponse(w, http.StatusForbidden, "CSRF token missing", nil)
                                return
                        }</span>

                        <span class="cov0" title="0">token := r.Header.Get(cfg.CSRFHeaderName)
                        if token == "" || token != cookie.Value </span><span class="cov0" title="0">{
                                json.WriteErrorResponse(w, http.StatusForbidden, "Invalid CSRF token", nil)
                                return
                        }</span>
                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "net/http"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "go.uber.org/zap"
)

func Logger(next http.Handler, logger *zap.SugaredLogger) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := loggerPkg.LoggerToContext(r.Context(), logger)
                r = r.WithContext(ctx)

                next.ServeHTTP(w, r)
        }</span>)
}

func LoggerMiddleware(logger *zap.SugaredLogger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return Logger(next, logger)
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "net/http"
        "regexp"
        "strconv"
        "time"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customResponseWriter"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/metrics"
)

var pathPatterns = []*regexp.Regexp{
        // tracks handlers
        regexp.MustCompile(`^/api/v1/tracks$`),
        regexp.MustCompile(`^/api/v1/tracks/([0-9]+)$`),
        regexp.MustCompile(`^/api/v1/tracks/([0-9]+)/stream$`),
        regexp.MustCompile(`^/api/v1/tracks/([0-9]+)/like$`),
        regexp.MustCompile(`^/api/v1/tracks/search$`),
        regexp.MustCompile(`^/api/v1/streams/([0-9]+)$`),

        // albums handlers
        regexp.MustCompile(`^/api/v1/albums$`),
        regexp.MustCompile(`^/api/v1/albums/([0-9]+)$`),
        regexp.MustCompile(`^/api/v1/albums/search$`),
        regexp.MustCompile(`^/api/v1/albums/([0-9]+)/tracks$`),
        regexp.MustCompile(`^/api/v1/albums/([0-9]+)/like$`),

        // artists handlers
        regexp.MustCompile(`^/api/v1/artists$`),
        regexp.MustCompile(`^/api/v1/artists/([0-9]+)$`),
        regexp.MustCompile(`^/api/v1/artists/search$`),
        regexp.MustCompile(`^/api/v1/artists/([0-9]+)/tracks$`),
        regexp.MustCompile(`^/api/v1/artists/([0-9]+)/albums$`),
        regexp.MustCompile(`^/api/v1/artists/([0-9]+)/like$`),

        // playlists handlers
        regexp.MustCompile(`^/api/v1/playlists$`),
        regexp.MustCompile(`^/api/v1/playlists/([0-9]+)$`),
        regexp.MustCompile(`^/api/v1/playlists/([0-9]+)$`), // duplicate for PUT/DELETE, order preserved
        regexp.MustCompile(`^/api/v1/playlists/to-add$`),
        regexp.MustCompile(`^/api/v1/playlists/me$`),
        regexp.MustCompile(`^/api/v1/playlists/([0-9]+)/tracks$`),
        regexp.MustCompile(`^/api/v1/playlists/([0-9]+)/tracks/([0-9]+)$`),
        regexp.MustCompile(`^/api/v1/playlists/([0-9]+)/tracks$`), // GET playlist tracks
        regexp.MustCompile(`^/api/v1/playlists/([0-9]+)$`),        // GET playlist by ID
        regexp.MustCompile(`^/api/v1/playlists/([0-9]+)/like$`),
        regexp.MustCompile(`^/api/v1/playlists/search$`),

        // auth handlers
        regexp.MustCompile(`^/api/v1/auth/signup$`),
        regexp.MustCompile(`^/api/v1/auth/login$`),
        regexp.MustCompile(`^/api/v1/auth/logout$`),
        regexp.MustCompile(`^/api/v1/auth/check$`),

        // user handlers
        regexp.MustCompile(`^/api/v1/user/me/avatar$`),
        regexp.MustCompile(`^/api/v1/user/me$`),
        regexp.MustCompile(`^/api/v1/user/me$`), // for DELETE
        regexp.MustCompile(`^/api/v1/user/([^/]+)$`),
        regexp.MustCompile(`^/api/v1/user/me/history$`),
        regexp.MustCompile(`^/api/v1/user/([^/]+)/artists$`),
        regexp.MustCompile(`^/api/v1/user/([^/]+)/tracks$`),
        regexp.MustCompile(`^/api/v1/user/([^/]+)/playlists$`),
        regexp.MustCompile(`^/api/v1/user/me/albums$`),

        // jams handlers
        regexp.MustCompile(`^/api/v1/jams$`),
        regexp.MustCompile(`^/api/v1/jams/([^/]+)$`),
}

var pathReplacements = []string{
        // tracks handlers
        "/api/v1/tracks",
        "/api/v1/tracks/{id}",
        "/api/v1/tracks/{id}/stream",
        "/api/v1/tracks/{id}/like",
        "/api/v1/tracks/search",
        "/api/v1/streams/{id}",

        // albums handlers
        "/api/v1/albums",
        "/api/v1/albums/{id}",
        "/api/v1/albums/search",
        "/api/v1/albums/{id}/tracks",
        "/api/v1/albums/{id}/like",

        // artists handlers
        "/api/v1/artists",
        "/api/v1/artists/{id}",
        "/api/v1/artists/search",
        "/api/v1/artists/{id}/tracks",
        "/api/v1/artists/{id}/albums",
        "/api/v1/artists/{id}/like",

        // playlists handlers
        "/api/v1/playlists",
        "/api/v1/playlists/{id}",
        "/api/v1/playlists/{id}", // PUT/DELETE
        "/api/v1/playlists/to-add",
        "/api/v1/playlists/me",
        "/api/v1/playlists/{id}/tracks",
        "/api/v1/playlists/{id}/tracks/{trackId}",
        "/api/v1/playlists/{id}/tracks", // GET
        "/api/v1/playlists/{id}",        // GET by ID
        "/api/v1/playlists/{id}/like",
        "/api/v1/playlists/search",

        // auth handlers
        "/api/v1/auth/signup",
        "/api/v1/auth/login",
        "/api/v1/auth/logout",
        "/api/v1/auth/check",

        // user handlers
        "/api/v1/user/me/avatar",
        "/api/v1/user/me", // PUT
        "/api/v1/user/me", // DELETE
        "/api/v1/user/{username}",
        "/api/v1/user/me/history",
        "/api/v1/user/{username}/artists",
        "/api/v1/user/{username}/tracks",
        "/api/v1/user/{username}/playlists",
        "/api/v1/user/me/albums",

        // jams handlers
        "/api/v1/jams",
        "/api/v1/jams/{id}",
}

func ExtractPath(path string) string <span class="cov0" title="0">{
        for i, pattern := range pathPatterns </span><span class="cov0" title="0">{
                if pattern.MatchString(path) </span><span class="cov0" title="0">{
                        return pathReplacements[i]
                }</span>
        }

        <span class="cov0" title="0">return path</span>
}

func MetricsMiddleware(m *metrics.Metrics) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()

                        rec := customResponseWriter.NewResponseWriter(w)

                        next.ServeHTTP(rec, r)

                        duration := time.Since(start).Seconds()

                        method := r.Method
                        path := r.URL.Path
                        status := strconv.Itoa(rec.StatusCode)

                        normalizedPath := ExtractPath(path)

                        m.HTTPTotalNumberOfRequests.WithLabelValues(method, normalizedPath, status).Inc()
                        m.HTTPRequestDuration.WithLabelValues(method, normalizedPath).Observe(duration)

                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "context"
        "net/http"

        "github.com/google/uuid"
        "go.uber.org/zap"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
)

type RequestIDKey struct{}

func RequestId(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                requestId := r.Header.Get("X-Request-Id")
                if requestId == "" </span><span class="cov0" title="0">{
                        requestId = uuid.New().String()
                }</span>
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), RequestIDKey{}, requestId)
                logger := loggerPkg.LoggerFromContext(ctx).With(zap.String("request_id", requestId))
                ctx = loggerPkg.LoggerToContext(ctx, logger)
                r = r.WithContext(ctx)
                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package album

import (
        "net/http"
        "strconv"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/album"
        ctxExtractor "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/errorStatus"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/json"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/pagination"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        deliveryModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

type AlbumHandler struct {
        usecase album.Usecase
        cfg     *config.Config
}

func NewAlbumHandler(usecase album.Usecase, cfg *config.Config) *AlbumHandler <span class="cov10" title="6">{
        return &amp;AlbumHandler{usecase: usecase, cfg: cfg}
}</span>

// GetAllAlbums godoc
// @Summary Get albums
// @Description Get a list of albums with optional pagination filters
// @Tags albums
// @Accept json
// @Produce json
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Album} "List of albums"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid filters"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /albums [get]
func (h *AlbumHandler) GetAllAlbums(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov4" title="2">usecaseAlbums, err := h.usecase.GetAllAlbums(ctx, &amp;usecaseModel.AlbumFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        })

        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get albums", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">albums := model.AlbumsFromUsecaseToDelivery(usecaseAlbums)

        json.WriteSuccessResponse(w, http.StatusOK, albums, nil)</span>
}

// GetAlbumsByArtistID godoc
// @Summary Get albums by artist ID
// @Description Get a list of albums for a specific artist
// @Tags albums
// @Accept json
// @Produce json
// @Param id path integer true "Artist ID"
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Album} "List of albums"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid artist ID"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /artists/{id}/albums [get]
func (h *AlbumHandler) GetAlbumsByArtistID(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov6" title="3">vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse artist ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov4" title="2">usecaseAlbums, err := h.usecase.GetAlbumsByArtistID(ctx, id, &amp;usecaseModel.AlbumFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        })
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get albums", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">albums := model.AlbumsFromUsecaseToDelivery(usecaseAlbums)
        json.WriteSuccessResponse(w, http.StatusOK, albums, nil)</span>
}

// GetAlbumByID godoc
// @Summary Get album by ID
// @Description Get an album by its ID
// @Tags albums
// @Accept json
// @Produce json
// @Param id path integer true "Album ID"
// @Success 200 {object} delivery.APIResponse{body=delivery.Album} "Album details"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid album ID"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /albums/{id} [get]
func (h *AlbumHandler) GetAlbumByID(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse album ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov4" title="2">usecaseAlbum, err := h.usecase.GetAlbumByID(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get album", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">album := model.AlbumFromUsecaseToDelivery(usecaseAlbum, usecaseAlbum.Artists)
        json.WriteSuccessResponse(w, http.StatusOK, album, nil)</span>
}

// LikeAlbum godoc
// @Summary Like an album
// @Description Like an album for a user
// @Tags albums
// @Accept json
// @Produce json
// @Param id path integer true "Album ID"
// @Param likeRequest body delivery.AlbumLikeRequest true "Like request"
// @Success 200 {object} delivery.APIResponse{body=delivery.Message} "Album liked/unliked"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid album ID"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Album not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /albums/{id}/like [post]
func (h *AlbumHandler) LikeAlbum(w http.ResponseWriter, r *http.Request) <span class="cov10" title="6">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to like album for unauthorized user")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov9" title="5">vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse album ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov7" title="4">var deliveryLikeRequest deliveryModel.AlbumLikeRequest

        err = json.ReadJSON(w, r, &amp;deliveryLikeRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to read like request", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov6" title="3">usecaseLikeRequest := model.AlbumLikeRequestFromDeliveryToUsecase(deliveryLikeRequest.IsLike, userID, id)

        err = h.usecase.LikeAlbum(ctx, usecaseLikeRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to like album", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov4" title="2">json.WriteSuccessResponse(w, http.StatusOK, deliveryModel.Message{
                Message: "album liked/unliked",
        }, nil)</span>
}

// GetFavoriteAlbums godoc
// @Summary Get favorite albums
// @Description Get a list of favorite albums for a user
// @Tags albums
// @Accept json
// @Produce json
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Album} "List of favorite albums"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /user/me/albums [get]
func (h *AlbumHandler) GetFavoriteAlbums(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to get favorite albums for unauthorized user")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov6" title="3">pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov4" title="2">usecaseAlbums, err := h.usecase.GetFavoriteAlbums(ctx, &amp;usecaseModel.AlbumFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        }, userID)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get favorite albums", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">albums := model.AlbumsFromUsecaseToDelivery(usecaseAlbums)
        json.WriteSuccessResponse(w, http.StatusOK, albums, nil)</span>
}

// SearchAlbums godoc
// @Summary Search albums
// @Description Search albums by query
// @Tags albums
// @Accept json
// @Produce json
// @Param query query string true "Query"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Album} "List of albums"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid query"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /albums/search [get]
func (h *AlbumHandler) SearchAlbums(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        query := r.URL.Query().Get("query")
        if query == "" </span><span class="cov1" title="1">{
                logger.Error("query is empty")
                json.WriteErrorResponse(w, http.StatusBadRequest, "query is empty", nil)
                return
        }</span>

        <span class="cov4" title="2">usecaseAlbums, err := h.usecase.SearchAlbums(ctx, query)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to search albums", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">albums := model.AlbumsFromUsecaseToDelivery(usecaseAlbums)
        json.WriteSuccessResponse(w, http.StatusOK, albums, nil)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package usecase

import (
        "context"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/album"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"

        albumProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/album"
        artistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
)

func NewUsecase(albumClient albumProto.AlbumServiceClient, artistClient artistProto.ArtistServiceClient) album.Usecase <span class="cov10" title="8">{
        return &amp;albumUsecase{albumClient: albumClient, artistClient: artistClient}
}</span>

type albumUsecase struct {
        albumClient  albumProto.AlbumServiceClient
        artistClient artistProto.ArtistServiceClient
}

func (u *albumUsecase) GetAllAlbums(ctx context.Context, filters *usecaseModel.AlbumFilters) ([]*usecaseModel.Album, error) <span class="cov4" title="2">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov4" title="2">{
                userID = -1
        }</span>

        <span class="cov4" title="2">protoFilters := &amp;albumProto.FiltersWithUserID{
                Filters: &amp;albumProto.Filters{
                        Pagination: model.PaginationFromUsecaseToAlbumProto(filters.Pagination),
                },
                UserId: &amp;albumProto.UserID{Id: userID},
        }

        protoAlbums, err := u.albumClient.GetAllAlbums(ctx, protoFilters)
        if err != nil </span><span class="cov1" title="1">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]*artistProto.AlbumID, 0, len(protoAlbums.Albums))
        for _, protoAlbum := range protoAlbums.Albums </span><span class="cov4" title="2">{
                albumIDs = append(albumIDs, &amp;artistProto.AlbumID{Id: protoAlbum.Id})
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByAlbumIDs(ctx, &amp;artistProto.AlbumIDList{Ids: albumIDs})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">artistWithTitleMap := model.ArtistWithTitleMapFromProtoToUsecase(protoArtists.Artists)

        albums := make([]*usecaseModel.Album, 0, len(protoAlbums.Albums))
        for _, protoAlbum := range protoAlbums.Albums </span><span class="cov4" title="2">{
                usecaseAlbum := model.AlbumFromProtoToUsecase(protoAlbum)
                usecaseAlbum.Artists = artistWithTitleMap[protoAlbum.Id]
                albums = append(albums, usecaseAlbum)
        }</span>
        <span class="cov1" title="1">return albums, nil</span>
}

func (u *albumUsecase) GetAlbumsByArtistID(ctx context.Context, artistID int64, filters *usecaseModel.AlbumFilters) ([]*usecaseModel.Album, error) <span class="cov1" title="1">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                userID = -1
        }</span>

        <span class="cov1" title="1">protoAlbumIDs, err := u.artistClient.GetAlbumIDsByArtistID(ctx, &amp;artistProto.ArtistID{Id: artistID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]*albumProto.AlbumID, 0, len(protoAlbumIDs.Ids))
        for _, protoAlbumID := range protoAlbumIDs.Ids </span><span class="cov4" title="2">{
                newAlbumID := &amp;albumProto.AlbumID{Id: protoAlbumID.Id}
                albumIDs = append(albumIDs, newAlbumID)
        }</span>

        <span class="cov1" title="1">protoAlbums, err := u.albumClient.GetAlbumsByIDs(ctx, &amp;albumProto.AlbumIDListWithUserID{
                Ids:    &amp;albumProto.AlbumIDList{Ids: albumIDs},
                UserId: &amp;albumProto.UserID{Id: userID},
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">artistAlbumIDs := make([]*artistProto.AlbumID, 0, len(protoAlbumIDs.Ids))
        for _, protoAlbumID := range protoAlbumIDs.Ids </span><span class="cov4" title="2">{
                artistAlbumIDs = append(artistAlbumIDs, &amp;artistProto.AlbumID{Id: protoAlbumID.Id})
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByAlbumIDs(ctx, &amp;artistProto.AlbumIDList{Ids: artistAlbumIDs})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">artistWithTitleMap := model.ArtistWithTitleMapFromProtoToUsecase(protoArtists.Artists)

        albums := make([]*usecaseModel.Album, 0, len(protoAlbums.Albums))
        for _, protoAlbum := range protoAlbums.Albums </span><span class="cov4" title="2">{
                usecaseAlbum := model.AlbumFromProtoToUsecase(protoAlbum)
                usecaseAlbum.Artists = artistWithTitleMap[protoAlbum.Id]
                albums = append(albums, usecaseAlbum)
        }</span>
        <span class="cov1" title="1">return albums, nil</span>
}

func (u *albumUsecase) GetAlbumByID(ctx context.Context, id int64) (*usecaseModel.Album, error) <span class="cov1" title="1">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                userID = -1
        }</span>

        <span class="cov1" title="1">protoAlbum, err := u.albumClient.GetAlbumByID(ctx, &amp;albumProto.AlbumIDWithUserID{
                AlbumId: &amp;albumProto.AlbumID{Id: id},
                UserId:  &amp;albumProto.UserID{Id: userID},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByAlbumID(ctx, &amp;artistProto.AlbumID{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">artistWithTitleList := model.ArtistWithTitleListFromProtoToUsecase(protoArtists.Artists)

        usecaseAlbum := model.AlbumFromProtoToUsecase(protoAlbum)
        usecaseAlbum.Artists = artistWithTitleList
        return usecaseAlbum, nil</span>
}

func (u *albumUsecase) LikeAlbum(ctx context.Context, request *usecaseModel.AlbumLikeRequest) error <span class="cov4" title="2">{
        protoRequest := model.AlbumLikeRequestFromUsecaseToProto(request)
        _, err := u.albumClient.LikeAlbum(ctx, protoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return customErrors.HandleAlbumGRPCError(err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *albumUsecase) GetFavoriteAlbums(ctx context.Context, filters *usecaseModel.AlbumFilters, userID int64) ([]*usecaseModel.Album, error) <span class="cov1" title="1">{
        protoFilters := &amp;albumProto.FiltersWithUserID{
                Filters: &amp;albumProto.Filters{
                        Pagination: model.PaginationFromUsecaseToAlbumProto(filters.Pagination),
                },
                UserId: &amp;albumProto.UserID{Id: userID},
        }

        protoAlbums, err := u.albumClient.GetFavoriteAlbums(ctx, protoFilters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]*artistProto.AlbumID, 0, len(protoAlbums.Albums))
        for _, protoAlbum := range protoAlbums.Albums </span><span class="cov4" title="2">{
                albumIDs = append(albumIDs, &amp;artistProto.AlbumID{Id: protoAlbum.Id})
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByAlbumIDs(ctx, &amp;artistProto.AlbumIDList{Ids: albumIDs})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">artistWithTitleMap := model.ArtistWithTitleMapFromProtoToUsecase(protoArtists.Artists)

        albums := make([]*usecaseModel.Album, 0, len(protoAlbums.Albums))
        for _, protoAlbum := range protoAlbums.Albums </span><span class="cov4" title="2">{
                usecaseAlbum := model.AlbumFromProtoToUsecase(protoAlbum)
                usecaseAlbum.Artists = artistWithTitleMap[protoAlbum.Id]
                albums = append(albums, usecaseAlbum)
        }</span>
        <span class="cov1" title="1">return albums, nil</span>
}

func (u *albumUsecase) SearchAlbums(ctx context.Context, query string) ([]*usecaseModel.Album, error) <span class="cov1" title="1">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                userID = -1
        }</span>

        <span class="cov1" title="1">protoRequest := &amp;albumProto.Query{
                Query:  query,
                UserId: &amp;albumProto.UserID{Id: userID},
        }

        protoAlbums, err := u.albumClient.SearchAlbums(ctx, protoRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]*artistProto.AlbumID, 0, len(protoAlbums.Albums))
        for _, protoAlbum := range protoAlbums.Albums </span><span class="cov4" title="2">{
                albumIDs = append(albumIDs, &amp;artistProto.AlbumID{Id: protoAlbum.Id})
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByAlbumIDs(ctx, &amp;artistProto.AlbumIDList{Ids: albumIDs})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">artistWithTitleMap := model.ArtistWithTitleMapFromProtoToUsecase(protoArtists.Artists)

        albums := make([]*usecaseModel.Album, 0, len(protoAlbums.Albums))
        for _, protoAlbum := range protoAlbums.Albums </span><span class="cov4" title="2">{
                usecaseAlbum := model.AlbumFromProtoToUsecase(protoAlbum)
                usecaseAlbum.Artists = artistWithTitleMap[protoAlbum.Id]
                albums = append(albums, usecaseAlbum)
        }</span>
        <span class="cov1" title="1">return albums, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package artist

import (
        "net/http"
        "strconv"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/artist"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/errorStatus"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/json"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/pagination"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        deliveryModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

type ArtistHandler struct {
        usecase artist.Usecase
        cfg     *config.Config
}

func NewArtistHandler(usecase artist.Usecase, cfg *config.Config) *ArtistHandler <span class="cov9" title="5">{
        return &amp;ArtistHandler{usecase: usecase, cfg: cfg}
}</span>

// GetAllArtists godoc
// @Summary Get artists
// @Description Get a list of artists with optional pagination filters
// @Tags artists
// @Accept json
// @Produce json
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Artist} "List of artists"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid filters"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /artists [get]
func (h *ArtistHandler) GetAllArtists(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov4" title="2">usecaseArtists, err := h.usecase.GetAllArtists(ctx, &amp;usecaseModel.ArtistFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        })

        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get artists", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">artists := model.ArtistsFromUsecaseToDelivery(usecaseArtists)
        json.WriteSuccessResponse(w, http.StatusOK, artists, nil)</span>
}

// GetArtistByID godoc
// @Summary Get artist by ID
// @Description Get detailed information about a specific artist by their ID
// @Tags artists
// @Accept json
// @Produce json
// @Param id path integer true "Artist ID"
// @Success 200 {object} delivery.APIResponse{body=delivery.ArtistDetailed} "Artist details"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /artists/{id} [get]
func (h *ArtistHandler) GetArtistByID(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse artist ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov4" title="2">usecaseArtist, err := h.usecase.GetArtistByID(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get artist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">artistDetailed := model.ArtistDetailedFromUsecaseToDelivery(usecaseArtist)
        json.WriteSuccessResponse(w, http.StatusOK, artistDetailed, nil)</span>
}

// LikeArtist godoc
// @Summary Like an artist
// @Description Like an artist for a user
// @Tags artists
// @Accept json
// @Produce json
// @Param id path integer true "Artist ID"
// @Param likeRequest body delivery.ArtistLikeRequest true "Like request"
// @Success 200 {object} delivery.APIResponse{body=delivery.Message} "Artist liked/unliked"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid artist ID"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Artist not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /artists/{id}/like [post]
func (h *ArtistHandler) LikeArtist(w http.ResponseWriter, r *http.Request) <span class="cov10" title="6">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to like artist for unauthorized user")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov9" title="5">vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse artist ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov7" title="4">var deliveryLikeRequest deliveryModel.ArtistLikeRequest

        err = json.ReadJSON(w, r, &amp;deliveryLikeRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to read like request", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov6" title="3">usecaseLikeRequest := model.ArtistLikeRequestFromDeliveryToUsecase(deliveryLikeRequest.IsLike, userID, id)

        err = h.usecase.LikeArtist(ctx, usecaseLikeRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to like artist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov4" title="2">json.WriteSuccessResponse(w, http.StatusOK, deliveryModel.Message{
                Message: "artist liked/unliked",
        }, nil)</span>
}

// GetFavoriteArtists godoc
// @Summary Get favorite artists
// @Description Get a list of favorite artists for a user
// @Tags artists
// @Accept json
// @Produce json
// @Param username path string true "Username"
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Artist} "List of favorite artists"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid username"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /user/{username}/artists [get]
func (h *ArtistHandler) GetFavoriteArtists(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        username := mux.Vars(r)["username"]
        if username == "" </span><span class="cov1" title="1">{
                logger.Warn("attempt to get favorite artists for empty username")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov6" title="3">pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov4" title="2">usecaseArtists, err := h.usecase.GetFavoriteArtists(ctx, &amp;usecaseModel.ArtistFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        }, username)

        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get artists", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">artists := model.ArtistsFromUsecaseToDelivery(usecaseArtists)
        json.WriteSuccessResponse(w, http.StatusOK, artists, nil)</span>
}

// SearchArtists godoc
// @Summary Search artists
// @Description Search artists by query
// @Tags artists
// @Accept json
// @Produce json
// @Param query query string true "Query"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Artist} "List of artists"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid query"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /artists/search [get]
func (h *ArtistHandler) SearchArtists(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        query := r.URL.Query().Get("query")
        if query == "" </span><span class="cov1" title="1">{
                logger.Error("query is empty")
                json.WriteErrorResponse(w, http.StatusBadRequest, "query is empty", nil)
                return
        }</span>

        <span class="cov4" title="2">usecaseArtists, err := h.usecase.SearchArtists(ctx, query)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to search artists", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">artists := model.ArtistsFromUsecaseToDelivery(usecaseArtists)
        json.WriteSuccessResponse(w, http.StatusOK, artists, nil)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package usecase

import (
        "context"

        artistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/artist"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        customErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
)

func NewUsecase(artistClient artistProto.ArtistServiceClient, userClient userProto.UserServiceClient) artist.Usecase <span class="cov9" title="5">{
        return &amp;artistUsecase{
                artistClient: artistClient,
                userClient:   userClient,
        }
}</span>

type artistUsecase struct {
        artistClient artistProto.ArtistServiceClient
        userClient   userProto.UserServiceClient
}

func (u *artistUsecase) GetArtistByID(ctx context.Context, id int64) (*usecaseModel.ArtistDetailed, error) <span class="cov6" title="3">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov4" title="2">{
                userID = -1
        }</span>

        <span class="cov6" title="3">protoArtist, err := u.artistClient.GetArtistByID(ctx, &amp;artistProto.ArtistIDWithUserID{
                ArtistId: &amp;artistProto.ArtistID{Id: id},
                UserId:   &amp;artistProto.UserID{Id: userID},
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov4" title="2">return model.ArtistDetailedFromProtoToUsecase(protoArtist), nil</span>
}

func (u *artistUsecase) GetAllArtists(ctx context.Context, filters *usecaseModel.ArtistFilters) ([]*usecaseModel.Artist, error) <span class="cov6" title="3">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov4" title="2">{
                userID = -1
        }</span>

        <span class="cov6" title="3">protoFilters := &amp;artistProto.FiltersWithUserID{
                Filters: &amp;artistProto.Filters{
                        Pagination: model.PaginationFromUsecaseToArtistProto(filters.Pagination),
                },
                UserId: &amp;artistProto.UserID{Id: userID},
        }

        protoArtists, err := u.artistClient.GetAllArtists(ctx, protoFilters)
        if err != nil </span><span class="cov1" title="1">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov4" title="2">return model.ArtistsFromProtoToUsecase(protoArtists.Artists), nil</span>
}

func (u *artistUsecase) LikeArtist(ctx context.Context, request *usecaseModel.ArtistLikeRequest) error <span class="cov4" title="2">{
        protoRequest := model.ArtistLikeRequestFromUsecaseToProto(request)
        _, err := u.artistClient.LikeArtist(ctx, protoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return customErrors.HandleArtistGRPCError(err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *artistUsecase) GetFavoriteArtists(ctx context.Context, filters *usecaseModel.ArtistFilters, username string) ([]*usecaseModel.Artist, error) <span class="cov10" title="6">{
        profileUserID, err := u.userClient.GetIDByUsername(ctx, &amp;userProto.Username{Username: username})
        if err != nil </span><span class="cov1" title="1">{
                return nil, customErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov9" title="5">profilePrivacy, err := u.userClient.GetUserPrivacyByID(ctx, &amp;userProto.UserID{Id: profileUserID.Id})
        if err != nil </span><span class="cov1" title="1">{
                return nil, customErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov7" title="4">currentUserID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov0" title="0">{
                currentUserID = -1
        }</span>

        <span class="cov7" title="4">if !profilePrivacy.IsPublicFavoriteArtists &amp;&amp; profileUserID.Id != currentUserID </span><span class="cov1" title="1">{
                return []*usecaseModel.Artist{}, nil
        }</span>

        <span class="cov6" title="3">protoFilters := &amp;artistProto.FiltersWithUserID{
                Filters: &amp;artistProto.Filters{
                        Pagination: model.PaginationFromUsecaseToArtistProto(filters.Pagination),
                },
                UserId: &amp;artistProto.UserID{Id: profileUserID.Id},
        }

        protoArtists, err := u.artistClient.GetFavoriteArtists(ctx, protoFilters)
        if err != nil </span><span class="cov1" title="1">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov4" title="2">return model.ArtistsFromProtoToUsecase(protoArtists.Artists), nil</span>
}

func (u *artistUsecase) SearchArtists(ctx context.Context, query string) ([]*usecaseModel.Artist, error) <span class="cov7" title="4">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov6" title="3">{
                userID = -1
        }</span>

        <span class="cov7" title="4">protoRequest := &amp;artistProto.Query{
                Query:  query,
                UserId: &amp;artistProto.UserID{Id: userID},
        }

        protoArtists, err := u.artistClient.SearchArtists(ctx, protoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov6" title="3">return model.ArtistsFromProtoToUsecase(protoArtists.Artists), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package usecase

import (
        "context"

        authProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/auth"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/auth"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
)

func NewAuthUsecase(authClient *authProto.AuthServiceClient) auth.Usecase <span class="cov0" title="0">{
        return &amp;AuthUsecase{authClient: authClient}
}</span>

type AuthUsecase struct {
        authClient *authProto.AuthServiceClient
}

func (u *AuthUsecase) CreateSession(ctx context.Context, ID int64) (string, error) <span class="cov0" title="0">{
        sessionID, err := (*u.authClient).CreateSession(ctx, &amp;authProto.UserID{Id: ID})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return model.SessionIDFromProtoToUsecase(sessionID), nil</span>
}

func (u *AuthUsecase) DeleteSession(ctx context.Context, SID string) error <span class="cov0" title="0">{
        _, err := (*u.authClient).DeleteSession(ctx, &amp;authProto.SessionID{SessionId: SID})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *AuthUsecase) GetSession(ctx context.Context, SID string) (int64, error) <span class="cov0" title="0">{
        id, err := (*u.authClient).GetSession(ctx, &amp;authProto.SessionID{SessionId: SID})
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">return model.UserIDFromProtoToUsecase(id), nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package ctxExtractor

import (
        "context"

        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
)

type UserContextKey struct{}
type LabelContextKey struct{}
type AdminContextKey struct{}

func UserFromContext(ctx context.Context) (int64, bool) <span class="cov0" title="0">{
        user, ok := ctx.Value(UserContextKey{}).(int64)
        if !ok </span><span class="cov0" title="0">{
                return -1, false
        }</span>
        <span class="cov0" title="0">return user, true</span>
}

func UserToContext(ctx context.Context, user *usecaseModel.User) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, UserContextKey{}, user)
}</span>

func LabelFromContext(ctx context.Context) (int64, bool) <span class="cov0" title="0">{
        label, ok := ctx.Value(LabelContextKey{}).(int64)
        if !ok </span><span class="cov0" title="0">{
                return -1, false
        }</span>
        <span class="cov0" title="0">return label, true</span>
}

func AdminFromContext(ctx context.Context) bool <span class="cov0" title="0">{
        _, ok := ctx.Value(AdminContextKey{}).(int64)
        return ok
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package customErrors

import (
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

var (
        ErrArtistNotFound               = errors.New("artist not found")
        ErrInvalidOffset                = errors.New("invalid offset: should be greater than 0")
        ErrInvalidLimit                 = errors.New("invalid limit: should be greater than 0")
        ErrAlbumNotFound                = errors.New("album not found")
        ErrStreamNotFound               = errors.New("stream not found")
        ErrFailedToUpdateStreamDuration = errors.New("failed to update stream duration")
        ErrTrackNotFound                = errors.New("track not found")
        ErrStreamPermissionDenied       = errors.New("user does not have permission to update this stream")
        ErrUserNotFound                 = errors.New("user not found")
        ErrUserExist                    = errors.New("user already exist")
        ErrWrongPassword                = errors.New("wrong password")
        ErrPasswordRequired             = errors.New("password required")
        ErrCreateSalt                   = errors.New("failed to create salt")
        ErrCreateSession                = errors.New("failed to create session")
        ErrDeleteSession                = errors.New("failed to delete session")
        ErrGetSession                   = errors.New("failed to get session")
        ErrStream                       = errors.New("stream not found")
        ErrUnauthorized                 = errors.New("this action is not allowed for unauthorized users")
        ErrPlaylistNotFound             = errors.New("playlist not found")
        ErrPlaylistPermissionDenied     = errors.New("user does not have permission for this playlist")
        ErrPlaylistBadRequest           = errors.New("invalid playlist request")
        ErrUnsupportedImageFormat       = errors.New("unsupported image format: only JPEG and PNG are allowed")
        ErrImageTooBig                  = errors.New("image size exceeds 5MB limit")
        ErrFailedToParseImage           = errors.New("failed to parse image")
        ErrFailedToUploadImage          = errors.New("failed to upload image")
        ErrFailedToCreatePlaylist       = errors.New("failed to create playlist")
        ErrPlaylistUnauthorized         = errors.New("unauthorized users can't create playlist")
        ErrPlaylistImageNotUploaded     = errors.New("playlist image not uploaded")
        ErrPlaylistDuplicate            = errors.New("playlist with this title by you already exists")
        ErrPlaylistTrackNotFound        = errors.New("track not found in playlist")
        ErrPlaylistTrackDuplicate       = errors.New("track already in playlist")
        ErrLableExist                   = errors.New("label already exist")
        ErrUnsupportedImageFormatError  = errors.New("unsupported image format")
        ErrFailedToUploadAlbumImage     = errors.New("failed to upload album image")
        ErrCreateRoomNotAllDataProvided = errors.New("not all data provided")
        ErrRoomIDRequired               = errors.New("room id is required")
        ErrInvalidSelection             = errors.New("invalid selection")
)

func HandleAlbumGRPCError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.NotFound:<span class="cov0" title="0">
                return ErrAlbumNotFound</span>
        case codes.Internal:<span class="cov0" title="0">
                return errors.New("internal server error: " + st.Message())</span>
        default:<span class="cov0" title="0">
                return err</span>
        }
}

func HandleArtistGRPCError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.NotFound:<span class="cov0" title="0">
                return ErrArtistNotFound</span>
        case codes.Internal:<span class="cov0" title="0">
                return errors.New("internal server error: " + st.Message())</span>
        default:<span class="cov0" title="0">
                return err</span>
        }
}

func HandleTrackGRPCError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.NotFound:<span class="cov0" title="0">
                switch st.Message() </span>{
                case "track not found":<span class="cov0" title="0">
                        return ErrTrackNotFound</span>
                case "stream not found":<span class="cov0" title="0">
                        return ErrStreamNotFound</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        case codes.PermissionDenied:<span class="cov0" title="0">
                return ErrStreamPermissionDenied</span>
        case codes.Internal:<span class="cov0" title="0">
                switch st.Message() </span>{
                case "failed to update stream duration":<span class="cov0" title="0">
                        return ErrFailedToUpdateStreamDuration</span>
                default:<span class="cov0" title="0">
                        return errors.New("internal server error: " + st.Message())</span>
                }
        default:<span class="cov0" title="0">
                return err</span>
        }
}

func HandleUserGRPCError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.NotFound:<span class="cov0" title="0">
                return ErrUserNotFound</span>
        case codes.AlreadyExists:<span class="cov0" title="0">
                return ErrUserExist</span>
        case codes.Unauthenticated:<span class="cov0" title="0">
                return ErrWrongPassword</span>
        case codes.InvalidArgument:<span class="cov0" title="0">
                return ErrPasswordRequired</span>
        case codes.Internal:<span class="cov0" title="0">
                switch st.Message() </span>{
                case "failed to create salt":<span class="cov0" title="0">
                        return ErrCreateSalt</span>
                default:<span class="cov0" title="0">
                        return errors.New("internal server error: " + st.Message())</span>
                }
        default:<span class="cov0" title="0">
                return err</span>
        }
}

func HandleAuthGRPCError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.Unavailable:<span class="cov0" title="0">
                return ErrGetSession</span>
        default:<span class="cov0" title="0">
                return err</span>
        }
}

func HandlePlaylistGRPCError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.NotFound:<span class="cov0" title="0">
                switch st.Message() </span>{
                case "playlist not found":<span class="cov0" title="0">
                        return ErrPlaylistNotFound</span>
                case "track not found in playlist":<span class="cov0" title="0">
                        return ErrPlaylistTrackNotFound</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        case codes.PermissionDenied:<span class="cov0" title="0">
                return ErrPlaylistPermissionDenied</span>
        case codes.InvalidArgument:<span class="cov0" title="0">
                switch st.Message() </span>{
                case "invalid playlist request":<span class="cov0" title="0">
                        return ErrPlaylistBadRequest</span>
                case "unsupported image format: only JPEG and PNG are allowed":<span class="cov0" title="0">
                        return ErrUnsupportedImageFormat</span>
                case "image size exceeds 5MB limit":<span class="cov0" title="0">
                        return ErrImageTooBig</span>
                case "failed to parse image":<span class="cov0" title="0">
                        return ErrFailedToParseImage</span>
                case "failed to upload image":<span class="cov0" title="0">
                        return ErrFailedToUploadImage</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        case codes.AlreadyExists:<span class="cov0" title="0">
                switch st.Message() </span>{
                case "playlist with this title by you already exists":<span class="cov0" title="0">
                        return ErrPlaylistDuplicate</span>
                case "track already in playlist":<span class="cov0" title="0">
                        return ErrPlaylistTrackDuplicate</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        case codes.Internal:<span class="cov0" title="0">
                return errors.New("internal server error: " + st.Message())</span>
        default:<span class="cov0" title="0">
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package customResponseWriter

import (
        "bufio"
        "net"
        "net/http"
)

type ResponseWriter struct {
        http.ResponseWriter
        StatusCode int
}

func NewResponseWriter(w http.ResponseWriter) *ResponseWriter <span class="cov0" title="0">{
        return &amp;ResponseWriter{
                ResponseWriter: w,
                StatusCode:     http.StatusOK,
        }
}</span>

func (rw *ResponseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.StatusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func (rw *ResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov0" title="0">{
        if hijacker, ok := rw.ResponseWriter.(http.Hijacker); ok </span><span class="cov0" title="0">{
                return hijacker.Hijack()
        }</span>
        <span class="cov0" title="0">return nil, nil, http.ErrNotSupported</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package errorStatus

import (
        "net/http"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
)

var mapErrorStatus = map[error]int{
        customErrors.ErrTrackNotFound:                http.StatusNotFound,
        customErrors.ErrStreamNotFound:               http.StatusNotFound,
        customErrors.ErrFailedToUpdateStreamDuration: http.StatusInternalServerError,
        customErrors.ErrStreamPermissionDenied:       http.StatusForbidden,

        customErrors.ErrUserExist:        http.StatusConflict,
        customErrors.ErrUserNotFound:     http.StatusNotFound,
        customErrors.ErrCreateSalt:       http.StatusInternalServerError,
        customErrors.ErrWrongPassword:    http.StatusUnauthorized,
        customErrors.ErrPasswordRequired: http.StatusBadRequest,

        customErrors.ErrCreateSession:                http.StatusInternalServerError,
        customErrors.ErrGetSession:                   http.StatusUnauthorized,
        customErrors.ErrDeleteSession:                http.StatusInternalServerError,
        customErrors.ErrInvalidOffset:                http.StatusBadRequest,
        customErrors.ErrInvalidLimit:                 http.StatusBadRequest,
        customErrors.ErrPasswordRequired:             http.StatusBadRequest,
        customErrors.ErrUnsupportedImageFormat:       http.StatusBadRequest,
        customErrors.ErrFailedToParseImage:           http.StatusBadRequest,
        customErrors.ErrArtistNotFound:               http.StatusNotFound,
        customErrors.ErrAlbumNotFound:                http.StatusNotFound,
        customErrors.ErrUnauthorized:                 http.StatusForbidden,
        customErrors.ErrPlaylistNotFound:             http.StatusNotFound,
        customErrors.ErrPlaylistPermissionDenied:     http.StatusForbidden,
        customErrors.ErrPlaylistDuplicate:            http.StatusConflict,
        customErrors.ErrPlaylistTrackNotFound:        http.StatusNotFound,
        customErrors.ErrPlaylistTrackDuplicate:       http.StatusConflict,
        customErrors.ErrPlaylistImageNotUploaded:     http.StatusBadRequest,
        customErrors.ErrPlaylistBadRequest:           http.StatusBadRequest,
        customErrors.ErrPlaylistUnauthorized:         http.StatusUnauthorized,
        customErrors.ErrCreateRoomNotAllDataProvided: http.StatusBadRequest,
        customErrors.ErrRoomIDRequired:               http.StatusBadRequest,
        customErrors.ErrInvalidSelection:             http.StatusBadRequest,
        customErrors.ErrLableExist:                   http.StatusBadRequest,
}

func ErrorStatus(err error) int <span class="cov0" title="0">{
        status, exists := mapErrorStatus[err]
        if !exists </span><span class="cov0" title="0">{
                return http.StatusInternalServerError
        }</span>
        <span class="cov0" title="0">return status</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package json

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "maps"
        "net/http"

        deliveryModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
        easyjson "github.com/mailru/easyjson"
        "go.uber.org/zap"
)

const (
        MaxBytes      = 1024 * 1024
        DefaultStatus = http.StatusOK
)

var (
        ErrMultipleJSONValues = errors.New("body must only contain a single JSON value")
)

func ReadJSON(w http.ResponseWriter, r *http.Request, v interface{}) error <span class="cov0" title="0">{
        maxBytes := int64(MaxBytes)
        r.Body = http.MaxBytesReader(w, r.Body, maxBytes)

        unmarshaler, ok := v.(easyjson.Unmarshaler)
        if ok </span><span class="cov0" title="0">{
                body, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to read request body")
                }</span>
                <span class="cov0" title="0">if err := easyjson.Unmarshal(body, unmarshaler); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal JSON: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">decoder := json.NewDecoder(r.Body)
        if err := decoder.Decode(v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := decoder.Decode(&amp;struct{}{}); err != io.EOF </span><span class="cov0" title="0">{
                return ErrMultipleJSONValues
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func WriteJSON(w http.ResponseWriter, status int, data interface{}, headers http.Header) <span class="cov0" title="0">{
        logger := zap.L().Sugar()
        var jsonData []byte
        var err error

        marshaler, ok := data.(easyjson.Marshaler)
        if ok </span><span class="cov0" title="0">{
                var buf bytes.Buffer
                if _, err := easyjson.MarshalToWriter(marshaler, &amp;buf); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to marshal JSON (easyjson)")
                        return
                }</span>
                <span class="cov0" title="0">jsonData = buf.Bytes()</span>
        } else<span class="cov0" title="0"> {
                jsonData, err = json.Marshal(data)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to marshal JSON (reflect)")
                        return
                }</span>
        }

        <span class="cov0" title="0">maps.Copy(w.Header(), headers)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        _, err = w.Write(jsonData)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to write json", zap.Error(err))
        }</span>
}

func WriteSuccessResponse(w http.ResponseWriter, status int, data interface{}, headers http.Header) <span class="cov0" title="0">{
        response := deliveryModel.APIResponse{
                Status: status,
                Body:   data,
        }

        WriteJSON(w, status, response, headers)
}</span>

func WriteErrorResponse(w http.ResponseWriter, status int, message string, headers http.Header) <span class="cov0" title="0">{
        response := deliveryModel.APIErrorResponse{
                Status: status,
                Error:  message,
        }

        WriteJSON(w, status, response, headers)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package logger

import (
        "context"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type LoggerKey struct{}

func NewZapLogger() (*zap.SugaredLogger, error) <span class="cov0" title="0">{
        config := zap.NewProductionConfig()
        config.EncoderConfig.TimeKey = "timestamp"
        config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

        logger, err := config.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return logger.Sugar(), nil</span>
}

func LoggerFromContext(ctx context.Context) *zap.SugaredLogger <span class="cov0" title="0">{
        logger := ctx.Value(LoggerKey{}).(*zap.SugaredLogger)
        return logger
}</span>

func LoggerToContext(ctx context.Context, logger *zap.SugaredLogger) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, LoggerKey{}, logger)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/collectors"
)

type Metrics struct {
        HTTPTotalNumberOfRequests *prometheus.CounterVec
        HTTPRequestDuration       *prometheus.HistogramVec
        // MicroserviceRequests        *prometheus.CounterVec
        // MicroserviceRequestDuration *prometheus.HistogramVec
        // MicroserviceErrors          *prometheus.CounterVec
}

/*
request_duration_seconds_bucket{le="0.0003"} 73
request_duration_seconds_bucket{le="0.00039999999999999996"} 77
request_duration_seconds_bucket{le="0.0005"} 82
request_duration_seconds_bucket{le="0.00075"} 83
request_duration_seconds_bucket{le="0.001"} 84
request_duration_seconds_bucket{le="0.003"} 137
request_duration_seconds_bucket{le="0.005"} 217
request_duration_seconds_bucket{le="0.0075"} 872 ----
request_duration_seconds_bucket{le="0.01"} 1596
request_duration_seconds_bucket{le="0.030000000000000002"} 5308
request_duration_seconds_bucket{le="0.05"} 5725
request_duration_seconds_bucket{le="0.07500000000000001"} 5760
request_duration_seconds_bucket{le="0.1"} 5773
request_duration_seconds_bucket{le="0.3"} 5813
request_duration_seconds_bucket{le="0.5"} 5819
request_duration_seconds_bucket{le="0.75"} 5821
request_duration_seconds_bucket{le="1.0"} 5823
request_duration_seconds_bucket{le="+Inf"} 5827
request_duration_seconds_count 5827
request_duration_seconds_sum 112.082849507
*/

func NewMetrics(reg prometheus.Registerer, namespace string) *Metrics <span class="cov0" title="0">{
        metrics := &amp;Metrics{
                HTTPTotalNumberOfRequests: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name:      "http_requests_total",
                                Help:      "Total number of HTTP requests",
                                Namespace: namespace,
                        },
                        []string{"method", "path", "status"},
                ),
                HTTPRequestDuration: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:      "http_request_duration_seconds",
                                Help:      "Duration of HTTP requests in seconds",
                                Buckets:   []float64{0.0003, 0.003, 0.004, 0.005, 0.0075, 0.009, 0.01, 0.015, 0.02, 0.025, 0.03, 0.05, 1.0},
                                Namespace: namespace,
                        },
                        []string{"method", "path"},
                ),
        }
        reg.MustRegister(collectors.NewGoCollector())
        reg.MustRegister(metrics.HTTPTotalNumberOfRequests)
        reg.MustRegister(metrics.HTTPRequestDuration)

        return metrics
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package pagination

import (
        "net/http"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        customErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        query "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/query"
        deliveryModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
)

func validatePagination(p *deliveryModel.Pagination, cfg *config.PaginationConfig) error <span class="cov0" title="0">{
        if p.Offset &gt; cfg.MaxOffset </span><span class="cov0" title="0">{
                p.Offset = cfg.MaxOffset
        }</span>

        <span class="cov0" title="0">if p.Offset &lt; 0 </span><span class="cov0" title="0">{
                p.Offset = 0
                return customErrors.ErrInvalidOffset
        }</span>

        <span class="cov0" title="0">if p.Limit &gt; cfg.MaxLimit </span><span class="cov0" title="0">{
                p.Limit = cfg.MaxLimit
        }</span>

        <span class="cov0" title="0">if p.Limit &lt; 0 </span><span class="cov0" title="0">{
                p.Limit = 0
                return customErrors.ErrInvalidLimit
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func GetPagination(r *http.Request, cfg *config.PaginationConfig) (*deliveryModel.Pagination, error) <span class="cov0" title="0">{
        pagination := &amp;deliveryModel.Pagination{}

        offset, err := query.ReadInt(r.URL.Query(), "offset", cfg.DefaultOffset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.ErrInvalidOffset
        }</span>

        <span class="cov0" title="0">limit, err := query.ReadInt(r.URL.Query(), "limit", cfg.DefaultLimit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.ErrInvalidLimit
        }</span>

        <span class="cov0" title="0">pagination.Offset = offset
        pagination.Limit = limit

        err = validatePagination(pagination, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return pagination, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package query

import (
        "net/url"
        "strconv"
)

func ReadInt(qs url.Values, key string, defaultValue int) (int, error) <span class="cov0" title="0">{
        str := qs.Get(key)
        if str == "" </span><span class="cov0" title="0">{
                return defaultValue, nil
        }</span>

        <span class="cov0" title="0">i, err := strconv.Atoi(str)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return i, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package artist

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/asaskevich/govalidator"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/errorStatus"
        jsonPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/json"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/jam"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        delivery "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
        "github.com/gorilla/mux"
        "github.com/gorilla/websocket"
        "go.uber.org/zap"
)

type JamHandler struct {
        usecase jam.Usecase
        cfg     *config.Config
}

func NewJamHandler(usecase jam.Usecase, cfg *config.Config) *JamHandler <span class="cov0" title="0">{
        return &amp;JamHandler{usecase: usecase, cfg: cfg}
}</span>

func (h *JamHandler) CreateRoom(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        userID, ok := ctxExtractor.UserFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                status := errorStatus.ErrorStatus(customErrors.ErrUnauthorized)
                logger.Error("user not found in context", zap.Error(customErrors.ErrUnauthorized))
                jsonPkg.WriteErrorResponse(w, status, customErrors.ErrUnauthorized.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">var request delivery.CreateJamRequest
        err := jsonPkg.ReadJSON(w, r, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                status := errorStatus.ErrorStatus(err)
                logger.Error("failed to read json", zap.Error(err))
                jsonPkg.WriteErrorResponse(w, status, err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">valid, err := govalidator.ValidateStruct(request)
        if err != nil </span><span class="cov0" title="0">{
                status := errorStatus.ErrorStatus(err)
                logger.Error("failed to validate struct", zap.Error(err))
                jsonPkg.WriteErrorResponse(w, status, err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                status := errorStatus.ErrorStatus(customErrors.ErrCreateRoomNotAllDataProvided)
                logger.Error("failed to validate struct", zap.Error(customErrors.ErrCreateRoomNotAllDataProvided))
                jsonPkg.WriteErrorResponse(w, status, customErrors.ErrCreateRoomNotAllDataProvided.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strconv.FormatInt(userID, 10)

        usecaseRequest := model.CreateJamRequestFromDeliveryToUsecase(&amp;request, userIDStr)
        usecaseResponse, err := h.usecase.CreateJam(ctx, usecaseRequest)
        if err != nil </span><span class="cov0" title="0">{
                status := errorStatus.ErrorStatus(err)
                logger.Error("failed to create jam", zap.Error(err))
                jsonPkg.WriteErrorResponse(w, status, err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">response := model.CreateJamResponseFromUsecaseToDelivery(usecaseResponse)
        jsonPkg.WriteSuccessResponse(w, http.StatusCreated, response, nil)</span>
}

func (h *JamHandler) WSHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, ok := ctxExtractor.UserFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                logger.Error("user not found in context", zap.Error(customErrors.ErrUnauthorized))
                http.Error(w, customErrors.ErrUnauthorized.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">roomID := mux.Vars(r)["id"]
        if roomID == "" </span><span class="cov0" title="0">{
                logger.Error("room id is required", zap.Error(customErrors.ErrRoomIDRequired))
                http.Error(w, customErrors.ErrRoomIDRequired.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">upgrader := websocket.Upgrader{CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                return true
        }</span>}

        <span class="cov0" title="0">wsConn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to upgrade to websocket", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strconv.FormatInt(userID, 10)

        usecaseRequest := usecase.JoinJamRequest{
                RoomID: roomID,
                UserID: userIDStr,
        }
        usecaseResponse, err := h.usecase.JoinJam(ctx, &amp;usecaseRequest)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to join jam", zap.Error(err))
                err = wsConn.WriteJSON(delivery.JamMessage{
                        Type:  "error",
                        Error: err.Error(),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to write error message to websocket", zap.Error(err))
                }</span>
                <span class="cov0" title="0">err = wsConn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close websocket", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response := model.JamMessageFromUsecaseToDelivery(usecaseResponse)
        err = wsConn.WriteJSON(response)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to write response to websocket", zap.Error(err))
        }</span>

        <span class="cov0" title="0">messageChan, err := h.usecase.SubscribeToJamMessages(ctx, roomID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to subscribe to jam messages", zap.Error(err))
                err = wsConn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close websocket", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case usecaseMessage, ok := &lt;-messageChan:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">deliveryMessage := model.JamMessageFromUsecaseToDelivery(usecaseMessage)
                                err := wsConn.WriteJSON(deliveryMessage)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Error("failed to write message to websocket", zap.Error(err))
                                        return
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, data, err := wsConn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        err := h.usecase.LeaveJam(ctx, roomID, userIDStr)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to leave jam", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">var m delivery.JamMessage
                err = json.Unmarshal(data, &amp;m)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to unmarshal message", zap.Error(err))
                        return
                }</span>

                <span class="cov0" title="0">usecaseMessage := model.JamMessageFromDeliveryToUsecase(&amp;m)

                err = h.usecase.HandleClientMessage(ctx, roomID, userIDStr, usecaseMessage)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to handle client message", zap.Error(err))
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package redis

import (
        "context"
        "encoding/json"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/jam"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/repository"
        "github.com/gomodule/redigo/redis"
        "github.com/google/uuid"
        "go.uber.org/zap"
)

type jamRedisRepository struct {
        redisPool *redis.Pool
}

func (r *jamRedisRepository) getConn() (redis.Conn, error) <span class="cov0" title="0">{
        conn := r.redisPool.Get()
        if err := conn.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

func NewJamRedisRepository(redisPool *redis.Pool) jam.Repository <span class="cov0" title="0">{
        return &amp;jamRedisRepository{redisPool: redisPool}
}</span>

func (r *jamRedisRepository) CreateJam(ctx context.Context, request *repository.CreateJamRequest) (*repository.CreateJamResponse, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        jamID := uuid.New().String()
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "SET", "jam:"+jamID+":host", request.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "HMSET", "jam:"+jamID+":track",
                "id", request.TrackID,
                "position", request.Position,
                "paused", 1,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;repository.CreateJamResponse{
                RoomID: jamID,
                HostID: request.UserID,
        }, nil</span>
}

func (r *jamRedisRepository) AddUser(ctx context.Context, roomID string, userID string) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "SADD", "jam:"+roomID+":users", userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">username, avatarURL, _ := r.GetUserInfo(ctx, roomID, userID)

        joinPayload, err := json.Marshal(repository.JamMessage{
                Type:       "user:joined",
                UserID:     userID,
                UserNames:  map[string]string{userID: username},
                UserImages: map[string]string{userID: avatarURL},
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "PUBLISH", "jam:"+roomID+":pubsub", string(joinPayload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *jamRedisRepository) PauseJam(ctx context.Context, roomID string) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "HSET", "jam:"+roomID+":track", "paused", true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pausedPayload, err := json.Marshal(repository.JamMessage{
                Type: "pause",
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "PUBLISH", "jam:"+roomID+":pubsub", string(pausedPayload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *jamRedisRepository) GetInitialJamData(ctx context.Context, roomID string) (*repository.JamMessage, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">track, err := redis.StringMap(redis.DoContext(conn, ctx, "HGETALL", "jam:"+roomID+":track"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">users, err := redis.Strings(redis.DoContext(conn, ctx, "SMEMBERS", "jam:"+roomID+":users"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">hostID, err := redis.String(redis.DoContext(conn, ctx, "GET", "jam:"+roomID+":host"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">paused := track["paused"] == "1"

        position, err := redis.Int64(redis.DoContext(conn, ctx, "HGET", "jam:"+roomID+":track", "position"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">loadedMap := make(map[string]bool)
        for _, u := range users </span><span class="cov0" title="0">{
                isLoaded, _ := redis.Bool(redis.DoContext(conn, ctx, "SISMEMBER", "jam:"+roomID+":loaded", u))
                loadedMap[u] = isLoaded
        }</span>

        <span class="cov0" title="0">userNames := make(map[string]string)
        userImages := make(map[string]string)

        allUserIDs := make(map[string]bool)
        if hostID != "" </span><span class="cov0" title="0">{
                allUserIDs[hostID] = true
        }</span>
        <span class="cov0" title="0">for _, userID := range users </span><span class="cov0" title="0">{
                allUserIDs[userID] = true
        }</span>

        <span class="cov0" title="0">for userID := range allUserIDs </span><span class="cov0" title="0">{
                username, avatarURL, err := r.GetUserInfo(ctx, roomID, userID)
                if err == nil </span><span class="cov0" title="0">{
                        if username != "" </span><span class="cov0" title="0">{
                                userNames[userID] = username
                        }</span>
                        <span class="cov0" title="0">if avatarURL != "" </span><span class="cov0" title="0">{
                                userImages[userID] = avatarURL
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;repository.JamMessage{
                Type:       "init",
                TrackID:    track["id"],
                Position:   position,
                Paused:     paused,
                Users:      users,
                HostID:     hostID,
                Loaded:     loadedMap,
                UserNames:  userNames,
                UserImages: userImages,
        }, nil</span>
}

func (r *jamRedisRepository) GetHostID(ctx context.Context, roomID string) (string, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">hostID, err := redis.String(redis.DoContext(conn, ctx, "GET", "jam:"+roomID+":host"))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hostID, nil</span>
}

func (r *jamRedisRepository) CheckAllReadyAndPlay(ctx context.Context, roomID string) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">total, _ := redis.Int(redis.DoContext(conn, ctx, "SCARD", "jam:"+roomID+":users"))
        loaded, _ := redis.Int(redis.DoContext(conn, ctx, "SCARD", "jam:"+roomID+":loaded"))
        if loaded &gt;= total </span><span class="cov0" title="0">{
                payload, err := json.Marshal(repository.JamMessage{
                        Type: "play",
                })
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "PUBLISH", "jam:"+roomID+":pubsub", string(payload))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

func (r *jamRedisRepository) LoadTrack(ctx context.Context, roomID string, trackID string) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "HMSET", "jam:"+roomID+":track", "id", trackID, "position", 0, "paused", 1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "DEL", "jam:"+roomID+":loaded")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">loadMessageKey := "jam:" + roomID + ":loadmessage:" + trackID
        exists, err := redis.Bool(redis.DoContext(conn, ctx, "EXISTS", loadMessageKey))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "SETEX", loadMessageKey, 10, "1")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">payload, err := json.Marshal(repository.JamMessage{
                Type:    "load",
                TrackID: trackID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "PUBLISH", "jam:"+roomID+":pubsub", string(payload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *jamRedisRepository) MarkUserAsReady(ctx context.Context, roomID string, userID string) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "SADD", "jam:"+roomID+":loaded", userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">users, err := redis.Strings(redis.DoContext(conn, ctx, "SMEMBERS", "jam:"+roomID+":users"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">loadedMap := make(map[string]bool)
        for _, u := range users </span><span class="cov0" title="0">{
                isLoaded, _ := redis.Bool(redis.DoContext(conn, ctx, "SISMEMBER", "jam:"+roomID+":loaded", u))
                loadedMap[u] = isLoaded
        }</span>
        <span class="cov0" title="0">payload, err := json.Marshal(repository.JamMessage{
                Type:   "ready",
                Loaded: loadedMap,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "PUBLISH", "jam:"+roomID+":pubsub", string(payload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *jamRedisRepository) RemoveUser(ctx context.Context, roomID string, userID string) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "SREM", "jam:"+roomID+":users", userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "DEL", "jam:"+roomID+":userinfo:"+userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">payload, err := json.Marshal(repository.JamMessage{
                Type:   "user:left",
                UserID: userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "PUBLISH", "jam:"+roomID+":pubsub", string(payload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *jamRedisRepository) RemoveJam(ctx context.Context, roomID string) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">users, _ := redis.Strings(redis.DoContext(conn, ctx, "SMEMBERS", "jam:"+roomID+":users"))
        hostID, _ := redis.String(redis.DoContext(conn, ctx, "GET", "jam:"+roomID+":host"))

        allUserIDs := make(map[string]bool)
        if hostID != "" </span><span class="cov0" title="0">{
                allUserIDs[hostID] = true
        }</span>
        <span class="cov0" title="0">for _, userID := range users </span><span class="cov0" title="0">{
                allUserIDs[userID] = true
        }</span>

        <span class="cov0" title="0">for userID := range allUserIDs </span><span class="cov0" title="0">{
                _, err = redis.DoContext(conn, ctx, "DEL", "jam:"+roomID+":userinfo:"+userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "DEL", "jam:"+roomID+":host")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "DEL", "jam:"+roomID+":track")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "DEL", "jam:"+roomID+":users")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "DEL", "jam:"+roomID+":loaded")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">payload, err := json.Marshal(repository.JamMessage{
                Type: "jam:closed",
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "PUBLISH", "jam:"+roomID+":pubsub", string(payload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "DEL", "jam:"+roomID+":pubsub")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *jamRedisRepository) ExistsRoom(ctx context.Context, roomID string) (bool, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">exists, err := redis.Bool(redis.DoContext(conn, ctx, "EXISTS", "jam:"+roomID+":host"))
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}

func (r *jamRedisRepository) SeekJam(ctx context.Context, roomID string, position int64) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "HSET", "jam:"+roomID+":track", "position", position)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">seekPayload, err := json.Marshal(repository.JamMessage{
                Type:     "seek",
                Position: position,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "PUBLISH", "jam:"+roomID+":pubsub", string(seekPayload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *jamRedisRepository) StoreUserInfo(ctx context.Context, roomID string, userID string, username string, avatarURL string) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = redis.DoContext(conn, ctx, "HMSET", "jam:"+roomID+":userinfo:"+userID,
                "username", username,
                "avatar", avatarURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *jamRedisRepository) GetUserInfo(ctx context.Context, roomID string, userID string) (string, string, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">userInfo, err := redis.StringMap(redis.DoContext(conn, ctx, "HGETALL", "jam:"+roomID+":userinfo:"+userID))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">username := userInfo["username"]
        avatarURL := userInfo["avatar"]

        return username, avatarURL, nil</span>
}

func (r *jamRedisRepository) SubscribeToJamMessages(ctx context.Context, roomID string) (&lt;-chan []byte, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        conn, err := r.getConn()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pubSub := redis.PubSubConn{Conn: conn}
        err = pubSub.Subscribe("jam:" + roomID + ":pubsub")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">messageChan := make(chan []byte, 100)

        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Error closing connection:", zap.Error(err))
                        }</span>
                }()
                <span class="cov0" title="0">defer close(messageChan)
                defer func() </span><span class="cov0" title="0">{
                        if err := pubSub.Unsubscribe(); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Error unsubscribing from jam messages:", zap.Error(err))
                        }</span>
                }()

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                switch v := pubSub.Receive().(type) </span>{
                                case redis.Message:<span class="cov0" title="0">
                                        select </span>{
                                        case messageChan &lt;- v.Data:<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                case error:<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return messageChan, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package usecase

import (
        "context"
        "encoding/json"
        "errors"
        "strconv"

        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/jam"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/repository"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
        "go.uber.org/zap"
)

type Usecase struct {
        jamRepository jam.Repository
        userClient    userProto.UserServiceClient
}

func NewUsecase(jamRepository jam.Repository, userClient userProto.UserServiceClient) *Usecase <span class="cov0" title="0">{
        return &amp;Usecase{
                jamRepository: jamRepository,
                userClient:    userClient,
        }
}</span>

func (u *Usecase) CreateJam(ctx context.Context, request *usecase.CreateJamRequest) (*usecase.CreateJamResponse, error) <span class="cov0" title="0">{
        repoRequest := &amp;repository.CreateJamRequest{
                UserID:   request.UserID,
                TrackID:  request.TrackID,
                Position: request.Position,
        }
        jamResponse, err := u.jamRepository.CreateJam(ctx, repoRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = u.storeUserInfo(ctx, jamResponse.RoomID, request.UserID)
        if err != nil </span><span class="cov0" title="0">{
                logger := loggerPkg.LoggerFromContext(ctx)
                logger.Error("failed to store host user info", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return &amp;usecase.CreateJamResponse{
                RoomID: jamResponse.RoomID,
                HostID: jamResponse.HostID,
        }, nil</span>
}

func (u *Usecase) JoinJam(ctx context.Context, request *usecase.JoinJamRequest) (*usecase.JamMessage, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        exists, err := u.jamRepository.ExistsRoom(ctx, request.RoomID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to check if room exists", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, errors.New("room not found")
        }</span>
        <span class="cov0" title="0">hostID, err := u.jamRepository.GetHostID(ctx, request.RoomID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get host id", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">if hostID != request.UserID </span><span class="cov0" title="0">{
                err = u.storeUserInfo(ctx, request.RoomID, request.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to store user info", zap.Error(err))
                }</span>

                <span class="cov0" title="0">err = u.jamRepository.AddUser(ctx, request.RoomID, request.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to add user", zap.Error(err))
                        return nil, err
                }</span>

                <span class="cov0" title="0">err = u.jamRepository.PauseJam(ctx, request.RoomID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to pause jam", zap.Error(err))
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">repoJamData, err := u.jamRepository.GetInitialJamData(ctx, request.RoomID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get initial jam data", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">jamData := model.JamMessageFromRepositoryToUsecase(repoJamData)

        return jamData, nil</span>
}

func (u *Usecase) storeUserInfo(ctx context.Context, roomID string, userIDStr string) error <span class="cov0" title="0">{
        userID, err := strconv.ParseInt(userIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">userProtoData, err := u.userClient.GetUserByID(ctx, &amp;userProto.UserID{Id: userID})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">username := userProtoData.Username
        avatarURL := ""

        if userProtoData.Avatar != "" </span><span class="cov0" title="0">{
                avatarURLProto, err := u.userClient.GetUserAvatarURL(ctx, &amp;userProto.FileKey{FileKey: userProtoData.Avatar})
                if err == nil </span><span class="cov0" title="0">{
                        avatarURL = avatarURLProto.Url
                }</span>
        }

        <span class="cov0" title="0">return u.jamRepository.StoreUserInfo(ctx, roomID, userIDStr, username, avatarURL)</span>
}

func (u *Usecase) HandleClientMessage(ctx context.Context, roomID string, userID string, m *usecase.JamMessage) error <span class="cov0" title="0">{
        if m.Type == "jam:closed" </span><span class="cov0" title="0">{
                return errors.New("jam closed")
        }</span>

        <span class="cov0" title="0">hostID, err := u.jamRepository.GetHostID(ctx, roomID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">isHost := hostID == userID

        switch m.Type </span>{
        case "host:load":<span class="cov0" title="0">
                if !isHost </span><span class="cov0" title="0">{
                        return errors.New("not host")
                }</span>
                <span class="cov0" title="0">err := u.jamRepository.LoadTrack(ctx, roomID, m.TrackID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = u.jamRepository.PauseJam(ctx, roomID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.jamRepository.CheckAllReadyAndPlay(ctx, roomID)</span>
        case "client:ready":<span class="cov0" title="0">
                if isHost </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">err := u.jamRepository.MarkUserAsReady(ctx, roomID, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.jamRepository.CheckAllReadyAndPlay(ctx, roomID)</span>
        case "host:play":<span class="cov0" title="0">
                if !isHost </span><span class="cov0" title="0">{
                        return errors.New("not host")
                }</span>
                <span class="cov0" title="0">u.jamRepository.CheckAllReadyAndPlay(ctx, roomID)</span>
        case "host:pause":<span class="cov0" title="0">
                if !isHost </span><span class="cov0" title="0">{
                        return errors.New("not host")
                }</span>
                <span class="cov0" title="0">err := u.jamRepository.PauseJam(ctx, roomID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case "host:seek":<span class="cov0" title="0">
                if !isHost </span><span class="cov0" title="0">{
                        return errors.New("not host")
                }</span>
                <span class="cov0" title="0">err := u.jamRepository.SeekJam(ctx, roomID, m.Position)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (u *Usecase) LeaveJam(ctx context.Context, roomID string, userID string) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        hostID, err := u.jamRepository.GetHostID(ctx, roomID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get host id", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">if hostID == userID </span><span class="cov0" title="0">{
                err = u.jamRepository.RemoveJam(ctx, roomID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to remove jam", zap.Error(err))
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">err = u.jamRepository.RemoveUser(ctx, roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to remove user", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">u.jamRepository.CheckAllReadyAndPlay(ctx, roomID)
        return nil</span>
}

func (u *Usecase) SubscribeToJamMessages(ctx context.Context, roomID string) (&lt;-chan *usecase.JamMessage, error) <span class="cov0" title="0">{
        repoMessageChan, err := u.jamRepository.SubscribeToJamMessages(ctx, roomID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">usecaseMessageChan := make(chan *usecase.JamMessage, 100)

        go func() </span><span class="cov0" title="0">{
                defer close(usecaseMessageChan)

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case repoMessage, ok := &lt;-repoMessageChan:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">var repoJamMessage repository.JamMessage
                                err := json.Unmarshal(repoMessage, &amp;repoJamMessage)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">usecaseMessage := model.JamMessageFromRepositoryToUsecase(&amp;repoJamMessage)

                                select </span>{
                                case usecaseMessageChan &lt;- usecaseMessage:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return usecaseMessageChan, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package http

import (
        "io"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/errorStatus"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/json"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/pagination"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/label/domain"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

type LabelHandler struct {
        usecase domain.Usecase
        cfg     *config.Config
}

func NewLabelHandler(usecase domain.Usecase, cfg *config.Config) *LabelHandler <span class="cov10" title="9">{
        return &amp;LabelHandler{usecase: usecase, cfg: cfg}
}</span>

// CreateLabel godoc
// @Summary Create a new label
// @Description Creates a new label in the system. Only accessible by administrators.
// @Tags label
// @Accept json
// @Produce json
// @Security AdminAuth
// @Param label body delivery.Label true "Label information"
// @Success 201 {object} delivery.Label "Created label"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid input"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized - admin access required"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label [post]
func (h *LabelHandler) CreateLabel(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        isAdmin := ctxExtractor.AdminFromContext(ctx)
        if !isAdmin </span><span class="cov1" title="1">{
                logger.Error("Unauthorized access attempt")
                json.WriteErrorResponse(w, http.StatusUnauthorized, "Unauthorized", nil)
                return
        }</span>

        <span class="cov3" title="2">var label *delivery.Label

        err := json.ReadJSON(w, r, &amp;label)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to read JSON", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "Failed to read JSON", nil)
                return
        }</span>
        <span class="cov1" title="1">labelUsecase := model.LabelFromDeliveryToUsecase(label)
        newLabel, err := h.usecase.CreateLabel(ctx, labelUsecase)
        if err != nil </span><span class="cov0" title="0">{
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">newLabelDelivery := model.LabelFromUsecaseToDelivery(newLabel)
        json.WriteSuccessResponse(w, http.StatusCreated, newLabelDelivery, nil)</span>
}

// GetLabel godoc
// @Summary Get label by ID
// @Description Retrieves a label by its ID. Only accessible by administrators.
// @Tags label
// @Accept json
// @Produce json
// @Security AdminAuth
// @Param id path integer true "Label ID"
// @Success 200 {object} delivery.Label "Label information"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid label ID"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized - admin access required"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label/{id} [get]
func (h *LabelHandler) GetLabel(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        isAdmin := ctxExtractor.AdminFromContext(ctx)
        if !isAdmin </span><span class="cov1" title="1">{
                logger.Error("Unauthorized access attempt")
                json.WriteErrorResponse(w, http.StatusUnauthorized, "Unauthorized", nil)
                return
        }</span>
        <span class="cov3" title="2">vars := mux.Vars(r)
        labelID := vars["id"]
        labelIDInt, err := strconv.ParseInt(labelID, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Invalid label ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "Invalid label ID", nil)
                return
        }</span>

        <span class="cov1" title="1">label, err := h.usecase.GetLabel(ctx, labelIDInt)
        if err != nil </span><span class="cov0" title="0">{
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">labelDelivery := model.LabelFromUsecaseToDelivery(label)
        json.WriteSuccessResponse(w, http.StatusOK, labelDelivery, nil)</span>
}

// CreateArtist godoc
// @Summary Create a new artist
// @Description Creates a new artist associated with the label. Only accessible by label members.
// @Tags label
// @Accept multipart/form-data
// @Produce json
// @Security LabelAuth
// @Param title formData string true "Artist name"
// @Param thumbnail formData file true "Artist profile image (max 6MB)"
// @Success 201 {object} delivery.Artist "Created artist"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid input"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 403 {object} delivery.APIForbiddenErrorResponse "Forbidden - user not in label"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label/artist [post]
func (h *LabelHandler) CreateArtist(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        labelID, isLabel := ctxExtractor.LabelFromContext(ctx)
        if !isLabel </span><span class="cov1" title="1">{
                logger.Error("failed to get labelID")
                json.WriteErrorResponse(w, http.StatusForbidden, "user not in label", nil)
                return
        }</span>

        <span class="cov3" title="2">if r.ContentLength &gt; 6&lt;&lt;20 </span><span class="cov0" title="0">{
                logger.Error("request body too large")
                json.WriteErrorResponse(w, http.StatusBadRequest, "request body too large", nil)
                return
        }</span>

        <span class="cov3" title="2">err := r.ParseMultipartForm(6 &lt;&lt; 20)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to parse multipart form", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">request := &amp;delivery.CreateArtistRequest{}

        request.Title = r.FormValue("title")
        if request.Title == "" </span><span class="cov1" title="1">{
                logger.Error("title is empty")
                json.WriteErrorResponse(w, http.StatusBadRequest, "title is empty", nil)
                return
        }</span>

        <span class="cov1" title="1">if len(request.Title) &gt; 100 </span><span class="cov0" title="0">{
                logger.Error("title is too long")
                json.WriteErrorResponse(w, http.StatusBadRequest, "title is too long", nil)
                return
        }</span>

        <span class="cov1" title="1">file, _, err := r.FormFile("thumbnail")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get thumbnail", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "thumbnail image is required", nil)
                return
        }</span>

        <span class="cov1" title="1">request.Image, err = io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read thumbnail", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(customErrors.ErrPlaylistImageNotUploaded), customErrors.ErrPlaylistImageNotUploaded.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">request.LabelID = labelID
        usecaseArtist := model.ArtistLoadFromDeliveryToUsecase(request)

        artist, err := h.usecase.CreateArtist(ctx, usecaseArtist)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create artist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>
        <span class="cov1" title="1">artistResponse := model.ArtistFromUsecaseToDelivery(artist)

        json.WriteSuccessResponse(w, http.StatusCreated, artistResponse, nil)</span>
}

// EditArtist godoc
// @Summary Edit an existing artist
// @Description Updates an artist's information (name and/or image). Only accessible by label members.
// @Tags label
// @Accept multipart/form-data
// @Produce json
// @Security LabelAuth
// @Param artist_id formData string true "Artist ID to edit"
// @Param new_title formData string false "New artist name (required if thumbnail is not provided)"
// @Param thumbnail formData file false "New artist profile image (required if new_title is not provided, max 6MB)"
// @Success 200 {object} delivery.Artist "Updated artist"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid input"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 403 {object} delivery.APIForbiddenErrorResponse "Forbidden - user not in label"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label/artist [put]
func (h *LabelHandler) EditArtist(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        labelID, isLabel := ctxExtractor.LabelFromContext(ctx)
        if !isLabel </span><span class="cov0" title="0">{
                logger.Error("failed to get labelID")
                json.WriteErrorResponse(w, http.StatusForbidden, "user not in label", nil)
                return
        }</span>

        <span class="cov1" title="1">if r.ContentLength &gt; 6&lt;&lt;20 </span><span class="cov0" title="0">{
                logger.Error("request body too large")
                json.WriteErrorResponse(w, http.StatusBadRequest, "request body too large", nil)
                return
        }</span>

        <span class="cov1" title="1">editRequest := &amp;delivery.EditArtistRequest{}

        artistID := r.FormValue("artist_id")
        if artistID == "" </span><span class="cov0" title="0">{
                logger.Error("artist_id is empty")
                json.WriteErrorResponse(w, http.StatusBadRequest, "artist_id is empty", nil)
                return
        }</span>

        <span class="cov1" title="1">artistIdInt, err := strconv.Atoi(artistID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to parse artist_id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "failed to parse artist_id", nil)
                return
        }</span>
        <span class="cov1" title="1">artistIdInt64 := int64(artistIdInt)
        editRequest.ArtistID = artistIdInt64

        editRequest.NewTitle = r.FormValue("new_title")
        if len(editRequest.NewTitle) &gt; 100 </span><span class="cov0" title="0">{
                logger.Error("new title is too long")
                json.WriteErrorResponse(w, http.StatusBadRequest, "new title is too long", nil)
                return
        }</span>

        <span class="cov1" title="1">file, _, err := r.FormFile("thumbnail")
        if err == nil </span><span class="cov1" title="1">{
                editRequest.Image, err = io.ReadAll(file)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to read thumbnail", zap.Error(err))
                        json.WriteErrorResponse(w, errorStatus.ErrorStatus(customErrors.ErrPlaylistImageNotUploaded), customErrors.ErrPlaylistImageNotUploaded.Error(), nil)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                editRequest.Image = nil
        }</span>
        <span class="cov1" title="1">editRequest.LabelID = labelID

        if editRequest.NewTitle == "" &amp;&amp; editRequest.Image == nil </span><span class="cov0" title="0">{
                logger.Error("new title and image are empty")
                json.WriteErrorResponse(w, http.StatusBadRequest, "new title and image are empty", nil)
                return
        }</span>

        <span class="cov1" title="1">artistEditUsecase := model.ArtistEditFromDeliveryToUsecase(editRequest)
        artist, err := h.usecase.EditArtist(ctx, artistEditUsecase)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to edit artist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>
        <span class="cov1" title="1">artistResponse := model.ArtistFromUsecaseToDelivery(artist)
        json.WriteSuccessResponse(w, http.StatusOK, artistResponse, nil)</span>
}

// GetArtists godoc
// @Summary Get artists in a label
// @Description Retrieves a list of artists associated with the user's label with optional pagination
// @Tags label
// @Accept json
// @Produce json
// @Security LabelAuth
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Artist} "List of artists in the label"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid pagination parameters"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 403 {object} delivery.APIForbiddenErrorResponse "Forbidden - user not in label"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label/artists [get]
func (h *LabelHandler) GetArtists(w http.ResponseWriter, r *http.Request) <span class="cov3" title="2">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        labelID, isLabel := ctxExtractor.LabelFromContext(ctx)
        if !isLabel </span><span class="cov1" title="1">{
                logger.Error("failed to get labelID")
                json.WriteErrorResponse(w, http.StatusForbidden, "user not in label", nil)
                return
        }</span>

        <span class="cov1" title="1">pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">usecaseArtists, err := h.usecase.GetArtists(ctx, labelID, &amp;usecase.ArtistFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get artists", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">artistsDelivery := model.ArtistsFromUsecaseToDelivery(usecaseArtists)
        json.WriteSuccessResponse(w, http.StatusOK, artistsDelivery, nil)</span>
}

// DeleteArtist godoc
// @Summary Delete an artist
// @Description Removes an artist from the label. Only accessible by label members.
// @Tags label
// @Accept json
// @Produce json
// @Security LabelAuth
// @Param request body delivery.DeleteArtistRequest true "Artist deletion request containing title"
// @Success 200 {object} delivery.DeleteArtistRequest "Artist deleted successfully"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid input"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 403 {object} delivery.APIForbiddenErrorResponse "Forbidden - user not in label"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label/artist [delete]
func (h *LabelHandler) DeleteArtist(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        labelID, isLabel := ctxExtractor.LabelFromContext(ctx)
        if !isLabel </span><span class="cov1" title="1">{
                logger.Error("failed to get labelID")
                json.WriteErrorResponse(w, http.StatusUnauthorized, "user not in label", nil)
                return
        }</span>

        <span class="cov3" title="2">deleteArtistRequest := &amp;delivery.DeleteArtistRequest{}

        err := json.ReadJSON(w, r, &amp;deleteArtistRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to read JSON", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">deleteArtistRequest.LabelID = labelID

        err = h.usecase.DeleteArtist(ctx, model.ArtistDeleteFromDeliveryToUsecase(deleteArtistRequest))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete artist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">json.WriteSuccessResponse(w, http.StatusOK, deleteArtistRequest, nil)</span>
}

// CreateAlbum godoc
// @Summary Create a new album
// @Description Creates a new album with tracks. Only accessible by label members.
// @Tags label
// @Accept multipart/form-data
// @Produce json
// @Security LabelAuth
// @Param title formData string true "Album title (max 100 characters)"
// @Param type formData string true "Album type (album, single, ep, compilation)"
// @Param artists_ids formData string true "Comma-separated list of artist IDs"
// @Param thumbnail formData file true "Album cover image"
// @Param tracks[] formData file true "Array of track files"
// @Param track_titles[] formData []string true "Array of track titles corresponding to tracks[]"
// @Success 201 {object} delivery.SuccessCreateAlbum "Created album ID"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid input"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 403 {object} delivery.APIForbiddenErrorResponse "Forbidden - user not in label"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label/album [post]
func (h *LabelHandler) CreateAlbum(w http.ResponseWriter, r *http.Request) <span class="cov7" title="5">{
        ctx := r.Context()

        logger := loggerPkg.LoggerFromContext(ctx)

        labelID, isLabel := ctxExtractor.LabelFromContext(ctx)
        if !isLabel </span><span class="cov1" title="1">{
                logger.Error("failed to get labelID")
                json.WriteErrorResponse(w, http.StatusUnauthorized, "user not in label", nil)
                return
        }</span>

        <span class="cov6" title="4">if r.ContentLength &gt; 300&lt;&lt;20 </span><span class="cov0" title="0">{
                logger.Error("request body too large")
                json.WriteErrorResponse(w, http.StatusBadRequest, "request body too large", nil)
                return
        }</span>

        <span class="cov6" title="4">err := r.ParseMultipartForm(300 &lt;&lt; 20)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to parse multipart form", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "failed to parse multipart form", nil)
                return
        }</span>

        <span class="cov6" title="4">request := &amp;delivery.CreateAlbumRequest{}
        request.LabelID = labelID

        request.Title = r.FormValue("title")
        if request.Title == "" </span><span class="cov1" title="1">{
                logger.Error("title is empty")
                json.WriteErrorResponse(w, http.StatusBadRequest, "title is empty", nil)
                return
        }</span>
        <span class="cov5" title="3">if len(request.Title) &gt; 100 </span><span class="cov0" title="0">{
                logger.Error("title is too long")
                json.WriteErrorResponse(w, http.StatusBadRequest, "title is too long", nil)
                return
        }</span>

        <span class="cov5" title="3">request.Type = r.FormValue("type")
        if request.Type == "" </span><span class="cov1" title="1">{
                logger.Error("type is empty")
                json.WriteErrorResponse(w, http.StatusBadRequest, "type is empty", nil)
                return
        }</span>
        <span class="cov3" title="2">if request.Type != "album" &amp;&amp; request.Type != "single" &amp;&amp; request.Type != "ep" &amp;&amp; request.Type != "compilation" </span><span class="cov1" title="1">{
                logger.Error("type is invalid")
                json.WriteErrorResponse(w, http.StatusBadRequest, "type is invalid", nil)
                return
        }</span>

        <span class="cov1" title="1">ArtistIDs := r.FormValue("artists_ids")
        ArtistIDsSlice := strings.Split(ArtistIDs, ",")
        for _, id := range ArtistIDsSlice </span><span class="cov3" title="2">{
                parsedID, err := strconv.ParseInt(id, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to parse artists_ids", zap.Error(err))
                        json.WriteErrorResponse(w, http.StatusBadRequest, "failed to parse artists_ids", nil)
                        return
                }</span>
                <span class="cov3" title="2">request.ArtistsIDs = append(request.ArtistsIDs, parsedID)</span>
        }

        <span class="cov1" title="1">file, _, err := r.FormFile("thumbnail")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get thumbnail", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "thumbnail image is required", nil)
                return
        }</span>
        <span class="cov1" title="1">request.Image, err = io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read thumbnail", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "failed to read thumbnail", nil)
                return
        }</span>

        <span class="cov1" title="1">fileHeaders := r.MultipartForm.File["tracks[]"]
        if len(fileHeaders) == 0 </span><span class="cov0" title="0">{
                logger.Error("tracks are empty")
                json.WriteErrorResponse(w, http.StatusBadRequest, "tracks are empty", nil)
                return
        }</span>

        <span class="cov1" title="1">tracks := make([]*delivery.CreateTrackRequest, 0, len(fileHeaders))
        trackTitles := r.Form["track_titles[]"]
        if len(trackTitles) != len(fileHeaders) </span><span class="cov0" title="0">{
                logger.Error("track titles count does not match tracks count")
                json.WriteErrorResponse(w, http.StatusBadRequest, "track titles count does not match tracks count", nil)
                return
        }</span>

        <span class="cov1" title="1">for i, fileHeader := range fileHeaders </span><span class="cov1" title="1">{
                track := &amp;delivery.CreateTrackRequest{
                        Title: trackTitles[i],
                }

                if fileHeader.Size &gt; 50&lt;&lt;20 </span><span class="cov0" title="0">{
                        logger.Error("track is too large")
                        json.WriteErrorResponse(w, http.StatusBadRequest, "track is too large", nil)
                        return
                }</span>

                <span class="cov1" title="1">file, err := fileHeader.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to open track file", zap.Error(err))
                        json.WriteErrorResponse(w, http.StatusBadRequest, "failed to open track file", nil)
                        return
                }</span>
                <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to close track file", zap.Error(err))
                        }</span>
                }()

                <span class="cov1" title="1">track.Track, err = io.ReadAll(file)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to read track file", zap.Error(err))
                        json.WriteErrorResponse(w, http.StatusBadRequest, "failed to read track file", nil)
                        return
                }</span>

                <span class="cov1" title="1">tracks = append(tracks, track)</span>
        }

        <span class="cov1" title="1">request.Tracks = tracks

        albumID, albumURL, err := h.usecase.CreateAlbum(ctx, model.NewAlbumFromDeliveryToUsecase(request))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create album", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">artists := make([]*delivery.AlbumArtist, 0, len(request.ArtistsIDs))
        for _, artistID := range request.ArtistsIDs </span><span class="cov3" title="2">{
                artist := &amp;delivery.AlbumArtist{
                        ID:    artistID,
                        Title: "",
                }
                artists = append(artists, artist)
        }</span>

        <span class="cov1" title="1">deliveryAlbum := delivery.Album{
                ID:          albumID,
                Title:       request.Title,
                Type:        model.AlbumTypeConverter(request.Type),
                Thumbnail:   albumURL,
                ReleaseDate: time.Now(),
                Artists:     artists,
        }

        json.WriteSuccessResponse(w, http.StatusCreated, deliveryAlbum, nil)</span>
}

// UpdateLabel godoc
// @Summary Update a label
// @Description Updates a label by adding or removing users. Only accessible by administrators.
// @Tags label
// @Accept json
// @Produce json
// @Security AdminAuth
// @Param request body delivery.EditLabelRequest true "Label update information containing labelID, users to add, and users to remove"
// @Success 200 {object} delivery.Message "Label edited successfully"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid input"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized - admin access required"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label [put]
func (h *LabelHandler) UpdateLabel(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        isAdmin := ctxExtractor.AdminFromContext(ctx)
        if !isAdmin </span><span class="cov1" title="1">{
                logger.Error("Unauthorized access attempt")
                json.WriteErrorResponse(w, http.StatusUnauthorized, "Unauthorized", nil)
                return
        }</span>

        <span class="cov3" title="2">var label *delivery.EditLabelRequest

        err := json.ReadJSON(w, r, &amp;label)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to read JSON", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "Failed to read JSON", nil)
                return
        }</span>

        <span class="cov1" title="1">err = h.usecase.UpdateLabel(ctx, label.LabelID, label.ToAdd, label.ToRemove)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update label", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">json.WriteSuccessResponse(w, http.StatusOK, "Label edited succesfully", nil)</span>
}

// DeleteAlbum godoc
// @Summary Delete an album
// @Description Removes an album from the label. Accessible by label members for their own label or administrators for any label.
// @Tags label
// @Accept json
// @Produce json
// @Security LabelAuth
// @Security AdminAuth
// @Param request body delivery.DeleteAlbumRequest true "Album deletion request containing labelID and albumID"
// @Success 200 {object} delivery.Message "Album deleted successfully"
// @Failure 400 {string} delivery.APIBadRequestErrorResponse "Bad request - invalid input or label ID mismatch"
// @Failure 401 {string} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 403 {string} delivery.APIForbiddenErrorResponse "Forbidden - user not in label"
// @Failure 500 {string} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label/album [delete]
func (h *LabelHandler) DeleteAlbum(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        isAdmin := ctxExtractor.AdminFromContext(ctx)
        labelID, isLabel := ctxExtractor.LabelFromContext(ctx)
        if !isLabel &amp;&amp; !isAdmin </span><span class="cov1" title="1">{
                logger.Error("failed to authorize user")
                json.WriteErrorResponse(w, http.StatusUnauthorized, "user not in label", nil)
                return
        }</span>

        <span class="cov3" title="2">var req delivery.DeleteAlbumRequest
        err := json.ReadJSON(w, r, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to read JSON", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "Failed to read JSON", nil)
                return
        }</span>
        <span class="cov1" title="1">if isLabel </span><span class="cov1" title="1">{
                if req.LabelID != labelID </span><span class="cov0" title="0">{
                        logger.Error("Label ID mismatch", zap.Error(err))
                        json.WriteErrorResponse(w, http.StatusBadRequest, "Label ID mismatch", nil)
                        return
                }</span>
        }

        <span class="cov1" title="1">err = h.usecase.DeleteAlbum(ctx, req.LabelID, req.AlbumID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete album", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">json.WriteSuccessResponse(w, http.StatusOK, "Album deleted successfully", nil)</span>
}

// GetAlbumsByLabelID godoc
// @Summary Get albums by label ID
// @Description Retrieves a list of albums associated with the user's label with optional pagination.
// @Tags label
// @Accept json
// @Produce json
// @Security LabelAuth
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Album} "List of albums in the label"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid pagination parameters"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 403 {object} delivery.APIForbiddenErrorResponse "Forbidden - user not in label"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /api/v1/label/albums [get]
func (h *LabelHandler) GetAlbumsByLabelID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        labelID, isLabel := ctxExtractor.LabelFromContext(ctx)
        if !isLabel </span><span class="cov0" title="0">{
                logger.Error("failed to get labelID")
                json.WriteErrorResponse(w, http.StatusUnauthorized, "user not in label", nil)
                return
        }</span>

        <span class="cov0" title="0">pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">albums, err := h.usecase.GetAlbumsByLabelID(ctx, labelID, &amp;usecase.AlbumFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get albums", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">albumsDelivery := model.AlbumsFromUsecaseToDelivery(albums)
        json.WriteSuccessResponse(w, http.StatusOK, albumsDelivery, nil)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/label/domain"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/repository"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "go.uber.org/zap"
)

const (
        CreateLabelQuery = `
                        INSERT INTO label (name)
                        VALUES ($1)
                        RETURNING id
        `
        GetLabelByIdQuery = `
                        SELECT name
                        FROM label
                        WHERE id = $1
        `
        CheckIsLabelUnique = `
                        SELECT 1
                        FROM label
                        WHERE name = $1
        `
)

type labelPostgresRepository struct {
        db *sql.DB
}

func NewLabelPostgresRepository(db *sql.DB) domain.Repository <span class="cov0" title="0">{
        return &amp;labelPostgresRepository{
                db: db,
        }
}</span>

func (r *labelPostgresRepository) CreateLabel(ctx context.Context, name string) (int64, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Creating label", zap.String("name", name))

        stmt, err := r.db.PrepareContext(ctx, CreateLabelQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return -1, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">var labelID int64
        err = stmt.QueryRowContext(ctx, name).Scan(&amp;labelID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Error("label not found", zap.Error(err))
                        return -1, err
                }</span>
                <span class="cov0" title="0">logger.Error("failed to create label", zap.Error(err))
                return -1, err</span>
        }

        <span class="cov0" title="0">return labelID, nil</span>
}

func (r *labelPostgresRepository) GetLabel(ctx context.Context, labelID int64) (*repoModel.Label, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting label", zap.Int64("labelID", labelID))

        stmt, err := r.db.PrepareContext(ctx, GetLabelByIdQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">var label repoModel.Label
        err = stmt.QueryRowContext(ctx, labelID).Scan(&amp;label.Name)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Error("label not found", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get label", zap.Error(err))
                return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;label, nil</span>
}

func (r *labelPostgresRepository) CheckIsLabelUnique(ctx context.Context, labelName string) (bool, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking if label is unique", zap.String("labelName", labelName))
        stmt, err := r.db.PrepareContext(ctx, CheckIsLabelUnique)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return false, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">var exist bool
        err = stmt.QueryRowContext(ctx, labelName).Scan(&amp;exist)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to check if artist name exists", zap.Error(err))
                return false, err</span>
        }
        <span class="cov0" title="0">return exist, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package usecase

import (
        "context"

        albumProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/album"
        artistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
        trackProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/track"
        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/label/domain"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
)

func NewLabelUsecase(labelRepo domain.Repository, userProto userProto.UserServiceClient, artistProto artistProto.ArtistServiceClient, albumProto albumProto.AlbumServiceClient, trackProto trackProto.TrackServiceClient) domain.Usecase <span class="cov0" title="0">{
        return &amp;labelUsecase{
                labelRepository: labelRepo,
                userProto:       userProto,
                artistProto:     artistProto,
                albumProto:      albumProto,
                trackProto:      trackProto,
        }
}</span>

type labelUsecase struct {
        labelRepository domain.Repository
        userProto       userProto.UserServiceClient
        artistProto     artistProto.ArtistServiceClient
        albumProto      albumProto.AlbumServiceClient
        trackProto      trackProto.TrackServiceClient
        S3Repository    domain.S3Repository
}

func (u *labelUsecase) CheckIsLabelUnique(ctx context.Context, labelName string) (bool, error) <span class="cov0" title="0">{
        exist, err := u.labelRepository.CheckIsLabelUnique(ctx, labelName)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return exist, nil</span>
}

func (u *labelUsecase) CreateLabel(ctx context.Context, label *usecaseModel.Label) (*usecaseModel.Label, error) <span class="cov0" title="0">{
        isExist, err := u.CheckIsLabelUnique(ctx, label.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return nil, customErrors.ErrLableExist
        }</span>
        <span class="cov0" title="0">_, err = u.userProto.ChecksUsersByUsernames(ctx, &amp;userProto.Usernames{
                Usernames: label.Members,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">labelID, err := u.labelRepository.CreateLabel(ctx, label.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = u.userProto.UpdateUsersLabelID(ctx, &amp;userProto.RequestUpdateUserLabelID{
                LabelId:   labelID,
                Usernames: label.Members,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">label.Id = labelID
        return label, nil</span>
}

func (u *labelUsecase) GetLabel(ctx context.Context, id int64) (*usecaseModel.Label, error) <span class="cov0" title="0">{
        label, err := u.labelRepository.GetLabel(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">members, err := u.userProto.GetUsersByLabelID(ctx, &amp;userProto.LabelID{
                Id: id,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">label.Members = members.Usernames
        labelUsecase := usecaseModel.Label{
                Id:      label.ID,
                Name:    label.Name,
                Members: label.Members,
        }
        return &amp;labelUsecase, nil</span>
}

func (u *labelUsecase) CreateArtist(ctx context.Context, artist *usecaseModel.ArtistLoad) (*usecaseModel.Artist, error) <span class="cov0" title="0">{
        artistProto := &amp;artistProto.ArtistLoad{
                Title:   artist.Title,
                Image:   artist.Image,
                LabelId: artist.LabelID,
        }
        protoCreatedArtist, err := u.artistProto.CreateArtist(ctx, artistProto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.ArtistFromProtoToUsecase(protoCreatedArtist), nil</span>
}

func (u *labelUsecase) EditArtist(ctx context.Context, artist *usecaseModel.ArtistEdit) (*usecaseModel.Artist, error) <span class="cov0" title="0">{
        artistProto := &amp;artistProto.ArtistEdit{
                ArtistId: artist.ArtistID,
                Image:    artist.Image,
                LabelId:  artist.LabelID,
                NewTitle: artist.NewTitle,
        }
        protoEditedArtist, err := u.artistProto.EditArtist(ctx, artistProto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.ArtistFromProtoToUsecase(protoEditedArtist), nil</span>
}

func (u *labelUsecase) GetArtists(ctx context.Context, labelID int64, filters *usecaseModel.ArtistFilters) ([]*usecaseModel.Artist, error) <span class="cov0" title="0">{
        protoArtists, err := u.artistProto.GetArtistsLabelID(ctx, &amp;artistProto.FiltersWithLabelID{
                Filters: &amp;artistProto.Filters{
                        Pagination: model.PaginationFromUsecaseToArtistProto(filters.Pagination),
                },
                LabelId: labelID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">artists := model.ArtistsFromProtoToUsecase(protoArtists.Artists)
        return artists, nil</span>
}

func (u *labelUsecase) GetAlbumsByLabelID(ctx context.Context, labelID int64, filters *usecaseModel.AlbumFilters) ([]*usecaseModel.Album, error) <span class="cov0" title="0">{
        protoAlbums, err := u.albumProto.GetAlbumsLabelID(ctx, &amp;albumProto.FiltersWithLabelID{
                Filters: &amp;albumProto.Filters{
                        Pagination: model.PaginationFromUsecaseToAlbumProto(filters.Pagination),
                },
                LabelId: labelID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">albumIDs := make([]*artistProto.AlbumID, 0, len(protoAlbums.Albums))
        for _, protoAlbum := range protoAlbums.Albums </span><span class="cov0" title="0">{
                albumIDs = append(albumIDs, &amp;artistProto.AlbumID{Id: protoAlbum.Id})
        }</span>

        <span class="cov0" title="0">protoArtists, err := u.artistProto.GetArtistsByAlbumIDs(ctx, &amp;artistProto.AlbumIDList{Ids: albumIDs})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov0" title="0">artistWithTitleMap := model.ArtistWithTitleMapFromProtoToUsecase(protoArtists.Artists)

        albums := make([]*usecaseModel.Album, 0, len(protoAlbums.Albums))
        for _, protoAlbum := range protoAlbums.Albums </span><span class="cov0" title="0">{
                usecaseAlbum := model.AlbumFromProtoToUsecase(protoAlbum)
                usecaseAlbum.Artists = artistWithTitleMap[protoAlbum.Id]
                albums = append(albums, usecaseAlbum)
        }</span>
        <span class="cov0" title="0">return albums, nil</span>
}

func (u *labelUsecase) DeleteArtist(ctx context.Context, artist *usecaseModel.ArtistDelete) error <span class="cov0" title="0">{
        artistProto := &amp;artistProto.ArtistDelete{
                ArtistId: artist.ArtistID,
                LabelId:  artist.LabelID,
        }
        _, err := u.artistProto.DeleteArtist(ctx, artistProto)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (u *labelUsecase) CreateAlbum(ctx context.Context, album *usecaseModel.CreateAlbumRequest) (int64, string, error) <span class="cov0" title="0">{
        var albumType albumProto.AlbumType
        switch album.Type </span>{
        case string(usecaseModel.AlbumTypeAlbum):<span class="cov0" title="0">
                albumType = albumProto.AlbumType_AlbumTypeAlbum</span>
        case string(usecaseModel.AlbumTypeEP):<span class="cov0" title="0">
                albumType = albumProto.AlbumType_AlbumTypeEP</span>
        case string(usecaseModel.AlbumTypeSingle):<span class="cov0" title="0">
                albumType = albumProto.AlbumType_AlbumTypeSingle</span>
        case string(usecaseModel.AlbumTypeCompilation):<span class="cov0" title="0">
                albumType = albumProto.AlbumType_AlbumTypeCompilation</span>
        default:<span class="cov0" title="0">
                albumType = albumProto.AlbumType_AlbumTypeAlbum</span>
        }

        <span class="cov0" title="0">albumProto := &amp;albumProto.CreateAlbumRequest{
                Type:    albumType,
                Title:   album.Title,
                LabelId: album.LabelID,
                Image:   album.Image,
        }
        protoCreatedAlbum, err := u.albumProto.CreateAlbum(ctx, albumProto)
        if err != nil </span><span class="cov0" title="0">{
                return -1, "", err
        }</span>

        <span class="cov0" title="0">artistIDs := make([]*artistProto.ArtistID, 0, len(album.ArtistsIDs))
        for _, id := range album.ArtistsIDs </span><span class="cov0" title="0">{
                artistIDs = append(artistIDs, &amp;artistProto.ArtistID{Id: id})
        }</span>

        <span class="cov0" title="0">tracksListWithAlbumId := &amp;trackProto.TracksListWithAlbumID{
                AlbumId: &amp;trackProto.AlbumID{Id: protoCreatedAlbum.Id},
                Tracks:  model.TrackListLoadFromUsecaseToProto(album.Tracks),
                Cover:   album.Image,
        }

        tracksIds, err := u.trackProto.AddTracksToAlbum(ctx, tracksListWithAlbumId)
        if err != nil </span><span class="cov0" title="0">{
                return -1, "", err
        }</span>

        <span class="cov0" title="0">tracksIdsUsecase := model.TracksIdsFromProtoToUsecase(tracksIds)

        _, err = u.artistProto.ConnectArtists(ctx, &amp;artistProto.ArtistsIDWithAlbumID{
                ArtistIds: &amp;artistProto.ArtistIDList{Ids: artistIDs},
                AlbumId:   &amp;artistProto.AlbumID{Id: protoCreatedAlbum.Id},
                TrackIds:  model.TracksIdsFromUsecaseToProtoArtist(tracksIdsUsecase),
        })
        if err != nil </span><span class="cov0" title="0">{
                return -1, "", err
        }</span>
        <span class="cov0" title="0">return protoCreatedAlbum.Id, protoCreatedAlbum.Url, nil</span>
}

func (u *labelUsecase) UpdateLabel(ctx context.Context, labelID int64, toAdd, toRemove []string) error <span class="cov0" title="0">{
        _, err := u.userProto.RemoveUsersFromLabel(ctx, &amp;userProto.RequestRemoveUserLabelID{
                LabelId:   labelID,
                Usernames: toRemove,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = u.userProto.UpdateUsersLabelID(ctx, &amp;userProto.RequestUpdateUserLabelID{
                LabelId:   labelID,
                Usernames: toAdd,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *labelUsecase) DeleteAlbum(ctx context.Context, albumID, labelID int64) error <span class="cov0" title="0">{
        _, err := u.albumProto.DeleteAlbum(ctx, &amp;albumProto.AlbumID{
                Id: albumID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = u.trackProto.DeleteTracksByAlbumID(ctx, &amp;trackProto.AlbumID{
                Id: albumID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package model

import (
        albumProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/album"
        artistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
        authProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/auth"
        playlistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/playlist"
        trackProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/track"
        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/repository"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
)

///////////////////////////////////// PAGINATION ////////////////////////////////////

func PaginationFromDeliveryToUsecase(deliveryPagination *delivery.Pagination) *usecase.Pagination <span class="cov1" title="1">{
        return &amp;usecase.Pagination{
                Offset: deliveryPagination.Offset,
                Limit:  deliveryPagination.Limit,
        }
}</span>

func PaginationFromUsecaseToArtistProto(usecasePagination *usecase.Pagination) *artistProto.Pagination <span class="cov1" title="1">{
        return &amp;artistProto.Pagination{
                Offset: int64(usecasePagination.Offset),
                Limit:  int64(usecasePagination.Limit),
        }
}</span>

func PaginationFromUsecaseToAlbumProto(usecasePagination *usecase.Pagination) *albumProto.Pagination <span class="cov1" title="1">{
        return &amp;albumProto.Pagination{
                Offset: int64(usecasePagination.Offset),
                Limit:  int64(usecasePagination.Limit),
        }
}</span>

func PaginationFromUsecaseToTrackProto(usecasePagination *usecase.Pagination) *trackProto.Pagination <span class="cov1" title="1">{
        return &amp;trackProto.Pagination{
                Offset: int64(usecasePagination.Offset),
                Limit:  int64(usecasePagination.Limit),
        }
}</span>

///////////////////////////////////// ALBUM ////////////////////////////////////

func AlbumsFromUsecaseToDelivery(usecaseAlbums []*usecase.Album) []*delivery.Album <span class="cov1" title="1">{
        albums := make([]*delivery.Album, 0, len(usecaseAlbums))
        for _, usecaseAlbum := range usecaseAlbums </span><span class="cov1" title="1">{
                albums = append(albums, AlbumFromUsecaseToDelivery(usecaseAlbum, usecaseAlbum.Artists))
        }</span>
        <span class="cov1" title="1">return albums</span>
}

func AlbumFromUsecaseToDelivery(usecaseAlbum *usecase.Album, usecaseAlbumArtists []*usecase.AlbumArtist) *delivery.Album <span class="cov4" title="2">{
        return &amp;delivery.Album{
                ID:          usecaseAlbum.ID,
                Title:       usecaseAlbum.Title,
                Type:        delivery.AlbumType(usecaseAlbum.Type),
                Thumbnail:   usecaseAlbum.Thumbnail,
                Artists:     AlbumArtistsFromUsecaseToDelivery(usecaseAlbumArtists),
                ReleaseDate: usecaseAlbum.ReleaseDate,
                IsLiked:     usecaseAlbum.IsLiked,
        }
}</span>

func AlbumArtistsFromUsecaseToDelivery(usecaseAlbumArtists []*usecase.AlbumArtist) []*delivery.AlbumArtist <span class="cov6" title="3">{
        albumArtists := make([]*delivery.AlbumArtist, 0, len(usecaseAlbumArtists))
        for _, usecaseAlbumArtist := range usecaseAlbumArtists </span><span class="cov6" title="3">{
                albumArtists = append(albumArtists, &amp;delivery.AlbumArtist{
                        ID:    usecaseAlbumArtist.ID,
                        Title: usecaseAlbumArtist.Title,
                })
        }</span>
        <span class="cov6" title="3">return albumArtists</span>
}

func AlbumFromProtoToUsecase(protoAlbum *albumProto.Album) *usecase.Album <span class="cov10" title="6">{
        var albumType usecase.AlbumType

        switch protoAlbum.Type </span>{
        case albumProto.AlbumType_AlbumTypeAlbum:<span class="cov1" title="1">
                albumType = usecase.AlbumTypeAlbum</span>
        case albumProto.AlbumType_AlbumTypeEP:<span class="cov1" title="1">
                albumType = usecase.AlbumTypeEP</span>
        case albumProto.AlbumType_AlbumTypeSingle:<span class="cov1" title="1">
                albumType = usecase.AlbumTypeSingle</span>
        case albumProto.AlbumType_AlbumTypeCompilation:<span class="cov1" title="1">
                albumType = usecase.AlbumTypeCompilation</span>
        default:<span class="cov4" title="2">
                albumType = usecase.AlbumTypeAlbum</span>
        }

        <span class="cov10" title="6">return &amp;usecase.Album{
                ID:          protoAlbum.Id,
                Title:       protoAlbum.Title,
                Type:        albumType,
                Thumbnail:   protoAlbum.Thumbnail,
                ReleaseDate: protoAlbum.ReleaseDate.AsTime(),
                IsLiked:     protoAlbum.IsFavorite,
        }</span>
}

func AlbumIdsFromUsecaseToAlbumProto(usecaseAlbumIds []int64) []*albumProto.AlbumID <span class="cov4" title="2">{
        albumIds := make([]*albumProto.AlbumID, 0, len(usecaseAlbumIds))
        for _, id := range usecaseAlbumIds </span><span class="cov6" title="3">{
                albumIds = append(albumIds, &amp;albumProto.AlbumID{Id: id})
        }</span>
        <span class="cov4" title="2">return albumIds</span>
}

func AlbumLikeRequestFromUsecaseToProto(usecaseLikeRequest *usecase.AlbumLikeRequest) *albumProto.LikeRequest <span class="cov1" title="1">{
        return &amp;albumProto.LikeRequest{
                AlbumId: &amp;albumProto.AlbumID{Id: usecaseLikeRequest.AlbumID},
                UserId:  &amp;albumProto.UserID{Id: usecaseLikeRequest.UserID},
                IsLike:  usecaseLikeRequest.IsLike,
        }
}</span>

func AlbumLikeRequestFromDeliveryToUsecase(isLike bool, userID int64, albumID int64) *usecase.AlbumLikeRequest <span class="cov1" title="1">{
        return &amp;usecase.AlbumLikeRequest{
                AlbumID: albumID,
                IsLike:  isLike,
                UserID:  userID,
        }
}</span>

func TrackRequestFromDeliveryToUsecase(deliveryTrack *delivery.CreateTrackRequest) *usecase.CreateTrackRequest <span class="cov0" title="0">{
        return &amp;usecase.CreateTrackRequest{
                Title: deliveryTrack.Title,
                Track: deliveryTrack.Track,
        }
}</span>

func NewAlbumFromDeliveryToUsecase(deliveryAlbum *delivery.CreateAlbumRequest) *usecase.CreateAlbumRequest <span class="cov0" title="0">{
        tracks := make([]*usecase.CreateTrackRequest, 0, len(deliveryAlbum.Tracks))
        for _, deliveryTrack := range deliveryAlbum.Tracks </span><span class="cov0" title="0">{
                tracks = append(tracks, TrackRequestFromDeliveryToUsecase(deliveryTrack))
        }</span>

        <span class="cov0" title="0">return &amp;usecase.CreateAlbumRequest{
                Title:      deliveryAlbum.Title,
                Image:      deliveryAlbum.Image,
                Type:       deliveryAlbum.Type,
                LabelID:    deliveryAlbum.LabelID,
                Tracks:     tracks,
                ArtistsIDs: deliveryAlbum.ArtistsIDs,
        }</span>
}

func AlbumTypeConverter(albumType string) delivery.AlbumType <span class="cov0" title="0">{
        switch albumType </span>{
        case string(usecase.AlbumTypeAlbum):<span class="cov0" title="0">
                return delivery.AlbumTypeAlbum</span>
        case string(usecase.AlbumTypeEP):<span class="cov0" title="0">
                return delivery.AlbumTypeEP</span>
        case string(usecase.AlbumTypeSingle):<span class="cov0" title="0">
                return delivery.AlbumTypeSingle</span>
        case string(usecase.AlbumTypeCompilation):<span class="cov0" title="0">
                return delivery.AlbumTypeCompilation</span>
        default:<span class="cov0" title="0">
                return delivery.AlbumTypeAlbum</span>
        }
}

///////////////////////////////////// ARTIST ////////////////////////////////////

func ArtistWithTitleListFromProtoToUsecase(protoArtistWithTitleList []*artistProto.ArtistWithTitle) []*usecase.AlbumArtist <span class="cov6" title="3">{
        artistWithTitleList := make([]*usecase.AlbumArtist, 0, len(protoArtistWithTitleList))
        for _, protoArtistWithTitle := range protoArtistWithTitleList </span><span class="cov7" title="4">{
                artistWithTitleList = append(artistWithTitleList, &amp;usecase.AlbumArtist{
                        ID:    protoArtistWithTitle.Id,
                        Title: protoArtistWithTitle.Title,
                })
        }</span>
        <span class="cov6" title="3">return artistWithTitleList</span>
}

func ArtistWithTitleMapFromProtoToUsecase(protoArtistWithTitleMap map[int64]*artistProto.ArtistWithTitleList) map[int64][]*usecase.AlbumArtist <span class="cov1" title="1">{
        artistWithTitleMap := make(map[int64][]*usecase.AlbumArtist, len(protoArtistWithTitleMap))
        for id, protoArtistWithTitleList := range protoArtistWithTitleMap </span><span class="cov4" title="2">{
                artistWithTitleMap[id] = ArtistWithTitleListFromProtoToUsecase(protoArtistWithTitleList.Artists)
        }</span>
        <span class="cov1" title="1">return artistWithTitleMap</span>
}

func ArtistsFromUsecaseToDelivery(usecaseArtists []*usecase.Artist) []*delivery.Artist <span class="cov1" title="1">{
        artists := make([]*delivery.Artist, 0, len(usecaseArtists))
        for _, usecaseArtist := range usecaseArtists </span><span class="cov1" title="1">{
                artists = append(artists, ArtistFromUsecaseToDelivery(usecaseArtist))
        }</span>
        <span class="cov1" title="1">return artists</span>
}

func ArtistFromUsecaseToDelivery(usecaseArtist *usecase.Artist) *delivery.Artist <span class="cov6" title="3">{
        return &amp;delivery.Artist{
                ID:          usecaseArtist.ID,
                Title:       usecaseArtist.Title,
                Thumbnail:   usecaseArtist.Thumbnail,
                Description: usecaseArtist.Description,
                IsLiked:     usecaseArtist.IsLiked,
        }
}</span>

func ArtistsFromProtoToUsecase(protoArtists []*artistProto.Artist) []*usecase.Artist <span class="cov1" title="1">{
        artists := make([]*usecase.Artist, 0, len(protoArtists))
        for _, protoArtist := range protoArtists </span><span class="cov1" title="1">{
                artists = append(artists, ArtistFromProtoToUsecase(protoArtist))
        }</span>
        <span class="cov1" title="1">return artists</span>
}

func ArtistFromProtoToUsecase(protoArtist *artistProto.Artist) *usecase.Artist <span class="cov6" title="3">{
        return &amp;usecase.Artist{
                ID:          protoArtist.Id,
                Title:       protoArtist.Title,
                Thumbnail:   protoArtist.Thumbnail,
                Description: protoArtist.Description,
                IsLiked:     protoArtist.IsFavorite,
        }
}</span>

func ArtistDetailedFromProtoToUsecase(protoArtist *artistProto.ArtistDetailed) *usecase.ArtistDetailed <span class="cov1" title="1">{
        return &amp;usecase.ArtistDetailed{
                Artist:    *ArtistFromProtoToUsecase(protoArtist.Artist),
                Favorites: protoArtist.FavoritesCount,
                Listeners: protoArtist.ListenersCount,
        }
}</span>

func ArtistDetailedFromUsecaseToDelivery(usecaseArtistDetailed *usecase.ArtistDetailed) *delivery.ArtistDetailed <span class="cov1" title="1">{
        return &amp;delivery.ArtistDetailed{
                Artist:    *ArtistFromUsecaseToDelivery(&amp;usecaseArtistDetailed.Artist),
                Favorites: usecaseArtistDetailed.Favorites,
                Listeners: usecaseArtistDetailed.Listeners,
        }
}</span>

func TrackIdsFromUsecaseToArtistProto(usecaseTrackIds []int64) []*artistProto.TrackID <span class="cov4" title="2">{
        trackIds := make([]*artistProto.TrackID, 0, len(usecaseTrackIds))
        for _, id := range usecaseTrackIds </span><span class="cov6" title="3">{
                trackIds = append(trackIds, &amp;artistProto.TrackID{Id: id})
        }</span>
        <span class="cov4" title="2">return trackIds</span>
}

func ArtistWithRoleListFromProtoToUsecase(protoArtistWithRoleList []*artistProto.ArtistWithRole) []*usecase.TrackArtist <span class="cov7" title="4">{
        artistWithRoleList := make([]*usecase.TrackArtist, 0, len(protoArtistWithRoleList))
        for _, protoArtistWithRole := range protoArtistWithRoleList </span><span class="cov9" title="5">{
                artistWithRoleList = append(artistWithRoleList, &amp;usecase.TrackArtist{
                        ID:    protoArtistWithRole.Id,
                        Title: protoArtistWithRole.Title,
                        Role:  protoArtistWithRole.Role,
                })
        }</span>
        <span class="cov7" title="4">return artistWithRoleList</span>
}

func UserIDFromUsecaseToProtoArtist(userID int64) *artistProto.UserID <span class="cov1" title="1">{
        return &amp;artistProto.UserID{
                Id: userID,
        }
}</span>

func ArtistsListenedFromProtoToUsecase(protoArtistsNum *artistProto.ArtistListened) int64 <span class="cov1" title="1">{
        return protoArtistsNum.ArtistsListened
}</span>

func ArtistLikeRequestFromUsecaseToProto(usecaseLikeRequest *usecase.ArtistLikeRequest) *artistProto.LikeRequest <span class="cov1" title="1">{
        return &amp;artistProto.LikeRequest{
                ArtistId: &amp;artistProto.ArtistID{Id: usecaseLikeRequest.ArtistID},
                UserId:   &amp;artistProto.UserID{Id: usecaseLikeRequest.UserID},
                IsLike:   usecaseLikeRequest.IsLike,
        }
}</span>

func ArtistLikeRequestFromDeliveryToUsecase(isLike bool, userID int64, artistID int64) *usecase.ArtistLikeRequest <span class="cov1" title="1">{
        return &amp;usecase.ArtistLikeRequest{
                ArtistID: artistID,
                IsLike:   isLike,
                UserID:   userID,
        }
}</span>

func ArtistLoadFromUsecaseToProto(artist *usecase.ArtistLoad) *artistProto.ArtistLoad <span class="cov0" title="0">{
        return &amp;artistProto.ArtistLoad{
                Title:   artist.Title,
                Image:   artist.Image,
                LabelId: artist.LabelID,
        }
}</span>

func ArtistLoadFromDeliveryToUsecase(deliveryArtist *delivery.CreateArtistRequest) *usecase.ArtistLoad <span class="cov0" title="0">{
        return &amp;usecase.ArtistLoad{
                Title:   deliveryArtist.Title,
                Image:   deliveryArtist.Image,
                LabelID: deliveryArtist.LabelID,
        }
}</span>

func ArtistDeleteFromDeliveryToUsecase(deleteArtist *delivery.DeleteArtistRequest) *usecase.ArtistDelete <span class="cov0" title="0">{
        return &amp;usecase.ArtistDelete{
                ArtistID: deleteArtist.ArtistID,
                LabelID:  deleteArtist.LabelID,
        }
}</span>

///////////////////////////////////// TRACK ////////////////////////////////////

func TracksFromUsecaseToDelivery(usecaseTracks []*usecase.Track) []*delivery.Track <span class="cov1" title="1">{
        tracks := make([]*delivery.Track, 0, len(usecaseTracks))
        for _, usecaseTrack := range usecaseTracks </span><span class="cov1" title="1">{
                tracks = append(tracks, TrackFromUsecaseToDelivery(usecaseTrack))
        }</span>
        <span class="cov1" title="1">return tracks</span>
}

func TrackFromUsecaseToDelivery(usecaseTrack *usecase.Track) *delivery.Track <span class="cov7" title="4">{
        return &amp;delivery.Track{
                ID:        usecaseTrack.ID,
                Title:     usecaseTrack.Title,
                Thumbnail: usecaseTrack.Thumbnail,
                Duration:  usecaseTrack.Duration,
                Album:     usecaseTrack.Album,
                AlbumID:   usecaseTrack.AlbumID,
                Artists:   TrackArtistsFromUsecaseToDelivery(usecaseTrack.Artists),
                IsLiked:   usecaseTrack.IsLiked,
        }
}</span>

func TracksDetailedFromUsecaseToDelivery(usecaseTracks []*usecase.TrackDetailed) []*delivery.TrackDetailed <span class="cov1" title="1">{
        tracks := make([]*delivery.TrackDetailed, 0, len(usecaseTracks))
        for _, usecaseTrack := range usecaseTracks </span><span class="cov1" title="1">{
                tracks = append(tracks, TrackDetailedFromUsecaseToDelivery(usecaseTrack))
        }</span>
        <span class="cov1" title="1">return tracks</span>
}

func TrackDetailedFromUsecaseToDelivery(usecaseTrackDetailed *usecase.TrackDetailed) *delivery.TrackDetailed <span class="cov4" title="2">{
        return &amp;delivery.TrackDetailed{
                Track:   *TrackFromUsecaseToDelivery(&amp;usecaseTrackDetailed.Track),
                FileUrl: usecaseTrackDetailed.FileUrl,
        }
}</span>

func TrackArtistsFromUsecaseToDelivery(usecaseTrackArtists []*usecase.TrackArtist) []*delivery.TrackArtist <span class="cov9" title="5">{
        trackArtists := make([]*delivery.TrackArtist, 0, len(usecaseTrackArtists))
        for _, usecaseTrackArtist := range usecaseTrackArtists </span><span class="cov9" title="5">{
                trackArtists = append(trackArtists, &amp;delivery.TrackArtist{
                        ID:    usecaseTrackArtist.ID,
                        Title: usecaseTrackArtist.Title,
                        Role:  usecaseTrackArtist.Role,
                })
        }</span>
        <span class="cov9" title="5">return trackArtists</span>
}

func TrackIdsFromUsecaseToTrackProto(usecaseTrackIds []*usecase.Track) []*trackProto.TrackID <span class="cov4" title="2">{
        trackIds := make([]*trackProto.TrackID, 0, len(usecaseTrackIds))
        for _, usecaseTrack := range usecaseTrackIds </span><span class="cov6" title="3">{
                trackIds = append(trackIds, &amp;trackProto.TrackID{Id: usecaseTrack.ID})
        }</span>
        <span class="cov4" title="2">return trackIds</span>
}

func TrackFromProtoToUsecase(protoTrack *trackProto.Track, protoAlbum *albumProto.AlbumTitle, protoArtists *artistProto.ArtistWithRoleList) *usecase.Track <span class="cov4" title="2">{
        return &amp;usecase.Track{
                ID:        protoTrack.Id,
                Title:     protoTrack.Title,
                Thumbnail: protoTrack.Thumbnail,
                Duration:  protoTrack.Duration,
                AlbumID:   protoTrack.AlbumId,
                Album:     protoAlbum.Title,
                Artists:   ArtistWithRoleListFromProtoToUsecase(protoArtists.Artists),
                IsLiked:   protoTrack.IsFavorite,
        }
}</span>

func TrackDetailedFromProtoToUsecase(protoTrack *trackProto.TrackDetailed, protoAlbum *albumProto.AlbumTitle, protoArtists *artistProto.ArtistWithRoleList) *usecase.TrackDetailed <span class="cov1" title="1">{
        return &amp;usecase.TrackDetailed{
                Track:   *TrackFromProtoToUsecase(protoTrack.Track, protoAlbum, protoArtists),
                FileUrl: protoTrack.FileUrl,
        }
}</span>

func TrackIDListFromArtistToTrackProto(protoArtist *artistProto.TrackIDList, userID int64) *trackProto.TrackIDList <span class="cov4" title="2">{
        trackIds := make([]*trackProto.TrackID, 0, len(protoArtist.Ids))
        for _, id := range protoArtist.Ids </span><span class="cov4" title="2">{
                trackIds = append(trackIds, &amp;trackProto.TrackID{Id: id.Id})
        }</span>
        <span class="cov4" title="2">return &amp;trackProto.TrackIDList{Ids: trackIds, UserId: &amp;trackProto.UserID{Id: userID}}</span>
}

func TrackLikeRequestFromUsecaseToProto(usecaseLikeRequest *usecase.TrackLikeRequest) *trackProto.LikeRequest <span class="cov1" title="1">{
        return &amp;trackProto.LikeRequest{
                TrackId: &amp;trackProto.TrackID{Id: usecaseLikeRequest.TrackID},
                UserId:  &amp;trackProto.UserID{Id: usecaseLikeRequest.UserID},
                IsLike:  usecaseLikeRequest.IsLike,
        }
}</span>

func TrackLikeRequestFromDeliveryToUsecase(isLike bool, userID int64, trackID int64) *usecase.TrackLikeRequest <span class="cov1" title="1">{
        return &amp;usecase.TrackLikeRequest{
                TrackID: trackID,
                IsLike:  isLike,
                UserID:  userID,
        }
}</span>

func UserIDFromUsecaseToProtoTrack(userID int64) *trackProto.UserID <span class="cov1" title="1">{
        return &amp;trackProto.UserID{
                Id: userID,
        }
}</span>

func TracksListenedFromProtoToUsecase(protoTracksNum *trackProto.TracksListened) int64 <span class="cov1" title="1">{
        return protoTracksNum.Tracks
}</span>

func MinutesListenedFromProtoToUsecase(protoMinutesNum *trackProto.MinutesListened) int64 <span class="cov1" title="1">{
        return protoMinutesNum.Minutes
}</span>

///////////////////////////////////// STREAM ////////////////////////////////////

func TrackStreamCreateDataFromDeliveryToUsecase(deliveryTrackStream *delivery.TrackStreamCreateData) *usecase.TrackStreamCreateData <span class="cov1" title="1">{
        return &amp;usecase.TrackStreamCreateData{
                TrackID: deliveryTrackStream.TrackID,
                UserID:  deliveryTrackStream.UserID,
        }
}</span>

func TrackStreamUpdateDataFromDeliveryToUsecase(deliveryTrackStream *delivery.TrackStreamUpdateData, userID int64, streamID int64) *usecase.TrackStreamUpdateData <span class="cov1" title="1">{
        return &amp;usecase.TrackStreamUpdateData{
                StreamID: streamID,
                Duration: deliveryTrackStream.Duration,
                UserID:   userID,
        }
}</span>

func TrackStreamCreateDataFromUsecaseToProto(usecaseTrackStream *usecase.TrackStreamCreateData) *trackProto.TrackStreamCreateData <span class="cov1" title="1">{
        return &amp;trackProto.TrackStreamCreateData{
                TrackId: &amp;trackProto.TrackID{Id: usecaseTrackStream.TrackID},
                UserId:  &amp;trackProto.UserID{Id: usecaseTrackStream.UserID},
        }
}</span>

func TrackStreamUpdateDataFromUsecaseToProto(usecaseTrackStream *usecase.TrackStreamUpdateData) *trackProto.TrackStreamUpdateData <span class="cov1" title="1">{
        return &amp;trackProto.TrackStreamUpdateData{
                StreamId: &amp;trackProto.StreamID{Id: usecaseTrackStream.StreamID},
                Duration: usecaseTrackStream.Duration,
                UserId:   &amp;trackProto.UserID{Id: usecaseTrackStream.UserID},
        }
}</span>

func ArtistIdsFromUsecaseToArtistProto(artistIDs []int64) *artistProto.ArtistIDList <span class="cov7" title="4">{
        artistIds := make([]*artistProto.ArtistID, 0, len(artistIDs))
        for _, id := range artistIDs </span><span class="cov10" title="6">{
                artistIds = append(artistIds, &amp;artistProto.ArtistID{Id: id})
        }</span>
        <span class="cov7" title="4">return &amp;artistProto.ArtistIDList{Ids: artistIds}</span>
}

func ArtistStreamCreateDataListFromUsecaseToProto(userID int64, artistIDs []int64) *artistProto.ArtistStreamCreateDataList <span class="cov4" title="2">{
        return &amp;artistProto.ArtistStreamCreateDataList{
                ArtistIds: ArtistIdsFromUsecaseToArtistProto(artistIDs),
                UserId:    &amp;artistProto.UserID{Id: userID},
        }
}</span>

// /////////////////////////////////// USER ////////////////////////////////////
func UserFullDataUsecaseToDelivery(usecaseUser *usecase.UserFullData) *delivery.UserFullData <span class="cov1" title="1">{
        return &amp;delivery.UserFullData{
                Username:   usecaseUser.Username,
                AvatarUrl:  usecaseUser.AvatarUrl,
                Email:      usecaseUser.Email,
                Privacy:    PrivacyUsecaseToDelivery(usecaseUser.Privacy),
                Statistics: StatisticsUsecaseToDelivery(usecaseUser.Statistics),
        }
}</span>

func PrivacyUsecaseToDelivery(usecasePrivacy *usecase.UserPrivacy) *delivery.Privacy <span class="cov4" title="2">{
        return &amp;delivery.Privacy{
                IsPublicPlaylists:       usecasePrivacy.IsPublicPlaylists,
                IsPublicMinutesListened: usecasePrivacy.IsPublicMinutesListened,
                IsPublicFavoriteArtists: usecasePrivacy.IsPublicFavoriteArtists,
                IsPublicTracksListened:  usecasePrivacy.IsPublicTracksListened,
                IsPublicFavoriteTracks:  usecasePrivacy.IsPublicFavoriteTracks,
                IsPublicArtistsListened: usecasePrivacy.IsPublicArtistsListened,
        }
}</span>

func StatisticsUsecaseToDelivery(usecaseStatistics *usecase.UserStatistics) *delivery.Statistics <span class="cov4" title="2">{
        return &amp;delivery.Statistics{
                MinutesListened: usecaseStatistics.MinutesListened,
                TracksListened:  usecaseStatistics.TracksListened,
                ArtistsListened: usecaseStatistics.ArtistsListened,
        }
}</span>

func PrivacyFromUsecaseToRepository(usecasePrivacy *usecase.UserPrivacy) *repository.UserPrivacySettings <span class="cov4" title="2">{
        if usecasePrivacy == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return &amp;repository.UserPrivacySettings{
                IsPublicPlaylists:       usecasePrivacy.IsPublicPlaylists,
                IsPublicMinutesListened: usecasePrivacy.IsPublicMinutesListened,
                IsPublicFavoriteArtists: usecasePrivacy.IsPublicFavoriteArtists,
                IsPublicTracksListened:  usecasePrivacy.IsPublicTracksListened,
                IsPublicFavoriteTracks:  usecasePrivacy.IsPublicFavoriteTracks,
                IsPublicArtistsListened: usecasePrivacy.IsPublicArtistsListened,
        }</span>
}

func PrivacyFromDeliveryToUsecase(deliveryPrivacy *delivery.Privacy) *usecase.UserPrivacy <span class="cov6" title="3">{
        if deliveryPrivacy == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="2">return &amp;usecase.UserPrivacy{
                IsPublicPlaylists:       deliveryPrivacy.IsPublicPlaylists,
                IsPublicMinutesListened: deliveryPrivacy.IsPublicMinutesListened,
                IsPublicFavoriteArtists: deliveryPrivacy.IsPublicFavoriteArtists,
                IsPublicTracksListened:  deliveryPrivacy.IsPublicTracksListened,
                IsPublicFavoriteTracks:  deliveryPrivacy.IsPublicFavoriteTracks,
                IsPublicArtistsListened: deliveryPrivacy.IsPublicArtistsListened,
        }</span>
}

func ChangeDataFromDeliveryToUsecase(deliveryUser *delivery.UserChangeSettings) *usecase.UserChangeSettings <span class="cov1" title="1">{
        privacyDelivery := PrivacyFromDeliveryToUsecase(deliveryUser.Privacy)
        return &amp;usecase.UserChangeSettings{
                Password:    deliveryUser.Password,
                NewUsername: deliveryUser.NewUsername,
                NewEmail:    deliveryUser.NewEmail,
                NewPassword: deliveryUser.NewPassword,
                Privacy:     privacyDelivery,
        }
}</span>

func LabelIDFromUsecaseToProto(userID int64) *userProto.LabelID <span class="cov0" title="0">{
        return &amp;userProto.LabelID{
                Id: userID,
        }
}</span>

func LabelIDFromProtoToUsecase(protoLabelID *userProto.LabelID) int64 <span class="cov0" title="0">{
        return protoLabelID.Id
}</span>

func LabelFromUsecaseToProto(label *usecase.Label) *userProto.Label <span class="cov0" title="0">{
        return &amp;userProto.Label{
                Id:        label.Id,
                Name:      label.Name,
                Usernames: label.Members,
        }
}</span>

func LabelFromProtoToUsecase(protoLabel *userProto.Label) *usecase.Label <span class="cov0" title="0">{
        return &amp;usecase.Label{
                Id:      protoLabel.Id,
                Name:    protoLabel.Name,
                Members: protoLabel.Usernames,
        }
}</span>

func LabelFromDeliveryToUsecase(deliveryLabel *delivery.Label) *usecase.Label <span class="cov0" title="0">{
        return &amp;usecase.Label{
                Name:    deliveryLabel.LabelName,
                Members: deliveryLabel.Usernames,
                Id:      deliveryLabel.Id,
        }
}</span>

func LabelFromUsecaseToDelivery(usecaseLabel *usecase.Label) *delivery.Label <span class="cov0" title="0">{
        return &amp;delivery.Label{
                Id:        usecaseLabel.Id,
                LabelName: usecaseLabel.Name,
                Usernames: usecaseLabel.Members,
        }
}</span>

func MembersFromProtoToUsecase(users *userProto.UsersToFront) []*usecase.User <span class="cov0" title="0">{
        members := make([]*usecase.User, 0, len(users.Users))
        for _, user := range users.Users </span><span class="cov0" title="0">{
                members = append(members, &amp;usecase.User{
                        Username:  user.Username,
                        Email:     user.Email,
                        AvatarUrl: user.Avatar,
                        ID:        user.Id,
                })
        }</span>
        <span class="cov0" title="0">return members</span>
}

func ArtistEditFromDeliveryToUsecase(editRequest *delivery.EditArtistRequest) *usecase.ArtistEdit <span class="cov0" title="0">{
        return &amp;usecase.ArtistEdit{
                ArtistID: editRequest.ArtistID,
                Image:    editRequest.Image,
                LabelID:  editRequest.LabelID,
                NewTitle: editRequest.NewTitle,
        }
}</span>

///////////////////////////////////// PLAYLIST ////////////////////////////////////

func PlaylistsFromProtoToUsecase(protoPlaylists []*playlistProto.Playlist, username string) []*usecase.Playlist <span class="cov1" title="1">{
        usecasePlaylists := make([]*usecase.Playlist, 0, len(protoPlaylists))
        for _, protoPlaylist := range protoPlaylists </span><span class="cov4" title="2">{
                usecasePlaylists = append(usecasePlaylists, PlaylistFromProtoToUsecase(protoPlaylist, username))
        }</span>
        <span class="cov1" title="1">return usecasePlaylists</span>
}

func PlaylistWithIsLikedFromProtoToUsecase(protoPlaylist *playlistProto.PlaylistWithIsLiked, username string) *usecase.PlaylistWithIsLiked <span class="cov1" title="1">{
        return &amp;usecase.PlaylistWithIsLiked{
                Playlist: *PlaylistFromProtoToUsecase(protoPlaylist.Playlist, username),
                IsLiked:  protoPlaylist.IsLiked,
        }
}</span>

func PlaylistWithIsLikedFromUsecaseToDelivery(usecasePlaylist *usecase.PlaylistWithIsLiked) *delivery.PlaylistWithIsLiked <span class="cov1" title="1">{
        return &amp;delivery.PlaylistWithIsLiked{
                Playlist: *PlaylistFromUsecaseToDelivery(&amp;usecasePlaylist.Playlist),
                IsLiked:  usecasePlaylist.IsLiked,
        }
}</span>

func LikePlaylistRequestFromDeliveryToUsecase(userID int64, playlistID int64, isLike bool) *usecase.LikePlaylistRequest <span class="cov1" title="1">{
        return &amp;usecase.LikePlaylistRequest{
                UserID:     userID,
                PlaylistID: playlistID,
                IsLike:     isLike,
        }
}</span>

func LikePlaylistRequestFromUsecaseToProto(usecaseLikePlaylist *usecase.LikePlaylistRequest) *playlistProto.LikePlaylistRequest <span class="cov1" title="1">{
        return &amp;playlistProto.LikePlaylistRequest{
                UserId:     usecaseLikePlaylist.UserID,
                PlaylistId: usecaseLikePlaylist.PlaylistID,
                IsLike:     usecaseLikePlaylist.IsLike,
        }
}</span>

func UpdatePlaylistsPublisityByUserIDRequestFromUsecaseToProto(isPublic bool, userID int64) *playlistProto.UpdatePlaylistsPublisityByUserIDRequest <span class="cov1" title="1">{
        return &amp;playlistProto.UpdatePlaylistsPublisityByUserIDRequest{
                IsPublic: isPublic,
                UserId:   userID,
        }
}</span>

func UploadPlaylistThumbnailRequestFromUsecaseToProto(title string, thumbnail []byte) *playlistProto.UploadPlaylistThumbnailRequest <span class="cov1" title="1">{
        return &amp;playlistProto.UploadPlaylistThumbnailRequest{
                Title:     title,
                Thumbnail: thumbnail,
        }
}</span>

func CreatePlaylistRequestFromUsecaseToProto(usecasePlaylist *usecase.CreatePlaylistRequest, thumbnail string, isPublic bool) *playlistProto.CreatePlaylistRequest <span class="cov1" title="1">{
        return &amp;playlistProto.CreatePlaylistRequest{
                Title:     usecasePlaylist.Title,
                UserId:    usecasePlaylist.UserID,
                Thumbnail: thumbnail,
                IsPublic:  isPublic,
        }
}</span>

func PlaylistFromProtoToUsecase(protoPlaylist *playlistProto.Playlist, username string) *usecase.Playlist <span class="cov10" title="6">{
        return &amp;usecase.Playlist{
                ID:        protoPlaylist.Id,
                Title:     protoPlaylist.Title,
                Thumbnail: protoPlaylist.Thumbnail,
                Username:  username,
        }
}</span>

func CreatePlaylistRequestFromDeliveryToUsecase(deliveryPlaylist *delivery.CreatePlaylistRequest, userID int64) *usecase.CreatePlaylistRequest <span class="cov1" title="1">{
        return &amp;usecase.CreatePlaylistRequest{
                Title:     deliveryPlaylist.Title,
                UserID:    userID,
                Thumbnail: deliveryPlaylist.Thumbnail,
        }
}</span>

func PlaylistFromUsecaseToDelivery(usecasePlaylist *usecase.Playlist) *delivery.Playlist <span class="cov10" title="6">{
        return &amp;delivery.Playlist{
                ID:        usecasePlaylist.ID,
                Title:     usecasePlaylist.Title,
                Thumbnail: usecasePlaylist.Thumbnail,
                Username:  usecasePlaylist.Username,
        }
}</span>

func PlaylistsFromUsecaseToDelivery(usecasePlaylists []*usecase.Playlist) []*delivery.Playlist <span class="cov1" title="1">{
        deliveryPlaylists := make([]*delivery.Playlist, 0, len(usecasePlaylists))
        for _, usecasePlaylist := range usecasePlaylists </span><span class="cov4" title="2">{
                deliveryPlaylists = append(deliveryPlaylists, PlaylistFromUsecaseToDelivery(usecasePlaylist))
        }</span>
        <span class="cov1" title="1">return deliveryPlaylists</span>
}

func AddTrackToPlaylistRequestFromDeliveryToUsecase(deliveryAddTrackToPlaylist *delivery.AddTrackToPlaylistRequest, userID int64, playlistID int64) *usecase.AddTrackToPlaylistRequest <span class="cov1" title="1">{
        return &amp;usecase.AddTrackToPlaylistRequest{
                UserID:     userID,
                PlaylistID: playlistID,
                TrackID:    deliveryAddTrackToPlaylist.TrackID,
        }
}</span>

func RemoveTrackFromPlaylistRequestFromDeliveryToUsecase(trackID int64, userID int64, playlistID int64) *usecase.RemoveTrackFromPlaylistRequest <span class="cov1" title="1">{
        return &amp;usecase.RemoveTrackFromPlaylistRequest{
                UserID:     userID,
                PlaylistID: playlistID,
                TrackID:    trackID,
        }
}</span>

func AddTrackToPlaylistRequestFromUsecaseToProto(usecaseAddTrackToPlaylist *usecase.AddTrackToPlaylistRequest) *playlistProto.AddTrackToPlaylistRequest <span class="cov1" title="1">{
        return &amp;playlistProto.AddTrackToPlaylistRequest{
                PlaylistId: usecaseAddTrackToPlaylist.PlaylistID,
                TrackId:    usecaseAddTrackToPlaylist.TrackID,
                UserId:     usecaseAddTrackToPlaylist.UserID,
        }
}</span>

func RemoveTrackFromPlaylistRequestFromUsecaseToProto(usecaseRemoveTrackFromPlaylist *usecase.RemoveTrackFromPlaylistRequest) *playlistProto.RemoveTrackFromPlaylistRequest <span class="cov1" title="1">{
        return &amp;playlistProto.RemoveTrackFromPlaylistRequest{
                PlaylistId: usecaseRemoveTrackFromPlaylist.PlaylistID,
                TrackId:    usecaseRemoveTrackFromPlaylist.TrackID,
                UserId:     usecaseRemoveTrackFromPlaylist.UserID,
        }
}</span>

func UpdatePlaylistRequestFromUsecaseToProto(usecaseUpdatePlaylist *usecase.UpdatePlaylistRequest, thumbnail string) *playlistProto.UpdatePlaylistRequest <span class="cov1" title="1">{
        return &amp;playlistProto.UpdatePlaylistRequest{
                Id:        usecaseUpdatePlaylist.PlaylistID,
                Title:     usecaseUpdatePlaylist.Title,
                Thumbnail: thumbnail,
                UserId:    usecaseUpdatePlaylist.UserID,
        }
}</span>

func UpdatePlaylistRequestFromDeliveryToUsecase(deliveryUpdatePlaylist *delivery.UpdatePlaylistRequest, userID int64, playlistID int64) *usecase.UpdatePlaylistRequest <span class="cov1" title="1">{
        return &amp;usecase.UpdatePlaylistRequest{
                UserID:     userID,
                PlaylistID: playlistID,
                Title:      deliveryUpdatePlaylist.Title,
                Thumbnail:  deliveryUpdatePlaylist.Thumbnail,
        }
}</span>

func RemovePlaylistRequestFromUsecaseToProto(usecaseRemovePlaylist *usecase.RemovePlaylistRequest) *playlistProto.RemovePlaylistRequest <span class="cov1" title="1">{
        return &amp;playlistProto.RemovePlaylistRequest{
                UserId:     usecaseRemovePlaylist.UserID,
                PlaylistId: usecaseRemovePlaylist.PlaylistID,
        }
}</span>

func RemovePlaylistRequestFromDeliveryToUsecase(playlistID int64, userID int64) *usecase.RemovePlaylistRequest <span class="cov1" title="1">{
        return &amp;usecase.RemovePlaylistRequest{
                UserID:     userID,
                PlaylistID: playlistID,
        }
}</span>

func GetPlaylistsToAddRequestFromDeliveryToUsecase(trackID int64, userID int64) *usecase.GetPlaylistsToAddRequest <span class="cov1" title="1">{
        return &amp;usecase.GetPlaylistsToAddRequest{
                UserID:  userID,
                TrackID: trackID,
        }
}</span>

func GetPlaylistsToAddRequestFromUsecaseToProto(usecaseGetPlaylistsToAdd *usecase.GetPlaylistsToAddRequest) *playlistProto.GetPlaylistsToAddRequest <span class="cov1" title="1">{
        return &amp;playlistProto.GetPlaylistsToAddRequest{
                UserId:  usecaseGetPlaylistsToAdd.UserID,
                TrackId: usecaseGetPlaylistsToAdd.TrackID,
        }
}</span>

func GetPlaylistsToAddResponseFromProtoToUsecase(proto *playlistProto.GetPlaylistsToAddResponse, username string) []*usecase.PlaylistWithIsIncludedTrack <span class="cov1" title="1">{
        usecasePlaylists := make([]*usecase.PlaylistWithIsIncludedTrack, 0, len(proto.Playlists))
        for _, protoPlaylist := range proto.Playlists </span><span class="cov4" title="2">{
                usecasePlaylists = append(usecasePlaylists, &amp;usecase.PlaylistWithIsIncludedTrack{
                        Playlist:   *PlaylistFromProtoToUsecase(protoPlaylist.Playlist, username),
                        IsIncluded: protoPlaylist.IsIncludedTrack,
                })
        }</span>
        <span class="cov1" title="1">return usecasePlaylists</span>
}

func PlaylistsWithIsIncludedTrackFromUsecaseToDelivery(usecasePlaylists []*usecase.PlaylistWithIsIncludedTrack) []*delivery.PlaylistWithIsIncludedTrack <span class="cov1" title="1">{
        deliveryPlaylists := make([]*delivery.PlaylistWithIsIncludedTrack, 0, len(usecasePlaylists))
        for _, usecasePlaylist := range usecasePlaylists </span><span class="cov4" title="2">{
                deliveryPlaylists = append(deliveryPlaylists, &amp;delivery.PlaylistWithIsIncludedTrack{
                        Playlist:   *PlaylistFromUsecaseToDelivery(&amp;usecasePlaylist.Playlist),
                        IsIncluded: usecasePlaylist.IsIncluded,
                })
        }</span>
        <span class="cov1" title="1">return deliveryPlaylists</span>
}

func RegisterDataFromUsecaseToProto(regData *usecase.User) *userProto.RegisterData <span class="cov1" title="1">{
        return &amp;userProto.RegisterData{
                Username: regData.Username,
                Email:    regData.Email,
                Password: regData.Password,
        }
}</span>

func UserFromProtoToUsecase(protoUser *userProto.UserFront) *usecase.User <span class="cov1" title="1">{
        return &amp;usecase.User{
                ID:        protoUser.Id,
                Username:  protoUser.Username,
                Email:     protoUser.Email,
                AvatarUrl: protoUser.Avatar,
                LabelID:   protoUser.LabelId,
        }
}</span>

func UserIDFromUsecaseToProtoUser(userID int64) *userProto.UserID <span class="cov1" title="1">{
        return &amp;userProto.UserID{
                Id: userID,
        }
}</span>

func UserIDFromProtoToUsecaseUser(protoUserID *userProto.UserID) int64 <span class="cov1" title="1">{
        return protoUserID.Id
}</span>

func LoginDataFromUsecaseToProto(loginData *usecase.User) *userProto.LoginData <span class="cov1" title="1">{
        return &amp;userProto.LoginData{
                Username: loginData.Username,
                Email:    loginData.Email,
                Password: loginData.Password,
        }
}</span>

func AvatarDataFromUsecaseToProto(fileURL string, id int64) *userProto.AvatarData <span class="cov1" title="1">{
        return &amp;userProto.AvatarData{
                AvatarPath: fileURL,
                Id:         id,
        }
}</span>

func DeleteUserFromUsecaseToProto(user *usecase.User) *userProto.UserDelete <span class="cov1" title="1">{
        return &amp;userProto.UserDelete{
                Username: user.Username,
                Email:    user.Email,
                Password: user.Password,
        }
}</span>

func UsernameFromUsecaseToProto(username string) *userProto.Username <span class="cov1" title="1">{
        return &amp;userProto.Username{
                Username: username,
        }
}</span>

func PrivacyFromProtoToUsecase(protoPrivacy *userProto.PrivacySettings) *usecase.UserPrivacy <span class="cov4" title="2">{
        return &amp;usecase.UserPrivacy{
                IsPublicPlaylists:       protoPrivacy.IsPublicPlaylists,
                IsPublicMinutesListened: protoPrivacy.IsPublicMinutesListened,
                IsPublicFavoriteArtists: protoPrivacy.IsPublicFavoriteArtists,
                IsPublicTracksListened:  protoPrivacy.IsPublicTracksListened,
                IsPublicFavoriteTracks:  protoPrivacy.IsPublicFavoriteTracks,
                IsPublicArtistsListened: protoPrivacy.IsPublicArtistsListened,
        }
}</span>

func UserFullDataFromProtoToUsecase(protoUser *userProto.UserFullData) *usecase.UserFullData <span class="cov1" title="1">{
        privacyUsecase := PrivacyFromProtoToUsecase(protoUser.Privacy)
        return &amp;usecase.UserFullData{
                Username:  protoUser.Username,
                Email:     protoUser.Email,
                AvatarUrl: protoUser.Avatar,
                Privacy:   privacyUsecase,
        }
}</span>

func PrivacyFromUsecaseToProto(username string, usecasePrivacy *usecase.UserPrivacy) *userProto.PrivacySettings <span class="cov1" title="1">{
        return &amp;userProto.PrivacySettings{
                Username:                username,
                IsPublicPlaylists:       usecasePrivacy.IsPublicPlaylists,
                IsPublicMinutesListened: usecasePrivacy.IsPublicMinutesListened,
                IsPublicFavoriteArtists: usecasePrivacy.IsPublicFavoriteArtists,
                IsPublicTracksListened:  usecasePrivacy.IsPublicTracksListened,
                IsPublicFavoriteTracks:  usecasePrivacy.IsPublicFavoriteTracks,
                IsPublicArtistsListened: usecasePrivacy.IsPublicArtistsListened,
        }
}</span>

func ChangeUserDataFromUsecaseToProto(username string, usecaseUser *usecase.UserChangeSettings) *userProto.ChangeUserDataMessage <span class="cov1" title="1">{
        return &amp;userProto.ChangeUserDataMessage{
                Username:    username,
                NewUsername: usecaseUser.NewUsername,
                NewEmail:    usecaseUser.NewEmail,
                NewPassword: usecaseUser.NewPassword,
                Password:    usecaseUser.Password,
        }
}</span>

func FileKeyFromUsecaseToProto(avatarURL string) *userProto.FileKey <span class="cov1" title="1">{
        return &amp;userProto.FileKey{
                FileKey: avatarURL,
        }
}</span>

func AvatarUrlFromProtoToUsecase(protoAvatarURL *userProto.AvatarUrl) string <span class="cov1" title="1">{
        return protoAvatarURL.Url
}</span>

func AvatarImageFromUsecaseToProto(username string, image []byte) *userProto.AvatarImage <span class="cov1" title="1">{
        return &amp;userProto.AvatarImage{
                Username: username,
                Image:    image,
        }
}</span>

func FileKeyFromProtoToUsecase(protoFileKey *userProto.FileKey) string <span class="cov1" title="1">{
        return protoFileKey.FileKey
}</span>

// ///////////////////////////////////// AUTH ////////////////////////////////////
func SessionIDFromProtoToUsecase(protoSessionID *authProto.SessionID) string <span class="cov1" title="1">{
        return protoSessionID.SessionId
}</span>

func UserIDFromProtoToUsecase(protoUserID *authProto.UserID) int64 <span class="cov1" title="1">{
        return protoUserID.Id
}</span>

func SessionIDFromUsecaseToProto(sessionID string) *authProto.SessionID <span class="cov1" title="1">{
        return &amp;authProto.SessionID{
                SessionId: sessionID,
        }
}</span>

func UserIDFromUsecaseToProto(userID int64) *authProto.UserID <span class="cov1" title="1">{
        return &amp;authProto.UserID{
                Id: userID,
        }
}</span>

func TrackLoadFromUsecaseToProto(track *usecase.CreateTrackRequest) *trackProto.TrackLoad <span class="cov0" title="0">{
        return &amp;trackProto.TrackLoad{
                Title: track.Title,
                File:  track.Track,
        }
}</span>

func TrackListLoadFromUsecaseToProto(tracks []*usecase.CreateTrackRequest) []*trackProto.TrackLoad <span class="cov0" title="0">{
        trackList := make([]*trackProto.TrackLoad, 0, len(tracks))
        for _, track := range tracks </span><span class="cov0" title="0">{
                trackList = append(trackList, TrackLoadFromUsecaseToProto(track))
        }</span>
        <span class="cov0" title="0">return trackList</span>
}

func TracksIdsFromProtoToUsecase(protoTracks *trackProto.TrackIdsList) []int64 <span class="cov0" title="0">{
        trackIds := make([]int64, 0, len(protoTracks.Ids))
        for _, id := range protoTracks.Ids </span><span class="cov0" title="0">{
                trackIds = append(trackIds, id.Id)
        }</span>
        <span class="cov0" title="0">return trackIds</span>
}

func TracksIdsFromUsecaseToProtoArtist(trackIDs []int64) *artistProto.TrackIDList <span class="cov0" title="0">{
        trackIds := make([]*artistProto.TrackID, 0, len(trackIDs))
        for _, id := range trackIDs </span><span class="cov0" title="0">{
                trackIds = append(trackIds, &amp;artistProto.TrackID{Id: id})
        }</span>
        <span class="cov0" title="0">return &amp;artistProto.TrackIDList{Ids: trackIds}</span>
}

// //////////////////////////////////// JAM ////////////////////////////////////

func CreateJamResponseFromUsecaseToDelivery(usecaseCreateJam *usecase.CreateJamResponse) *delivery.CreateJamResponse <span class="cov0" title="0">{
        return &amp;delivery.CreateJamResponse{
                RoomID: usecaseCreateJam.RoomID,
                HostID: usecaseCreateJam.HostID,
        }
}</span>

func CreateJamRequestFromDeliveryToUsecase(deliveryCreateJam *delivery.CreateJamRequest, userID string) *usecase.CreateJamRequest <span class="cov0" title="0">{
        return &amp;usecase.CreateJamRequest{
                UserID:   userID,
                TrackID:  deliveryCreateJam.TrackID,
                Position: deliveryCreateJam.Position,
        }
}</span>

func JamMessageFromUsecaseToDelivery(usecaseJamMessage *usecase.JamMessage) *delivery.JamMessage <span class="cov0" title="0">{
        return &amp;delivery.JamMessage{
                Type:       usecaseJamMessage.Type,
                TrackID:    usecaseJamMessage.TrackID,
                Position:   usecaseJamMessage.Position,
                Paused:     usecaseJamMessage.Paused,
                Users:      usecaseJamMessage.Users,
                HostID:     usecaseJamMessage.HostID,
                Loaded:     usecaseJamMessage.Loaded,
                UserID:     usecaseJamMessage.UserID,
                UserImages: usecaseJamMessage.UserImages,
                UserNames:  usecaseJamMessage.UserNames,
        }
}</span>

func JamMessageFromRepositoryToUsecase(repoJamMessage *repository.JamMessage) *usecase.JamMessage <span class="cov0" title="0">{
        return &amp;usecase.JamMessage{
                Type:       repoJamMessage.Type,
                TrackID:    repoJamMessage.TrackID,
                Position:   repoJamMessage.Position,
                Paused:     repoJamMessage.Paused,
                Users:      repoJamMessage.Users,
                HostID:     repoJamMessage.HostID,
                Loaded:     repoJamMessage.Loaded,
                UserID:     repoJamMessage.UserID,
                UserImages: repoJamMessage.UserImages,
                UserNames:  repoJamMessage.UserNames,
        }
}</span>

func JamMessageFromDeliveryToUsecase(deliveryJamMessage *delivery.JamMessage) *usecase.JamMessage <span class="cov0" title="0">{
        return &amp;usecase.JamMessage{
                Type:       deliveryJamMessage.Type,
                TrackID:    deliveryJamMessage.TrackID,
                Position:   deliveryJamMessage.Position,
                Paused:     deliveryJamMessage.Paused,
                Users:      deliveryJamMessage.Users,
                HostID:     deliveryJamMessage.HostID,
                Loaded:     deliveryJamMessage.Loaded,
                UserImages: deliveryJamMessage.UserImages,
                UserNames:  deliveryJamMessage.UserNames,
        }
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package repository

import "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"

func PaginationFromUsecaseToRepository(usecasePagination *usecase.Pagination) *Pagination <span class="cov0" title="0">{
        return &amp;Pagination{
                Offset: usecasePagination.Offset,
                Limit:  usecasePagination.Limit,
        }
}</span>

type Pagination struct {
        Offset int
        Limit  int
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package http

import (
        "io"
        "net/http"
        "strconv"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        customErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/errorStatus"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/json"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/query"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/playlist"
        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

const ()

type PlaylistHandler struct {
        usecase playlist.Usecase
        cfg     *config.Config
}

func NewPlaylistHandler(usecase playlist.Usecase, cfg *config.Config) *PlaylistHandler <span class="cov10" title="11">{
        return &amp;PlaylistHandler{usecase: usecase, cfg: cfg}
}</span>

// CreatePlaylist godoc
// @Summary Create a new playlist
// @Description Create a new playlist with a title and thumbnail image
// @Tags playlists
// @Accept multipart/form-data
// @Produce json
// @Param title formData string true "Playlist title"
// @Param thumbnail formData file true "Playlist thumbnail image"
// @Success 201 {object} delivery.APIResponse{body=delivery.Playlist} "Created playlist"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid form data"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 413 {object} delivery.APIRequestEntityTooLargeErrorResponse "Request entity too large"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists [post]
func (h *PlaylistHandler) CreatePlaylist(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to create playlist for unauthorized user")
                err := customErrors.ErrPlaylistUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">if r.ContentLength &gt; 6&lt;&lt;20 </span><span class="cov0" title="0">{
                logger.Error("content length is too large")
                json.WriteErrorResponse(w, http.StatusRequestEntityTooLarge, "content length is too large", nil)
                return
        }</span>

        <span class="cov3" title="2">err := r.ParseMultipartForm(6 &lt;&lt; 20) // 6 MB
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to parse multipart form", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">request := &amp;delivery.CreatePlaylistRequest{}

        request.Title = r.FormValue("title")
        if request.Title == "" </span><span class="cov0" title="0">{
                logger.Error("title is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "title is required", nil)
                return
        }</span>

        <span class="cov3" title="2">if len(request.Title) &gt; 100 </span><span class="cov0" title="0">{
                logger.Error("title is too long")
                json.WriteErrorResponse(w, http.StatusBadRequest, "title is too long", nil)
                return
        }</span>

        <span class="cov3" title="2">file, _, err := r.FormFile("thumbnail")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get thumbnail", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(customErrors.ErrPlaylistImageNotUploaded), customErrors.ErrPlaylistImageNotUploaded.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">request.Thumbnail, err = io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read thumbnail", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(customErrors.ErrPlaylistImageNotUploaded), customErrors.ErrPlaylistImageNotUploaded.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseRequest := model.CreatePlaylistRequestFromDeliveryToUsecase(request, userID)

        playlist, err := h.usecase.CreatePlaylist(ctx, usecaseRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to create playlist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">deliveryPlaylist := model.PlaylistFromUsecaseToDelivery(playlist)

        json.WriteSuccessResponse(w, http.StatusCreated, deliveryPlaylist, nil)</span>
}

// GetCombinedPlaylistsForCurrentUser godoc
// @Summary Get combined playlists for current user
// @Description Retrieves all playlists accessible to the current user
// @Tags playlists
// @Accept json
// @Produce json
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Playlist} "List of playlists"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/me [get]
func (h *PlaylistHandler) GetCombinedPlaylistsForCurrentUser(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to get combined playlists for unauthorized user")
                err := customErrors.ErrPlaylistUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">playlists, err := h.usecase.GetCombinedPlaylistsForCurrentUser(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get combined playlists", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">deliveryPlaylists := model.PlaylistsFromUsecaseToDelivery(playlists)

        json.WriteSuccessResponse(w, http.StatusOK, deliveryPlaylists, nil)</span>
}

// AddTrackToPlaylist godoc
// @Summary Add a track to a playlist
// @Description Adds a track to a specific playlist
// @Tags playlists
// @Accept json
// @Produce json
// @Param id path integer true "Playlist ID"
// @Param request body delivery.AddTrackToPlaylistRequest true "Track information"
// @Success 200 {object} delivery.APIResponse{} "Track added successfully"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID or request body"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Playlist or track not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/{id}/tracks [post]
func (h *PlaylistHandler) AddTrackToPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov6" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to add track to playlist for unauthorized user")
                err := customErrors.ErrPlaylistUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">vars := mux.Vars(r)
        playlistID := vars["id"]
        if playlistID == "" </span><span class="cov0" title="0">{
                logger.Error("playlist_id is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "playlist_id is required", nil)
                return
        }</span>

        <span class="cov5" title="3">playlistIDInt, err := strconv.ParseInt(playlistID, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse playlist_id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">request := &amp;delivery.AddTrackToPlaylistRequest{}
        err = json.ReadJSON(w, r, request)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read add track to playlist request", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseRequest := model.AddTrackToPlaylistRequestFromDeliveryToUsecase(request, userID, playlistIDInt)

        err = h.usecase.AddTrackToPlaylist(ctx, usecaseRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to add track to playlist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">json.WriteSuccessResponse(w, http.StatusOK, delivery.Message{Message: "Track added successfully"}, nil)</span>
}

// RemoveTrackFromPlaylist godoc
// @Summary Remove a track from a playlist
// @Description Removes a track from a specific playlist
// @Tags playlists
// @Accept json
// @Produce json
// @Param id path integer true "Playlist ID"
// @Param trackId path integer true "Track ID"
// @Success 200 {object} delivery.APIResponse{} "Track removed successfully"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid IDs"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Playlist or track not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/{id}/tracks/{trackId} [delete]
func (h *PlaylistHandler) RemoveTrackFromPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov7" title="5">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to remove track from playlist for unauthorized user")
                err := customErrors.ErrPlaylistUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov6" title="4">vars := mux.Vars(r)
        playlistID := vars["id"]
        if playlistID == "" </span><span class="cov0" title="0">{
                logger.Error("playlist_id is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "playlist_id is required", nil)
                return
        }</span>

        <span class="cov6" title="4">playlistIDInt, err := strconv.ParseInt(playlistID, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse playlist_id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">trackID := vars["trackId"]
        if trackID == "" </span><span class="cov0" title="0">{
                logger.Error("trackId is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "trackId is required", nil)
                return
        }</span>

        <span class="cov5" title="3">trackIDInt, err := strconv.ParseInt(trackID, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse trackId", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseRequest := model.RemoveTrackFromPlaylistRequestFromDeliveryToUsecase(trackIDInt, userID, playlistIDInt)

        err = h.usecase.RemoveTrackFromPlaylist(ctx, usecaseRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to remove track from playlist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">json.WriteSuccessResponse(w, http.StatusOK, delivery.Message{Message: "Track removed successfully"}, nil)</span>
}

// UpdatePlaylist godoc
// @Summary Update a playlist
// @Description Update a playlist's title and/or thumbnail
// @Tags playlists
// @Accept multipart/form-data
// @Produce json
// @Param id path integer true "Playlist ID"
// @Param title formData string true "New playlist title"
// @Param thumbnail formData file false "New playlist thumbnail image"
// @Success 200 {object} delivery.APIResponse{body=delivery.Playlist} "Updated playlist"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID or form data"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Playlist not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/{id} [put]
func (h *PlaylistHandler) UpdatePlaylist(w http.ResponseWriter, r *http.Request) <span class="cov6" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to update playlist for unauthorized user")
                err := customErrors.ErrPlaylistUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">vars := mux.Vars(r)
        playlistID := vars["id"]
        if playlistID == "" </span><span class="cov0" title="0">{
                logger.Error("playlist_id is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "playlist_id is required", nil)
                return
        }</span>

        <span class="cov5" title="3">playlistIDInt, err := strconv.ParseInt(playlistID, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse playlist_id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">request := &amp;delivery.UpdatePlaylistRequest{}
        request.Title = r.FormValue("title")
        if request.Title == "" </span><span class="cov0" title="0">{
                logger.Error("title is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "title is required", nil)
                return
        }</span>

        <span class="cov3" title="2">file, _, err := r.FormFile("thumbnail")
        if err != nil </span><span class="cov0" title="0">{
                request.Thumbnail = nil
        }</span> else<span class="cov3" title="2"> {
                request.Thumbnail, err = io.ReadAll(file)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to read thumbnail", zap.Error(err))
                        json.WriteErrorResponse(w, errorStatus.ErrorStatus(customErrors.ErrPlaylistImageNotUploaded), customErrors.ErrPlaylistImageNotUploaded.Error(), nil)
                        return
                }</span>
        }

        <span class="cov3" title="2">usecaseRequest := model.UpdatePlaylistRequestFromDeliveryToUsecase(request, userID, playlistIDInt)

        playlist, err := h.usecase.UpdatePlaylist(ctx, usecaseRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to update playlist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">deliveryPlaylist := model.PlaylistFromUsecaseToDelivery(playlist)

        json.WriteSuccessResponse(w, http.StatusOK, deliveryPlaylist, nil)</span>
}

// GetPlaylistByID godoc
// @Summary Get a playlist by ID
// @Description Retrieves a specific playlist by its ID with all its details
// @Tags playlists
// @Accept json
// @Produce json
// @Param id path integer true "Playlist ID"
// @Success 200 {object} delivery.APIResponse{body=delivery.PlaylistWithIsLiked} "Playlist details"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Playlist not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/{id} [get]
func (h *PlaylistHandler) GetPlaylistByID(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        playlistID := vars["id"]
        if playlistID == "" </span><span class="cov0" title="0">{
                logger.Error("playlist_id is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "playlist_id is required", nil)
                return
        }</span>

        <span class="cov5" title="3">playlistIDInt, err := strconv.ParseInt(playlistID, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse playlist_id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">playlist, err := h.usecase.GetPlaylistByID(ctx, playlistIDInt)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get playlist by id", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">deliveryPlaylist := model.PlaylistWithIsLikedFromUsecaseToDelivery(playlist)

        json.WriteSuccessResponse(w, http.StatusOK, deliveryPlaylist, nil)</span>
}

// RemovePlaylist godoc
// @Summary Remove a playlist
// @Description Deletes a playlist by its ID (only available to the playlist owner)
// @Tags playlists
// @Accept json
// @Produce json
// @Param id path integer true "Playlist ID"
// @Success 200 {object} delivery.APIResponse{body=delivery.Message} "Playlist removed successfully"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 403 {object} delivery.APIForbiddenErrorResponse "Forbidden - user is not the playlist owner"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Playlist not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/{id} [delete]
func (h *PlaylistHandler) RemovePlaylist(w http.ResponseWriter, r *http.Request) <span class="cov6" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to remove playlist for unauthorized user")
                err := customErrors.ErrPlaylistUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">vars := mux.Vars(r)
        playlistID := vars["id"]
        if playlistID == "" </span><span class="cov0" title="0">{
                logger.Error("playlist_id is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "playlist_id is required", nil)
                return
        }</span>

        <span class="cov5" title="3">playlistIDInt, err := strconv.ParseInt(playlistID, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse playlist_id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseRequest := model.RemovePlaylistRequestFromDeliveryToUsecase(playlistIDInt, userID)

        err = h.usecase.RemovePlaylist(ctx, usecaseRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to remove playlist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">json.WriteSuccessResponse(w, http.StatusOK, delivery.Message{Message: "Playlist removed successfully"}, nil)</span>
}

// GetPlaylistsToAdd godoc
// @Summary Get playlists available for adding a track
// @Description Retrieves all playlists owned by the current user with information about whether the track is already included
// @Tags playlists
// @Accept json
// @Produce json
// @Param trackId query integer true "Track ID to check inclusion status"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.PlaylistWithIsIncludedTrack} "List of playlists with track inclusion status"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid track ID"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/to-add [get]
func (h *PlaylistHandler) GetPlaylistsToAdd(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to get playlists to add for unauthorized user")
                err := customErrors.ErrPlaylistUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">trackID, err := query.ReadInt(r.URL.Query(), "trackId", -1)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to read track_id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">usecaseRequest := model.GetPlaylistsToAddRequestFromDeliveryToUsecase(int64(trackID), userID)

        playlists, err := h.usecase.GetPlaylistsToAdd(ctx, usecaseRequest)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get playlists to add", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">deliveryPlaylists := model.PlaylistsWithIsIncludedTrackFromUsecaseToDelivery(playlists)

        json.WriteSuccessResponse(w, http.StatusOK, deliveryPlaylists, nil)</span>
}

// LikePlaylist godoc
// @Summary Like a playlist
// @Description Like a playlist
// @Tags playlists
// @Accept json
// @Produce json
// @Param id path integer true "Playlist ID"
// @Param request body delivery.PlaylistLikeRequest true "Playlist like request"
// @Success 200 {object} delivery.APIResponse{} "Playlist liked/unliked successfully"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID or request body"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Playlist not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/{id}/like [post]
func (h *PlaylistHandler) LikePlaylist(w http.ResponseWriter, r *http.Request) <span class="cov6" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to like playlist for unauthorized user")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">vars := mux.Vars(r)
        playlistID := vars["id"]
        if playlistID == "" </span><span class="cov0" title="0">{
                logger.Error("playlist_id is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "playlist_id is required", nil)
                return
        }</span>

        <span class="cov5" title="3">playlistIDInt, err := strconv.ParseInt(playlistID, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse playlist_id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">request := &amp;delivery.PlaylistLikeRequest{}
        err = json.ReadJSON(w, r, request)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read playlist_like_request", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseRequest := model.LikePlaylistRequestFromDeliveryToUsecase(userID, playlistIDInt, request.IsLike)

        err = h.usecase.LikePlaylist(ctx, usecaseRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to like playlist", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">json.WriteSuccessResponse(w, http.StatusOK, delivery.Message{Message: "Playlist liked/unliked successfully"}, nil)</span>
}

// GetProfilePlaylists godoc
// @Summary Get profile playlists
// @Description Retrieves all playlists owned by a specific user
// @Tags playlists
// @Accept json
// @Produce json
// @Param username query string true "Username of the user"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Playlist} "List of playlists"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid username"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /user/{username}/playlists [get]
func (h *PlaylistHandler) GetProfilePlaylists(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        username := vars["username"]
        if username == "" </span><span class="cov1" title="1">{
                logger.Error("username is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "username is required", nil)
                return
        }</span>

        <span class="cov3" title="2">playlists, err := h.usecase.GetProfilePlaylists(ctx, username)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get profile playlists", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">deliveryPlaylists := model.PlaylistsFromUsecaseToDelivery(playlists)

        json.WriteSuccessResponse(w, http.StatusOK, deliveryPlaylists, nil)</span>
}

// SearchPlaylists godoc
// @Summary Search playlists
// @Description Search playlists by query
// @Tags playlists
// @Accept json
// @Produce json
// @Param query query string true "Search query"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Playlist} "List of playlists"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid query"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/search [get]
func (h *PlaylistHandler) SearchPlaylists(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        query := r.URL.Query().Get("query")
        if query == "" </span><span class="cov1" title="1">{
                logger.Error("query is required")
                json.WriteErrorResponse(w, http.StatusBadRequest, "query is required", nil)
                return
        }</span>

        <span class="cov3" title="2">playlists, err := h.usecase.SearchPlaylists(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to search playlists", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">deliveryPlaylists := model.PlaylistsFromUsecaseToDelivery(playlists)

        json.WriteSuccessResponse(w, http.StatusOK, deliveryPlaylists, nil)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package usecase

import (
        "context"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/playlist"

        playlistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/playlist"
        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        customErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"

        "go.uber.org/zap"
)

func NewUsecase(playlistClient *playlistProto.PlaylistServiceClient, userClient *userProto.UserServiceClient) playlist.Usecase <span class="cov0" title="0">{
        return &amp;playlistUsecase{playlistClient: playlistClient, userClient: userClient}
}</span>

type playlistUsecase struct {
        playlistClient *playlistProto.PlaylistServiceClient
        userClient     *userProto.UserServiceClient
}

func (u *playlistUsecase) CreatePlaylist(ctx context.Context, request *usecaseModel.CreatePlaylistRequest) (*usecaseModel.Playlist, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        thumbnail, err := (*u.playlistClient).UploadPlaylistThumbnail(ctx, model.UploadPlaylistThumbnailRequestFromUsecaseToProto(request.Title, request.Thumbnail))
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandlePlaylistGRPCError(err)
        }</span>

        <span class="cov0" title="0">privacy, err := (*u.userClient).GetUserPrivacyByID(ctx, &amp;userProto.UserID{
                Id: request.UserID,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get user privacy", zap.Error(err))
                return nil, customErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov0" title="0">playlist, err := (*u.playlistClient).CreatePlaylist(ctx, model.CreatePlaylistRequestFromUsecaseToProto(request, thumbnail.GetThumbnail(), privacy.IsPublicPlaylists))
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandlePlaylistGRPCError(err)
        }</span>

        <span class="cov0" title="0">user, err := (*u.userClient).GetUserByID(ctx, &amp;userProto.UserID{
                Id: playlist.GetUserId(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov0" title="0">return model.PlaylistFromProtoToUsecase(playlist, user.Username), nil</span>
}

func (u *playlistUsecase) GetCombinedPlaylistsForCurrentUser(ctx context.Context, userID int64) ([]*usecaseModel.Playlist, error) <span class="cov0" title="0">{
        request := &amp;playlistProto.GetCombinedPlaylistsByUserIDRequest{
                UserId: userID,
        }

        playlists, err := (*u.playlistClient).GetCombinedPlaylistsByUserID(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandlePlaylistGRPCError(err)
        }</span>

        <span class="cov0" title="0">usecasePlaylists := make([]*usecaseModel.Playlist, len(playlists.GetPlaylists()))
        for i, playlist := range playlists.GetPlaylists() </span><span class="cov0" title="0">{
                user, err := (*u.userClient).GetUserByID(ctx, &amp;userProto.UserID{
                        Id: playlist.GetUserId(),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandleUserGRPCError(err)
                }</span>
                <span class="cov0" title="0">usecasePlaylists[i] = model.PlaylistFromProtoToUsecase(playlist, user.Username)</span>
        }

        <span class="cov0" title="0">return usecasePlaylists, nil</span>
}

func (u *playlistUsecase) AddTrackToPlaylist(ctx context.Context, request *usecaseModel.AddTrackToPlaylistRequest) error <span class="cov0" title="0">{
        _, err := (*u.playlistClient).AddTrackToPlaylist(ctx, model.AddTrackToPlaylistRequestFromUsecaseToProto(request))
        if err != nil </span><span class="cov0" title="0">{
                return customErrors.HandlePlaylistGRPCError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *playlistUsecase) RemoveTrackFromPlaylist(ctx context.Context, request *usecaseModel.RemoveTrackFromPlaylistRequest) error <span class="cov0" title="0">{
        _, err := (*u.playlistClient).RemoveTrackFromPlaylist(ctx, model.RemoveTrackFromPlaylistRequestFromUsecaseToProto(request))
        if err != nil </span><span class="cov0" title="0">{
                return customErrors.HandlePlaylistGRPCError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *playlistUsecase) UpdatePlaylist(ctx context.Context, request *usecaseModel.UpdatePlaylistRequest) (*usecaseModel.Playlist, error) <span class="cov0" title="0">{
        thumbnail := ""
        if request.Thumbnail != nil </span><span class="cov0" title="0">{
                thumbnailObject, err := (*u.playlistClient).UploadPlaylistThumbnail(ctx, model.UploadPlaylistThumbnailRequestFromUsecaseToProto(request.Title, request.Thumbnail))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandlePlaylistGRPCError(err)
                }</span>
                <span class="cov0" title="0">thumbnail = thumbnailObject.GetThumbnail()</span>
        }

        <span class="cov0" title="0">playlist, err := (*u.playlistClient).UpdatePlaylist(ctx, model.UpdatePlaylistRequestFromUsecaseToProto(request, thumbnail))
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandlePlaylistGRPCError(err)
        }</span>

        <span class="cov0" title="0">user, err := (*u.userClient).GetUserByID(ctx, &amp;userProto.UserID{
                Id: playlist.GetUserId(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.PlaylistFromProtoToUsecase(playlist, user.Username), nil</span>
}

func (u *playlistUsecase) GetPlaylistByID(ctx context.Context, playlistID int64) (*usecaseModel.PlaylistWithIsLiked, error) <span class="cov0" title="0">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov0" title="0">{
                userID = -1
        }</span>

        <span class="cov0" title="0">playlist, err := (*u.playlistClient).GetPlaylistByID(ctx, &amp;playlistProto.GetPlaylistByIDRequest{
                Id:     playlistID,
                UserId: userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandlePlaylistGRPCError(err)
        }</span>

        <span class="cov0" title="0">user, err := (*u.userClient).GetUserByID(ctx, &amp;userProto.UserID{
                Id: playlist.GetPlaylist().GetUserId(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov0" title="0">return model.PlaylistWithIsLikedFromProtoToUsecase(playlist, user.Username), nil</span>
}

func (u *playlistUsecase) RemovePlaylist(ctx context.Context, request *usecaseModel.RemovePlaylistRequest) error <span class="cov0" title="0">{
        _, err := (*u.playlistClient).RemovePlaylist(ctx, model.RemovePlaylistRequestFromUsecaseToProto(request))
        if err != nil </span><span class="cov0" title="0">{
                return customErrors.HandlePlaylistGRPCError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *playlistUsecase) GetPlaylistsToAdd(ctx context.Context, request *usecaseModel.GetPlaylistsToAddRequest) ([]*usecaseModel.PlaylistWithIsIncludedTrack, error) <span class="cov0" title="0">{
        playlists, err := (*u.playlistClient).GetPlaylistsToAdd(ctx, model.GetPlaylistsToAddRequestFromUsecaseToProto(request))
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandlePlaylistGRPCError(err)
        }</span>

        <span class="cov0" title="0">user, err := (*u.userClient).GetUserByID(ctx, &amp;userProto.UserID{
                Id: request.UserID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.GetPlaylistsToAddResponseFromProtoToUsecase(playlists, user.Username), nil</span>
}

func (u *playlistUsecase) LikePlaylist(ctx context.Context, request *usecaseModel.LikePlaylistRequest) error <span class="cov0" title="0">{
        _, err := (*u.playlistClient).LikePlaylist(ctx, model.LikePlaylistRequestFromUsecaseToProto(request))
        if err != nil </span><span class="cov0" title="0">{
                return customErrors.HandlePlaylistGRPCError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *playlistUsecase) GetProfilePlaylists(ctx context.Context, username string) ([]*usecaseModel.Playlist, error) <span class="cov0" title="0">{
        requestUserID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov0" title="0">{
                requestUserID = -1
        }</span>

        <span class="cov0" title="0">userID, err := (*u.userClient).GetIDByUsername(ctx, &amp;userProto.Username{
                Username: username,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov0" title="0">userPrivacy, err := (*u.userClient).GetUserPrivacyByID(ctx, &amp;userProto.UserID{
                Id: userID.GetId(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov0" title="0">if !userPrivacy.IsPublicPlaylists &amp;&amp; userID.GetId() != requestUserID </span><span class="cov0" title="0">{
                return make([]*usecaseModel.Playlist, 0), nil
        }</span>

        <span class="cov0" title="0">playlists, err := (*u.playlistClient).GetProfilePlaylists(ctx, &amp;playlistProto.GetProfilePlaylistsRequest{
                UserId: userID.GetId(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandlePlaylistGRPCError(err)
        }</span>

        <span class="cov0" title="0">return model.PlaylistsFromProtoToUsecase(playlists.GetPlaylists(), username), nil</span>
}

func (u *playlistUsecase) SearchPlaylists(ctx context.Context, query string) ([]*usecaseModel.Playlist, error) <span class="cov0" title="0">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov0" title="0">{
                userID = -1
        }</span>

        <span class="cov0" title="0">playlists, err := (*u.playlistClient).SearchPlaylists(ctx, &amp;playlistProto.SearchPlaylistsRequest{
                Query:  query,
                UserId: userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandlePlaylistGRPCError(err)
        }</span>

        <span class="cov0" title="0">usecasePlaylists := make([]*usecaseModel.Playlist, len(playlists.GetPlaylists()))
        for i, playlist := range playlists.GetPlaylists() </span><span class="cov0" title="0">{
                user, err := (*u.userClient).GetUserByID(ctx, &amp;userProto.UserID{
                        Id: playlist.GetUserId(),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandleUserGRPCError(err)
                }</span>
                <span class="cov0" title="0">usecasePlaylists[i] = model.PlaylistFromProtoToUsecase(playlist, user.Username)</span>
        }

        <span class="cov0" title="0">return usecasePlaylists, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package http

import (
        "net/http"
        "strconv"

        "github.com/asaskevich/govalidator"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        customErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/errorStatus"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/json"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/pagination"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/track"
        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

const ()

type TrackHandler struct {
        usecase track.Usecase
        cfg     *config.Config
}

func NewTrackHandler(usecase track.Usecase, cfg *config.Config) *TrackHandler <span class="cov10" title="11">{
        return &amp;TrackHandler{usecase: usecase, cfg: cfg}
}</span>

// GetAllTracks godoc
// @Summary Get tracks
// @Description Get a list of tracks with optional pagination filters
// @Tags tracks
// @Accept json
// @Produce json
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Track} "List of tracks"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid filters"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /tracks [get]
func (h *TrackHandler) GetAllTracks(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseTracks, err := h.usecase.GetAllTracks(ctx, &amp;usecaseModel.TrackFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        })

        tracks := model.TracksFromUsecaseToDelivery(usecaseTracks)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get tracks", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">json.WriteSuccessResponse(w, http.StatusOK, tracks, nil)</span>
}

// GetTrackByID godoc
// @Summary Get track by ID
// @Description Retrieves a specific track by its ID with detailed information
// @Tags tracks
// @Accept json
// @Produce json
// @Param id path int true "Track ID"
// @Success 200 {object} delivery.APIResponse{body=delivery.TrackDetailed} "Track details"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /tracks/{id} [get]
func (h *TrackHandler) GetTrackByID(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse track ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseTrack, err := h.usecase.GetTrackByID(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get track", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">trackDetailed := model.TrackDetailedFromUsecaseToDelivery(usecaseTrack)

        json.WriteSuccessResponse(w, http.StatusOK, trackDetailed, nil)</span>
}

// GetTracksByArtistID godoc
// @Summary Get tracks by artist ID
// @Description Get a list of tracks by a specific artist with optional pagination filters
// @Tags tracks
// @Accept json
// @Produce json
// @Param id path integer true "Artist ID"
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Track} "List of tracks by artist"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID or filters"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /artists/{id}/tracks [get]
func (h *TrackHandler) GetTracksByArtistID(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse artist ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">usecaseTracks, err := h.usecase.GetTracksByArtistID(ctx, id, &amp;usecaseModel.TrackFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get tracks", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">tracks := model.TracksFromUsecaseToDelivery(usecaseTracks)
        json.WriteSuccessResponse(w, http.StatusOK, tracks, nil)</span>
}

// CreateStream godoc
// @Summary Create stream for track by id
// @Description Creates stream for track by id, essentially it means saving track to listening history
// @Tags tracks
// @Produce json
// @Param id path integer true "Track ID"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.StreamID} "ID of created stream"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID or filters"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /tracks/{id}/stream [post]
func (h *TrackHandler) CreateStream(w http.ResponseWriter, r *http.Request) <span class="cov6" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        idStr := vars["id"]
        trackID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse track ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to create stream for unauthorized user")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">trackStreamCreateData := &amp;delivery.TrackStreamCreateData{
                TrackID: trackID,
                UserID:  userID,
        }

        streamID, err := h.usecase.CreateStream(ctx, model.TrackStreamCreateDataFromDeliveryToUsecase(trackStreamCreateData))
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to save track stream", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">createResponse := &amp;delivery.StreamID{
                ID: streamID,
        }

        json.WriteSuccessResponse(w, http.StatusOK, createResponse, nil)</span>
}

// UpdateStreamDuration godoc
// @Summary Update stream duration by id
// @Description updates listening duration at the end of stream
// @Tags tracks
// @Produce json
// @Param id path integer true "Stream ID"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Message} "Message that stream was updated"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid ID or filters"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 403 {object} delivery.APIForbiddenErrorResponse "Forbidden"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /streams/{id} [put]
func (h *TrackHandler) UpdateStreamDuration(w http.ResponseWriter, r *http.Request) <span class="cov7" title="5">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        vars := mux.Vars(r)
        idStr := vars["id"]
        streamID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse stream ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov6" title="4">userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to update stream duration for unauthorized user")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">var streamUpdateData delivery.TrackStreamUpdateData

        err = json.ReadJSON(w, r, &amp;streamUpdateData)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("failed to read stream duration", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">valid, err := govalidator.ValidateStruct(streamUpdateData)
        if !valid </span><span class="cov1" title="1">{
                logger.Warn("invalid stream duration", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">err = h.usecase.UpdateStreamDuration(ctx, model.TrackStreamUpdateDataFromDeliveryToUsecase(&amp;streamUpdateData, userID, streamID))
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to update stream duration", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">responseMessage := delivery.Message{Message: "stream duration was successfully updated"}

        json.WriteSuccessResponse(w, http.StatusOK, responseMessage, nil)</span>
}

// GetLastListenedTracks godoc
// @Summary Get last listened tracks for a user
// @Description Retrieves a list of tracks last listened by a specific user with pagination
// @Tags tracks
// @Accept json
// @Produce json
// @Param username path string true "Username"
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Track} "List of last listened tracks"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid username or filters"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "User not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /users/me/history [get]
func (h *TrackHandler) GetLastListenedTracks(w http.ResponseWriter, r *http.Request) <span class="cov6" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to get last listened tracks for unauthorized user")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseTracks, err := h.usecase.GetLastListenedTracks(ctx, userID, &amp;usecaseModel.TrackFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        })

        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get last listened tracks", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">tracks := model.TracksFromUsecaseToDelivery(usecaseTracks)
        json.WriteSuccessResponse(w, http.StatusOK, tracks, nil)</span>
}

// GetTracksByAlbumID godoc
// @Summary Get tracks by album ID
// @Description Get a list of tracks by a specific album with optional pagination filters
// @Tags tracks
// @Accept json
// @Produce json
// @Param id path integer true "Album ID"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Track} "List of tracks by album"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid album ID or filters"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Album not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /albums/{id}/tracks [get]
func (h *TrackHandler) GetTracksByAlbumID(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse album ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseTracks, err := h.usecase.GetTracksByAlbumID(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get tracks by album ID", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">tracks := model.TracksFromUsecaseToDelivery(usecaseTracks)
        json.WriteSuccessResponse(w, http.StatusOK, tracks, nil)</span>
}

// LikeTrack godoc
// @Summary Like a track
// @Description Like a track for a user
// @Tags tracks
// @Accept json
// @Produce json
// @Param id path integer true "Track ID"
// @Param likeRequest body delivery.TrackLikeRequest true "Is like"
// @Success 200 {object} delivery.APIResponse{body=delivery.Message} "Track liked/unliked"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid track ID"
// @Failure 401 {object} delivery.APIUnauthorizedErrorResponse "Unauthorized"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Track not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /tracks/{id}/like [post]
func (h *TrackHandler) LikeTrack(w http.ResponseWriter, r *http.Request) <span class="cov7" title="6">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                logger.Warn("attempt to like track for unauthorized user")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov7" title="5">vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse track ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov6" title="4">var deliveryLikeRequest delivery.TrackLikeRequest

        err = json.ReadJSON(w, r, &amp;deliveryLikeRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Warn("failed to read like request", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">usecaseLikeRequest := model.TrackLikeRequestFromDeliveryToUsecase(deliveryLikeRequest.IsLike, userID, id)

        err = h.usecase.LikeTrack(ctx, usecaseLikeRequest)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to like track", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">json.WriteSuccessResponse(w, http.StatusOK, delivery.Message{
                Message: "track liked/unliked",
        }, nil)</span>
}

// GetPlaylistTracks godoc
// @Summary Get playlist tracks
// @Description Get a list of tracks by a specific playlist with optional pagination filters
// @Tags tracks
// @Accept json
// @Produce json
// @Param id path integer true "Playlist ID"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Track} "List of tracks by playlist"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid playlist ID or filters"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "Playlist not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /playlists/{id}/tracks [get]
func (h *TrackHandler) GetPlaylistTracks(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        idStr := vars["id"]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to parse playlist ID", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseTracks, err := h.usecase.GetPlaylistTracks(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get playlist tracks", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">tracks := model.TracksFromUsecaseToDelivery(usecaseTracks)
        json.WriteSuccessResponse(w, http.StatusOK, tracks, nil)</span>
}

// GetFavoriteTracks godoc
// @Summary Get favorite tracks
// @Description Get a list of favorite tracks for a user
// @Tags tracks
// @Accept json
// @Produce json
// @Param username path string true "Username"
// @Param offset query integer false "Offset (default: 0)"
// @Param limit query integer false "Limit (default: 10, max: 100)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Track} "List of favorite tracks"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid username or filters"
// @Failure 404 {object} delivery.APINotFoundErrorResponse "User not found"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /users/{username}/tracks [get]
func (h *TrackHandler) GetFavoriteTracks(w http.ResponseWriter, r *http.Request) <span class="cov6" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        username := vars["username"]
        if username == "" </span><span class="cov1" title="1">{
                logger.Warn("attempt to get favorite tracks for empty username")
                err := customErrors.ErrUnauthorized
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov5" title="3">pagination, err := pagination.GetPagination(r, &amp;h.cfg.Pagination)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get pagination", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">usecaseTracks, err := h.usecase.GetFavoriteTracks(ctx, &amp;usecaseModel.TrackFilters{
                Pagination: model.PaginationFromDeliveryToUsecase(pagination),
        }, username)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to get favorite tracks", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">tracks := model.TracksFromUsecaseToDelivery(usecaseTracks)
        json.WriteSuccessResponse(w, http.StatusOK, tracks, nil)</span>
}

// SearchTracks godoc
// @Summary Search tracks
// @Description Search tracks by query
// @Tags tracks
// @Accept json
// @Produce json
// @Param query path string true "Query"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Track} "List of tracks"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid query"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /tracks/search [get]
func (h *TrackHandler) SearchTracks(w http.ResponseWriter, r *http.Request) <span class="cov6" title="4">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        query := r.URL.Query().Get("query")
        if query == "" </span><span class="cov1" title="1">{
                logger.Warn("attempt to search tracks for empty query")
                json.WriteErrorResponse(w, http.StatusBadRequest, "query is empty", nil)
                return
        }</span>

        <span class="cov5" title="3">usecaseTracks, err := h.usecase.SearchTracks(ctx, query)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to search tracks", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov3" title="2">tracks := model.TracksFromUsecaseToDelivery(usecaseTracks)
        json.WriteSuccessResponse(w, http.StatusOK, tracks, nil)</span>
}

// GetSelectionTracks godoc
// @Summary Get selection tracks
// @Description Get a list of tracks by a specific selection
// @Tags tracks
// @Accept json
// @Produce json
// @Param selection path string true "Selection (most-recent, most-liked, most-liked-last-week, most-listened-last-month, top-chart)"
// @Success 200 {object} delivery.APIResponse{body=[]delivery.Track} "List of tracks"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid selection"
// @Failure 500 {object} delivery.APIInternalServerErrorResponse "Internal server error"
// @Router /selection/{selection} [get]
func (h *TrackHandler) GetSelectionTracks(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        selection := vars["selection"]

        if selection == "" </span><span class="cov0" title="0">{
                logger.Warn("attempt to get selection tracks for empty selection")
                json.WriteErrorResponse(w, http.StatusBadRequest, "selection is empty", nil)
                return
        }</span>

        <span class="cov0" title="0">usecaseTracks, err := h.usecase.GetSelectionTracks(ctx, selection)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get selection tracks", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">tracks := model.TracksFromUsecaseToDelivery(usecaseTracks)
        json.WriteSuccessResponse(w, http.StatusOK, tracks, nil)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package usecase

import (
        "context"

        albumProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/album"
        artistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
        playlistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/playlist"
        trackProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/track"
        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        customErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/track"
)

func NewUsecase(trackClient trackProto.TrackServiceClient, artistClient artistProto.ArtistServiceClient, albumClient albumProto.AlbumServiceClient, playlistClient playlistProto.PlaylistServiceClient, userClient userProto.UserServiceClient) track.Usecase <span class="cov10" title="13">{
        return &amp;trackUsecase{trackClient: trackClient, artistClient: artistClient, albumClient: albumClient, playlistClient: playlistClient, userClient: userClient}
}</span>

type trackUsecase struct {
        trackClient    trackProto.TrackServiceClient
        artistClient   artistProto.ArtistServiceClient
        albumClient    albumProto.AlbumServiceClient
        playlistClient playlistProto.PlaylistServiceClient
        userClient     userProto.UserServiceClient
}

func (u *trackUsecase) GetAllTracks(ctx context.Context, filters *usecaseModel.TrackFilters) ([]*usecaseModel.Track, error) <span class="cov3" title="2">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov3" title="2">{
                userID = -1
        }</span>

        <span class="cov3" title="2">protoFilters := &amp;trackProto.UserIDWithFilters{
                UserId:  &amp;trackProto.UserID{Id: userID},
                Filters: &amp;trackProto.Filters{Pagination: model.PaginationFromUsecaseToTrackProto(filters.Pagination)},
        }
        protoTracks, err := u.trackClient.GetAllTracks(ctx, protoFilters)
        if err != nil </span><span class="cov1" title="1">{
                return nil, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">trackIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                trackIDs = append(trackIDs, protoTrack.Id)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                albumIDs = append(albumIDs, protoTrack.AlbumId)
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByTrackIDs(ctx, &amp;artistProto.TrackIDList{Ids: model.TrackIdsFromUsecaseToArtistProto(trackIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoAlbumTitles, err := u.albumClient.GetAlbumTitleByIDs(ctx, &amp;albumProto.AlbumIDList{Ids: model.AlbumIdsFromUsecaseToAlbumProto(albumIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">tracks := make([]*usecaseModel.Track, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                track := model.TrackFromProtoToUsecase(protoTrack, protoAlbumTitles.Titles[protoTrack.AlbumId], protoArtists.Artists[protoTrack.Id])
                tracks = append(tracks, track)
        }</span>

        <span class="cov1" title="1">return tracks, nil</span>
}

func (u *trackUsecase) GetTrackByID(ctx context.Context, id int64) (*usecaseModel.TrackDetailed, error) <span class="cov1" title="1">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                userID = -1
        }</span>

        <span class="cov1" title="1">protoTrack, err := u.trackClient.GetTrackByID(ctx, &amp;trackProto.TrackIDWithUserID{TrackId: &amp;trackProto.TrackID{Id: id}, UserId: &amp;trackProto.UserID{Id: userID}})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByTrackID(ctx, &amp;artistProto.TrackID{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoAlbumTitle, err := u.albumClient.GetAlbumTitleByID(ctx, &amp;albumProto.AlbumID{Id: protoTrack.Track.AlbumId})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">trackDetailed := model.TrackDetailedFromProtoToUsecase(protoTrack, protoAlbumTitle, protoArtists)

        return trackDetailed, nil</span>
}

func (u *trackUsecase) GetTracksByArtistID(ctx context.Context, id int64, filters *usecaseModel.TrackFilters) ([]*usecaseModel.Track, error) <span class="cov1" title="1">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                userID = -1
        }</span>

        <span class="cov1" title="1">artistTrackIDs, err := u.artistClient.GetTrackIDsByArtistID(ctx, &amp;artistProto.ArtistID{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoFilters := &amp;trackProto.TrackIDListWithFilters{
                Ids:     model.TrackIDListFromArtistToTrackProto(artistTrackIDs, userID),
                Filters: &amp;trackProto.Filters{Pagination: model.PaginationFromUsecaseToTrackProto(filters.Pagination)},
        }

        protoTracks, err := u.trackClient.GetTracksByIDsFiltered(ctx, protoFilters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">trackIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                trackIDs = append(trackIDs, protoTrack.Id)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                albumIDs = append(albumIDs, protoTrack.AlbumId)
        }</span>

        <span class="cov1" title="1">protoAlbumTitles, err := u.albumClient.GetAlbumTitleByIDs(ctx, &amp;albumProto.AlbumIDList{Ids: model.AlbumIdsFromUsecaseToAlbumProto(albumIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByTrackIDs(ctx, &amp;artistProto.TrackIDList{Ids: model.TrackIdsFromUsecaseToArtistProto(trackIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">tracks := make([]*usecaseModel.Track, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                track := model.TrackFromProtoToUsecase(protoTrack, protoAlbumTitles.Titles[protoTrack.AlbumId], protoArtists.Artists[protoTrack.Id])
                tracks = append(tracks, track)
        }</span>

        <span class="cov1" title="1">return tracks, nil</span>
}

func (u *trackUsecase) CreateStream(ctx context.Context, stream *usecaseModel.TrackStreamCreateData) (int64, error) <span class="cov1" title="1">{
        protoTrackStreamCreateData := model.TrackStreamCreateDataFromUsecaseToProto(stream)
        streamID, err := u.trackClient.CreateStream(ctx, protoTrackStreamCreateData)
        if err != nil </span><span class="cov0" title="0">{
                return 0, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">albumID, err := u.trackClient.GetAlbumIDByTrackID(ctx, &amp;trackProto.TrackID{Id: stream.TrackID})
        if err != nil </span><span class="cov0" title="0">{
                return 0, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">artists, err := u.artistClient.GetArtistsByTrackID(ctx, &amp;artistProto.TrackID{Id: stream.TrackID})
        if err != nil </span><span class="cov0" title="0">{
                return 0, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">artistIDs := make([]int64, 0, len(artists.Artists))
        for _, artist := range artists.Artists </span><span class="cov1" title="1">{
                artistIDs = append(artistIDs, artist.Id)
        }</span>

        <span class="cov1" title="1">_, err = u.artistClient.CreateStreamsByArtistIDs(ctx, model.ArtistStreamCreateDataListFromUsecaseToProto(stream.UserID, artistIDs))
        if err != nil </span><span class="cov0" title="0">{
                return 0, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">_, err = u.albumClient.CreateStream(ctx, &amp;albumProto.AlbumStreamCreateData{
                AlbumId: &amp;albumProto.AlbumID{Id: albumID.Id},
                UserId:  &amp;albumProto.UserID{Id: stream.UserID},
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">return streamID.Id, nil</span>
}

func (u *trackUsecase) UpdateStreamDuration(ctx context.Context, endedStream *usecaseModel.TrackStreamUpdateData) error <span class="cov1" title="1">{
        protoTrackStreamUpdateData := model.TrackStreamUpdateDataFromUsecaseToProto(endedStream)
        _, err := u.trackClient.UpdateStreamDuration(ctx, protoTrackStreamUpdateData)
        if err != nil </span><span class="cov0" title="0">{
                return customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (u *trackUsecase) GetLastListenedTracks(ctx context.Context, userID int64, filters *usecaseModel.TrackFilters) ([]*usecaseModel.Track, error) <span class="cov1" title="1">{

        protoUserIDWithFilters := &amp;trackProto.UserIDWithFilters{
                UserId:  &amp;trackProto.UserID{Id: userID},
                Filters: &amp;trackProto.Filters{Pagination: model.PaginationFromUsecaseToTrackProto(filters.Pagination)},
        }

        protoTracks, err := u.trackClient.GetLastListenedTracks(ctx, protoUserIDWithFilters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">trackIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                trackIDs = append(trackIDs, protoTrack.Id)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                albumIDs = append(albumIDs, protoTrack.AlbumId)
        }</span>

        <span class="cov1" title="1">albumTitles, err := u.albumClient.GetAlbumTitleByIDs(ctx, &amp;albumProto.AlbumIDList{Ids: model.AlbumIdsFromUsecaseToAlbumProto(albumIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByTrackIDs(ctx, &amp;artistProto.TrackIDList{Ids: model.TrackIdsFromUsecaseToArtistProto(trackIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">tracks := make([]*usecaseModel.Track, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                track := model.TrackFromProtoToUsecase(protoTrack, albumTitles.Titles[protoTrack.AlbumId], protoArtists.Artists[protoTrack.Id])
                tracks = append(tracks, track)
        }</span>

        <span class="cov1" title="1">return tracks, nil</span>
}

func (u *trackUsecase) GetTracksByAlbumID(ctx context.Context, id int64) ([]*usecaseModel.Track, error) <span class="cov1" title="1">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                userID = -1
        }</span>

        <span class="cov1" title="1">protoAlbumID := &amp;trackProto.AlbumIDWithUserID{
                AlbumId: &amp;trackProto.AlbumID{Id: id},
                UserId:  &amp;trackProto.UserID{Id: userID},
        }
        protoTracks, err := u.trackClient.GetTracksByAlbumID(ctx, protoAlbumID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">trackIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                trackIDs = append(trackIDs, protoTrack.Id)
        }</span>

        <span class="cov1" title="1">albumTitle, err := u.albumClient.GetAlbumTitleByID(ctx, &amp;albumProto.AlbumID{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByTrackIDs(ctx, &amp;artistProto.TrackIDList{Ids: model.TrackIdsFromUsecaseToArtistProto(trackIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">tracks := make([]*usecaseModel.Track, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                track := model.TrackFromProtoToUsecase(protoTrack, albumTitle, protoArtists.Artists[protoTrack.Id])
                tracks = append(tracks, track)
        }</span>

        <span class="cov1" title="1">return tracks, nil</span>
}

func (u *trackUsecase) LikeTrack(ctx context.Context, request *usecaseModel.TrackLikeRequest) error <span class="cov1" title="1">{
        protoRequest := model.TrackLikeRequestFromUsecaseToProto(request)
        _, err := u.trackClient.LikeTrack(ctx, protoRequest)
        if err != nil </span><span class="cov0" title="0">{
                return customErrors.HandleTrackGRPCError(err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *trackUsecase) GetPlaylistTracks(ctx context.Context, id int64) ([]*usecaseModel.Track, error) <span class="cov1" title="1">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                userID = -1
        }</span>

        <span class="cov1" title="1">protoPlaylistTrackIds, err := u.playlistClient.GetPlaylistTrackIds(ctx, &amp;playlistProto.GetPlaylistTrackIdsRequest{
                PlaylistId: id,
                UserId:     userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandlePlaylistGRPCError(err)
        }</span>

        <span class="cov1" title="1">if len(protoPlaylistTrackIds.TrackIds) == 0 </span><span class="cov0" title="0">{
                return make([]*usecaseModel.Track, 0), nil
        }</span>

        <span class="cov1" title="1">trackIDList := make([]*trackProto.TrackID, 0, len(protoPlaylistTrackIds.TrackIds))
        for _, trackID := range protoPlaylistTrackIds.TrackIds </span><span class="cov1" title="1">{
                trackIDList = append(trackIDList, &amp;trackProto.TrackID{Id: trackID})
        }</span>

        <span class="cov1" title="1">protoTracks, err := u.trackClient.GetTracksByIDs(ctx, &amp;trackProto.TrackIDList{Ids: trackIDList, UserId: &amp;trackProto.UserID{Id: userID}})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">trackIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                trackIDs = append(trackIDs, protoTrack.Id)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                albumIDs = append(albumIDs, protoTrack.AlbumId)
        }</span>

        <span class="cov1" title="1">albumTitles, err := u.albumClient.GetAlbumTitleByIDs(ctx, &amp;albumProto.AlbumIDList{Ids: model.AlbumIdsFromUsecaseToAlbumProto(albumIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByTrackIDs(ctx, &amp;artistProto.TrackIDList{Ids: model.TrackIdsFromUsecaseToArtistProto(trackIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">tracks := make([]*usecaseModel.Track, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                track := model.TrackFromProtoToUsecase(protoTrack, albumTitles.Titles[protoTrack.AlbumId], protoArtists.Artists[protoTrack.Id])
                tracks = append(tracks, track)
        }</span>

        <span class="cov1" title="1">return tracks, nil</span>
}

func (u *trackUsecase) GetFavoriteTracks(ctx context.Context, filters *usecaseModel.TrackFilters, username string) ([]*usecaseModel.Track, error) <span class="cov3" title="2">{
        profileUserID, err := u.userClient.GetIDByUsername(ctx, &amp;userProto.Username{Username: username})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov3" title="2">requestUserID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov3" title="2">{
                requestUserID = -1
        }</span>

        <span class="cov3" title="2">profilePrivacy, err := u.userClient.GetUserPrivacyByID(ctx, &amp;userProto.UserID{Id: profileUserID.Id})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov3" title="2">if !profilePrivacy.IsPublicFavoriteTracks &amp;&amp; requestUserID != profileUserID.Id </span><span class="cov1" title="1">{
                return make([]*usecaseModel.Track, 0), nil
        }</span>

        <span class="cov1" title="1">protoFilters := &amp;trackProto.FavoriteRequest{
                ProfileUserId: &amp;trackProto.UserID{Id: profileUserID.Id},
                RequestUserId: &amp;trackProto.UserID{Id: requestUserID},
                Filters:       &amp;trackProto.Filters{Pagination: model.PaginationFromUsecaseToTrackProto(filters.Pagination)},
        }

        protoTracks, err := u.trackClient.GetFavoriteTracks(ctx, protoFilters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">trackIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                trackIDs = append(trackIDs, protoTrack.Id)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                albumIDs = append(albumIDs, protoTrack.AlbumId)
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByTrackIDs(ctx, &amp;artistProto.TrackIDList{Ids: model.TrackIdsFromUsecaseToArtistProto(trackIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoAlbumTitles, err := u.albumClient.GetAlbumTitleByIDs(ctx, &amp;albumProto.AlbumIDList{Ids: model.AlbumIdsFromUsecaseToAlbumProto(albumIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">tracks := make([]*usecaseModel.Track, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                track := model.TrackFromProtoToUsecase(protoTrack, protoAlbumTitles.Titles[protoTrack.AlbumId], protoArtists.Artists[protoTrack.Id])
                tracks = append(tracks, track)
        }</span>

        <span class="cov1" title="1">return tracks, nil</span>
}

func (u *trackUsecase) SearchTracks(ctx context.Context, query string) ([]*usecaseModel.Track, error) <span class="cov1" title="1">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov1" title="1">{
                userID = -1
        }</span>

        <span class="cov1" title="1">protoTracks, err := u.trackClient.SearchTracks(ctx, &amp;trackProto.Query{Query: query, UserId: &amp;trackProto.UserID{Id: userID}})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleTrackGRPCError(err)
        }</span>

        <span class="cov1" title="1">trackIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                trackIDs = append(trackIDs, protoTrack.Id)
        }</span>

        <span class="cov1" title="1">albumIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                albumIDs = append(albumIDs, protoTrack.AlbumId)
        }</span>

        <span class="cov1" title="1">protoArtists, err := u.artistClient.GetArtistsByTrackIDs(ctx, &amp;artistProto.TrackIDList{Ids: model.TrackIdsFromUsecaseToArtistProto(trackIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov1" title="1">protoAlbumTitles, err := u.albumClient.GetAlbumTitleByIDs(ctx, &amp;albumProto.AlbumIDList{Ids: model.AlbumIdsFromUsecaseToAlbumProto(albumIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov1" title="1">tracks := make([]*usecaseModel.Track, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov1" title="1">{
                track := model.TrackFromProtoToUsecase(protoTrack, protoAlbumTitles.Titles[protoTrack.AlbumId], protoArtists.Artists[protoTrack.Id])
                tracks = append(tracks, track)
        }</span>

        <span class="cov1" title="1">return tracks, nil</span>
}

func (u *trackUsecase) GetSelectionTracks(ctx context.Context, selection string) ([]*usecaseModel.Track, error) <span class="cov0" title="0">{
        userID, exists := ctxExtractor.UserFromContext(ctx)
        if !exists </span><span class="cov0" title="0">{
                userID = -1
        }</span>

        <span class="cov0" title="0">var protoTracks *trackProto.TrackList
        var err error
        switch selection </span>{
        case "most-liked":<span class="cov0" title="0">
                protoTracks, err = u.trackClient.GetMostLikedTracks(ctx, &amp;trackProto.UserID{Id: userID})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandleTrackGRPCError(err)
                }</span>
        case "most-recent":<span class="cov0" title="0">
                protoTracks, err = u.trackClient.GetMostRecentTracks(ctx, &amp;trackProto.UserID{Id: userID})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandleTrackGRPCError(err)
                }</span>
        case "most-listened-last-month":<span class="cov0" title="0">
                protoTracks, err = u.trackClient.GetMostListenedLastMonthTracks(ctx, &amp;trackProto.UserID{Id: userID})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandleTrackGRPCError(err)
                }</span>
        case "most-liked-last-week":<span class="cov0" title="0">
                protoTracks, err = u.trackClient.GetMostLikedLastWeekTracks(ctx, &amp;trackProto.UserID{Id: userID})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandleTrackGRPCError(err)
                }</span>
        case "top-chart":<span class="cov0" title="0">
                protoTracks, err = u.getMostListenedFromMostListenedArtists(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandleTrackGRPCError(err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, customErrors.ErrInvalidSelection</span>
        }

        <span class="cov0" title="0">trackIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov0" title="0">{
                trackIDs = append(trackIDs, protoTrack.Id)
        }</span>

        <span class="cov0" title="0">albumIDs := make([]int64, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov0" title="0">{
                albumIDs = append(albumIDs, protoTrack.AlbumId)
        }</span>

        <span class="cov0" title="0">protoArtists, err := u.artistClient.GetArtistsByTrackIDs(ctx, &amp;artistProto.TrackIDList{Ids: model.TrackIdsFromUsecaseToArtistProto(trackIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov0" title="0">protoAlbumTitles, err := u.albumClient.GetAlbumTitleByIDs(ctx, &amp;albumProto.AlbumIDList{Ids: model.AlbumIdsFromUsecaseToAlbumProto(albumIDs)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleAlbumGRPCError(err)
        }</span>

        <span class="cov0" title="0">tracks := make([]*usecaseModel.Track, 0, len(protoTracks.Tracks))
        for _, protoTrack := range protoTracks.Tracks </span><span class="cov0" title="0">{
                track := model.TrackFromProtoToUsecase(protoTrack, protoAlbumTitles.Titles[protoTrack.AlbumId], protoArtists.Artists[protoTrack.Id])
                tracks = append(tracks, track)
        }</span>

        <span class="cov0" title="0">return tracks, nil</span>
}

func (u *trackUsecase) getMostListenedFromMostListenedArtists(ctx context.Context, userID int64) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        protoFilters := &amp;artistProto.FiltersWithUserID{
                Filters: &amp;artistProto.Filters{
                        Pagination: &amp;artistProto.Pagination{
                                Offset: 0,
                                Limit:  5, // TOP 5
                        },
                },
                UserId: &amp;artistProto.UserID{Id: -1},
        }

        mostListenedArtists, err := u.artistClient.GetAllArtists(ctx, protoFilters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, customErrors.HandleArtistGRPCError(err)
        }</span>

        <span class="cov0" title="0">var combinedProtoTracks trackProto.TrackList
        for _, artist := range mostListenedArtists.Artists </span><span class="cov0" title="0">{
                artistTrackIDs, err := u.artistClient.GetTrackIDsByArtistID(ctx, &amp;artistProto.ArtistID{Id: artist.Id})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandleArtistGRPCError(err)
                }</span>

                <span class="cov0" title="0">protoFilters := &amp;trackProto.TrackIDListWithFilters{
                        Ids:     model.TrackIDListFromArtistToTrackProto(artistTrackIDs, userID),
                        Filters: &amp;trackProto.Filters{Pagination: model.PaginationFromUsecaseToTrackProto(&amp;usecaseModel.Pagination{Offset: 0, Limit: 3})},
                }

                protoTracks, err := u.trackClient.GetTracksByIDsFiltered(ctx, protoFilters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, customErrors.HandleTrackGRPCError(err)
                }</span>

                <span class="cov0" title="0">combinedProtoTracks.Tracks = append(combinedProtoTracks.Tracks, protoTracks.Tracks...)</span>
        }

        <span class="cov0" title="0">return &amp;combinedProtoTracks, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package user

import (
        "errors"
        "net/http"
        "strings"
        "time"

        "github.com/asaskevich/govalidator"
        "github.com/gorilla/mux"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/errorStatus"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/json"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        deliveryModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/delivery"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/user"
        "go.uber.org/zap"
)

var (
        ErrValidationFailed = errors.New("validation failed")
)

type UserHandler struct {
        usecase user.Usecase
}

func NewUserHandler(usecase user.Usecase) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                usecase: usecase,
        }
}</span>

func registerToUsecaseModel(user *deliveryModel.RegisterData) *usecaseModel.User <span class="cov0" title="0">{
        return &amp;usecaseModel.User{
                Username: user.Username,
                Email:    user.Email,
                Password: user.Password,
        }
}</span>

func loginToUsecaseModel(user *deliveryModel.LoginData) *usecaseModel.User <span class="cov0" title="0">{
        return &amp;usecaseModel.User{
                Username: user.Username,
                Email:    user.Email,
                Password: user.Password,
        }
}</span>

func toUserToFront(user *usecaseModel.User) *deliveryModel.UserToFront <span class="cov0" title="0">{
        isLabel := false
        if user.LabelID &gt; 0 </span><span class="cov0" title="0">{
                isLabel = true
        }</span>
        <span class="cov0" title="0">return &amp;deliveryModel.UserToFront{
                Username: user.Username,
                Email:    user.Email,
                Avatar:   user.AvatarUrl,
                IsLabel:  isLabel,
        }</span>
}

func userDeleteToUsecaseModel(user *deliveryModel.UserDelete) *usecaseModel.User <span class="cov0" title="0">{
        return &amp;usecaseModel.User{
                Username: user.Username,
                Email:    user.Email,
                Password: user.Password,
        }
}</span>

func validateData(data interface{}) (bool, error) <span class="cov0" title="0">{
        result, err := govalidator.ValidateStruct(data)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func createCookie(name string, value string, expiration time.Time, path string) *http.Cookie <span class="cov0" title="0">{
        return &amp;http.Cookie{
                Name:     name,
                Value:    value,
                Expires:  expiration,
                HttpOnly: true,
                Path:     path,
        }
}</span>

// Signup godoc
// @Summary Register a new user
// @Description Creates a new user account with provided registration data
// @Tags auth
// @Accept json
// @Produce json
// @Param register body delivery.RegisterData true "User registration data"
// @Success 200 {object} delivery.APIResponse{body=delivery.UserToFront} "User successfully registered"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid registration data"
// @Router /auth/signup [post]
func (h *UserHandler) Signup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        regData := &amp;deliveryModel.RegisterData{}
        err := json.ReadJSON(w, r, regData)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read registration data", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">if regData.Username == "default_avatar" </span><span class="cov0" title="0">{
                logger.Error("username is system word")
                json.WriteErrorResponse(w, http.StatusBadRequest, "Wrong username", nil)
                return
        }</span>
        <span class="cov0" title="0">isValid, err := validateData(regData)
        if err != nil || !isValid </span><span class="cov0" title="0">{
                logger.Error("failed to validate registration data", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, ErrValidationFailed.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">user, sessionId, err := h.usecase.CreateUser(ctx, registerToUsecaseModel(regData))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create user", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">cookie := createCookie("session_id", sessionId, time.Now().Add(24*time.Hour), "/")
        http.SetCookie(w, cookie)
        json.WriteSuccessResponse(w, http.StatusOK, toUserToFront(user), nil)</span>
}

// Login godoc
// @Summary Authenticate user
// @Description Authenticates a user with provided login credentials and returns a session
// @Tags auth
// @Accept json
// @Produce json
// @Param login body delivery.LoginData true "User login data"
// @Success 200 {object} delivery.APIResponse{body=delivery.UserToFront} "User successfully authenticated"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid login data"
// @Router /auth/login [post]
func (h *UserHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        logData := &amp;deliveryModel.LoginData{}
        err := json.ReadJSON(w, r, logData)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read login data", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">isValid, err := validateData(logData)
        if err != nil || !isValid </span><span class="cov0" title="0">{
                logger.Error("failed to validate login data", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, ErrValidationFailed.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">user, sessionId, err := h.usecase.LoginUser(ctx, loginToUsecaseModel(logData))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to login user", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">cookie := createCookie("session_id", sessionId, time.Now().Add(24*time.Hour), "/")
        http.SetCookie(w, cookie)
        json.WriteSuccessResponse(w, http.StatusOK, toUserToFront(user), nil)</span>
}

// Logout godoc
// @Summary Log out user
// @Description Terminates user session and invalidates session cookie
// @Tags auth
// @Accept json
// @Produce json
// @Success 200 {object} delivery.APIResponse{body=delivery.Message} "Successfully logged out"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - session not found"
// @Router /auth/logout [post]
func (h *UserHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get session id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">sessionId := cookie.Value
        err = h.usecase.Logout(ctx, sessionId)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to logout user", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">cookie.Expires = time.Now().AddDate(0, 0, -1)
        http.SetCookie(w, cookie)

        msg := &amp;deliveryModel.Message{
                Message: "Successfully logged out",
        }

        json.WriteSuccessResponse(w, http.StatusOK, msg, nil)</span>
}

// CheckUser godoc
// @Summary Check user authentication
// @Description Verifies user's session and returns user information if authenticated
// @Tags auth
// @Accept json
// @Produce json
// @Success 200 {object} delivery.APIResponse{body=delivery.UserToFront} "User information"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - session not found or invalid"
// @Router /auth/check [get]
func (h *UserHandler) CheckUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get session id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">sessionId := cookie.Value
        user, err := h.usecase.GetUserBySID(ctx, sessionId)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get user by session id", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">json.WriteSuccessResponse(w, http.StatusOK, toUserToFront(user), nil)</span>
}

// UploadAvatar godoc
// @Summary Upload user avatar
// @Description Uploads a new avatar image for a specific user
// @Tags user
// @Accept multipart/form-data
// @Produce json
// @Param username path string true "Username"
// @Param avatar formData file true "Avatar image file (max 5MB, image formats only)"
// @Success 200 {object} delivery.APIResponse{body=delivery.AvatarURL} "Link to the uploaded avatar image"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid file or username"
// @Router /user/me/avatar [post]
func (h *UserHandler) UploadAvatar(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        userID, exist := ctxExtractor.UserFromContext(ctx)
        if !exist </span><span class="cov0" title="0">{
                logger.Error("user not auth")
                json.WriteErrorResponse(w, http.StatusBadRequest, "user not found in context", nil)
                return
        }</span>
        <span class="cov0" title="0">userAuth, err := h.usecase.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get user by session id", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">const maxUploadSize = 5 &lt;&lt; 20
        err = r.ParseMultipartForm(maxUploadSize)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to parse form", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "failed to parse form", nil)
                return
        }</span>

        <span class="cov0" title="0">file, fileHeader, err := r.FormFile("avatar")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get file from form", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "failed to get file from form", nil)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close file", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">if fileHeader.Size &gt; maxUploadSize </span><span class="cov0" title="0">{
                logger.Error("file size exceeds limit", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, "file size exceeds limit", nil)
                return
        }</span>

        <span class="cov0" title="0">contentType := fileHeader.Header.Get("Content-Type")
        if !strings.HasPrefix(contentType, "image/") </span><span class="cov0" title="0">{
                logger.Error("invalid file type", zap.String("contentType", contentType))
                json.WriteErrorResponse(w, http.StatusBadRequest, "only image files are allowed", nil)
                return
        }</span>

        <span class="cov0" title="0">avatarURL, err := h.usecase.UploadAvatar(ctx, userAuth.Username, file, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to upload avatar", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">msg := &amp;deliveryModel.AvatarURL{
                AvatarUrl: avatarURL,
        }
        json.WriteSuccessResponse(w, http.StatusOK, msg, nil)</span>
}

// DeleteUser godoc
// @Summary Delete user account
// @Description Deletes the authenticated user's account. Requires valid session cookie and matching user credentials.
// @Tags user
// @Accept json
// @Produce json
// @Param Authorization header string true "Session ID cookie (session_id=...)"
// @Param user body delivery.UserDelete true "User credentials for deletion verification"
// @Success 200 {object} delivery.APIResponse{body=delivery.Message} "User successfully deleted"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Possible errors: invalid request body, validation failed, credentials mismatch, session cookie missing"
// @Failure 500 {object} delivery.APIBadRequestErrorResponse "Internal server error during user deletion"
// @Router /user/me [delete]
func (h *UserHandler) DeleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        userID, exist := ctxExtractor.UserFromContext(ctx)
        if !exist </span><span class="cov0" title="0">{
                logger.Error("user not auth")
                json.WriteErrorResponse(w, http.StatusBadRequest, "user not found in context", nil)
                return
        }</span>
        <span class="cov0" title="0">userAuth, err := h.usecase.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get user by session id", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">userDelete := &amp;deliveryModel.UserDelete{}
        err = json.ReadJSON(w, r, userDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read change user data", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">isValid, err := validateData(userDelete)
        if err != nil || !isValid </span><span class="cov0" title="0">{
                logger.Error("failed to validate change user data", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, ErrValidationFailed.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">if userAuth.Username != userDelete.Username || userAuth.Email != userDelete.Email </span><span class="cov0" title="0">{
                logger.Error("wrong user")
                json.WriteErrorResponse(w, http.StatusBadRequest, "user not found in context", nil)
                return
        }</span>

        <span class="cov0" title="0">cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get session id", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">sessionId := cookie.Value

        usecaseUser := userDeleteToUsecaseModel(userDelete)
        err = h.usecase.DeleteUser(ctx, usecaseUser, sessionId)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete user", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">cookie.Expires = time.Now().AddDate(0, 0, -1)
        http.SetCookie(w, cookie)
        msg := &amp;deliveryModel.Message{
                Message: "User successfully deleted",
        }
        json.WriteSuccessResponse(w, http.StatusOK, msg, nil)</span>
}

// GetUserData godoc
// @Summary Get user profile data and privacy settings
// @Description Retrieves user's profile information and privacy settings
// @Tags user
// @Accept json
// @Produce json
// @Param username path string true "Username"
// @Success 200 {object} delivery.APIResponse{body=delivery.UserFullData} "User data, privacy settings and statistics, -1 - if the statistics field is not allowed to display"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - username not found in URL or user not found"
// @Router /user/{username} [get]
func (h *UserHandler) GetUserData(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)

        vars := mux.Vars(r)
        username, ok := vars["username"]
        if !ok </span><span class="cov0" title="0">{
                logger.Error("username not found in URL")
                json.WriteErrorResponse(w, http.StatusBadRequest, "username not found in URL", nil)
                return
        }</span>

        <span class="cov0" title="0">userFullDataUsecase, err := h.usecase.GetUserData(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get user by username", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">var authUser *usecaseModel.User
        userID, isAuth := ctxExtractor.UserFromContext(ctx)
        if isAuth </span><span class="cov0" title="0">{
                authUser, err = h.usecase.GetUserByID(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to get user by session id", zap.Error(err))
                        json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                        return
                }</span>
        }

        <span class="cov0" title="0">UserFullDataDelivery := model.UserFullDataUsecaseToDelivery(userFullDataUsecase)
        isSameUser := isAuth &amp;&amp; authUser.Username == userFullDataUsecase.Username

        if !isSameUser </span><span class="cov0" title="0">{
                UserFullDataDelivery.Email = ""

                privacySettings := UserFullDataDelivery.Privacy
                UserFullDataDelivery.Privacy = nil

                if privacySettings != nil &amp;&amp; UserFullDataDelivery.Statistics != nil </span><span class="cov0" title="0">{
                        if !privacySettings.IsPublicMinutesListened </span><span class="cov0" title="0">{
                                UserFullDataDelivery.Statistics.MinutesListened = -1
                        }</span>
                        <span class="cov0" title="0">if !privacySettings.IsPublicTracksListened </span><span class="cov0" title="0">{
                                UserFullDataDelivery.Statistics.TracksListened = -1
                        }</span>
                        <span class="cov0" title="0">if !privacySettings.IsPublicArtistsListened </span><span class="cov0" title="0">{
                                UserFullDataDelivery.Statistics.ArtistsListened = -1
                        }</span>
                }
        }

        <span class="cov0" title="0">json.WriteSuccessResponse(w, http.StatusOK, UserFullDataDelivery, nil)</span>
}

// ChangeUserData godoc
// @Summary Change user data
// @Description Updates user profile information and privacy settings
// @Tags user
// @Accept json
// @Produce json
// @Param user body delivery.UserChangeSettings true "User data and privacy settings"
// @Success 200 {object} delivery.APIResponse{body=delivery.UserFullData} "Updated user data and privacy settings"
// @Failure 400 {object} delivery.APIBadRequestErrorResponse "Bad request - invalid request body, validation failed, or user not found"
// @Router /user/me [put]
func (h *UserHandler) ChangeUserData(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        logger := loggerPkg.LoggerFromContext(ctx)
        userID, exist := ctxExtractor.UserFromContext(ctx)
        if !exist </span><span class="cov0" title="0">{
                logger.Error("user not auth")
                json.WriteErrorResponse(w, http.StatusBadRequest, "user not auth", nil)
                return
        }</span>
        <span class="cov0" title="0">userAuth, err := h.usecase.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get user by session id", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">userChangeData := &amp;deliveryModel.UserChangeSettings{}
        err = json.ReadJSON(w, r, userChangeData)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to read change user data", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">isValid, err := validateData(userChangeData)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to validate change user data", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                logger.Error("failed to validate change user data", zap.Error(err))
                json.WriteErrorResponse(w, http.StatusBadRequest, ErrValidationFailed.Error(), nil)
                return
        }</span>
        <span class="cov0" title="0">userChangeDataUsecase := model.ChangeDataFromDeliveryToUsecase(userChangeData)
        if userChangeDataUsecase == nil </span><span class="cov0" title="0">{
                logger.Error("failed to convert change user data")
                json.WriteErrorResponse(w, http.StatusBadRequest, "failed to convert change user data", nil)
                return
        }</span>
        <span class="cov0" title="0">newUser, err := h.usecase.ChangeUserData(ctx, userAuth.Username, userChangeDataUsecase, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to change user data", zap.Error(err))
                json.WriteErrorResponse(w, errorStatus.ErrorStatus(err), err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">newUserDelivery := model.UserFullDataUsecaseToDelivery(newUser)
        json.WriteSuccessResponse(w, http.StatusOK, newUserDelivery, nil)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package usecase

import (
        "context"
        "errors"
        "io"

        artistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
        authProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/auth"
        playlistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/playlist"
        trackProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/track"
        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/ctxExtractor"
        cusstomErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/customErrors"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/model/usecase"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/user"
)

var (
        ErrWrongUsername = errors.New("wrong username")
)

func NewUserUsecase(userClient *userProto.UserServiceClient, authClient *authProto.AuthServiceClient, artistClient *artistProto.ArtistServiceClient, trackClient *trackProto.TrackServiceClient, playlistClient *playlistProto.PlaylistServiceClient) user.Usecase <span class="cov10" title="10">{
        return &amp;userUsecase{
                userClient:     userClient,
                authClient:     authClient,
                trackClient:    trackClient,
                artistClient:   artistClient,
                playlistClient: playlistClient,
        }
}</span>

type userUsecase struct {
        userClient     *userProto.UserServiceClient
        authClient     *authProto.AuthServiceClient
        artistClient   *artistProto.ArtistServiceClient
        trackClient    *trackProto.TrackServiceClient
        playlistClient *playlistProto.PlaylistServiceClient
}

func (u *userUsecase) CreateUser(ctx context.Context, user *usecaseModel.User) (*usecaseModel.User, string, error) <span class="cov3" title="2">{
        newUser, err := (*u.userClient).CreateUser(ctx, model.RegisterDataFromUsecaseToProto(user))
        if err != nil </span><span class="cov1" title="1">{
                return nil, "", cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov1" title="1">userUsecase := model.UserFromProtoToUsecase(newUser)
        avatar_url, err := (*u.userClient).GetUserAvatarURL(ctx, model.FileKeyFromUsecaseToProto(userUsecase.AvatarUrl))
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov1" title="1">userUsecase.AvatarUrl = model.AvatarUrlFromProtoToUsecase(avatar_url)
        sessionID, err := (*u.authClient).CreateSession(ctx, model.UserIDFromUsecaseToProto(userUsecase.ID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", cusstomErrors.HandleAuthGRPCError(err)
        }</span>
        <span class="cov1" title="1">return userUsecase, model.SessionIDFromProtoToUsecase(sessionID), nil</span>
}

func (u *userUsecase) GetUserBySID(ctx context.Context, SID string) (*usecaseModel.User, error) <span class="cov1" title="1">{
        id, err := (*u.authClient).GetSession(ctx, model.SessionIDFromUsecaseToProto(SID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, cusstomErrors.HandleAuthGRPCError(err)
        }</span>
        <span class="cov1" title="1">userID := model.UserIDFromProtoToUsecase(id)
        user, err := (*u.userClient).GetUserByID(ctx, model.UserIDFromUsecaseToProtoUser(userID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov1" title="1">userUsecase := model.UserFromProtoToUsecase(user)
        avatar_url, err := (*u.userClient).GetUserAvatarURL(ctx, model.FileKeyFromUsecaseToProto(userUsecase.AvatarUrl))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">labelID, isLabel := ctxExtractor.LabelFromContext(ctx)
        if isLabel </span><span class="cov0" title="0">{
                userUsecase.LabelID = labelID
        }</span> else<span class="cov1" title="1"> {
                userUsecase.LabelID = -1
        }</span>
        <span class="cov1" title="1">userUsecase.AvatarUrl = model.AvatarUrlFromProtoToUsecase(avatar_url)
        return userUsecase, nil</span>
}

func (u *userUsecase) LoginUser(ctx context.Context, user *usecaseModel.User) (*usecaseModel.User, string, error) <span class="cov1" title="1">{
        loginUser, err := (*u.userClient).LoginUser(ctx, model.LoginDataFromUsecaseToProto(user))
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov1" title="1">userUsecase := model.UserFromProtoToUsecase(loginUser)
        avatar_url, err := (*u.userClient).GetUserAvatarURL(ctx, model.FileKeyFromUsecaseToProto(userUsecase.AvatarUrl))
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov1" title="1">userUsecase.AvatarUrl = model.AvatarUrlFromProtoToUsecase(avatar_url)
        sessionID, err := (*u.authClient).CreateSession(ctx, model.UserIDFromUsecaseToProto(userUsecase.ID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", cusstomErrors.HandleAuthGRPCError(err)
        }</span>
        <span class="cov1" title="1">return userUsecase, model.SessionIDFromProtoToUsecase(sessionID), nil</span>
}

func (u *userUsecase) Logout(ctx context.Context, SID string) error <span class="cov1" title="1">{
        _, err := (*u.authClient).DeleteSession(ctx, model.SessionIDFromUsecaseToProto(SID))
        if err != nil </span><span class="cov0" title="0">{
                return cusstomErrors.HandleAuthGRPCError(err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *userUsecase) UploadAvatar(ctx context.Context, username string, fileAvatar io.Reader, ID int64) (string, error) <span class="cov1" title="1">{
        image, err := io.ReadAll(fileAvatar)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">fileURL, err := (*u.userClient).UploadUserAvatar(ctx, model.AvatarImageFromUsecaseToProto(username, image))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">fileUrlUsecase := model.FileKeyFromProtoToUsecase(fileURL)
        _, err = (*u.userClient).UploadAvatar(ctx, model.AvatarDataFromUsecaseToProto(fileUrlUsecase, ID))
        if err != nil </span><span class="cov0" title="0">{
                return "", cusstomErrors.HandleUserGRPCError(err)
        }</span>

        <span class="cov1" title="1">avatarUrl, err := (*u.userClient).GetUserAvatarURL(ctx, model.FileKeyFromUsecaseToProto(fileUrlUsecase))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">avatarUrlUsecase := model.AvatarUrlFromProtoToUsecase(avatarUrl)
        return avatarUrlUsecase, nil</span>
}

func (u *userUsecase) DeleteUser(ctx context.Context, user *usecaseModel.User, SID string) error <span class="cov1" title="1">{
        _, err := (*u.userClient).DeleteUser(ctx, model.DeleteUserFromUsecaseToProto(user))
        if err != nil </span><span class="cov0" title="0">{
                return cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov1" title="1">_, err = (*u.authClient).DeleteSession(ctx, model.SessionIDFromUsecaseToProto(SID))
        if err != nil </span><span class="cov0" title="0">{
                return cusstomErrors.HandleAuthGRPCError(err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *userUsecase) GetArtistsListened(ctx context.Context, username string) (int64, error) <span class="cov3" title="2">{
        id, err := (*u.userClient).GetIDByUsername(ctx, model.UsernameFromUsecaseToProto(username))
        if err != nil </span><span class="cov0" title="0">{
                return -1, cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov3" title="2">userID := model.UserIDFromProtoToUsecaseUser(id)
        artistListened, err := (*u.artistClient).GetArtistsListenedByUserID(ctx, model.UserIDFromUsecaseToProtoArtist(userID))
        if err != nil </span><span class="cov0" title="0">{
                return -1, cusstomErrors.HandleArtistGRPCError(err)
        }</span>
        <span class="cov3" title="2">artistListenedUsecase := model.ArtistsListenedFromProtoToUsecase(artistListened)
        return artistListenedUsecase, nil</span>
}

func (u *userUsecase) GetTracksListened(ctx context.Context, username string) (int64, error) <span class="cov3" title="2">{
        id, err := (*u.userClient).GetIDByUsername(ctx, model.UsernameFromUsecaseToProto(username))
        if err != nil </span><span class="cov0" title="0">{
                return -1, cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov3" title="2">userID := model.UserIDFromProtoToUsecaseUser(id)
        trackListened, err := (*u.trackClient).GetTracksListenedByUserID(ctx, model.UserIDFromUsecaseToProtoTrack(userID))
        if err != nil </span><span class="cov0" title="0">{
                return -1, cusstomErrors.HandleTrackGRPCError(err)
        }</span>
        <span class="cov3" title="2">trackListenedUsecase := model.TracksListenedFromProtoToUsecase(trackListened)
        return trackListenedUsecase, nil</span>
}

func (u *userUsecase) GetMinutesListened(ctx context.Context, username string) (int64, error) <span class="cov3" title="2">{
        id, err := (*u.userClient).GetIDByUsername(ctx, model.UsernameFromUsecaseToProto(username))
        if err != nil </span><span class="cov0" title="0">{
                return -1, cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov3" title="2">userID := model.UserIDFromProtoToUsecaseUser(id)
        minutesListened, err := (*u.trackClient).GetMinutesListenedByUserID(ctx, model.UserIDFromUsecaseToProtoTrack(userID))
        if err != nil </span><span class="cov0" title="0">{
                return -1, cusstomErrors.HandleTrackGRPCError(err)
        }</span>
        <span class="cov3" title="2">minutesListenedUsecase := model.MinutesListenedFromProtoToUsecase(minutesListened)
        return minutesListenedUsecase, nil</span>
}

func (u *userUsecase) GetUserData(ctx context.Context, username string) (*usecaseModel.UserFullData, error) <span class="cov3" title="2">{
        userFullData, err := (*u.userClient).GetUserFullData(ctx, model.UsernameFromUsecaseToProto(username))
        if err != nil </span><span class="cov0" title="0">{
                return nil, cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov3" title="2">userFullDataUsecase := model.UserFullDataFromProtoToUsecase(userFullData)
        artistsListened, err := u.GetArtistsListened(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">tracksListened, err := u.GetTracksListened(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">minutesListened, err := u.GetMinutesListened(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">stats := &amp;usecaseModel.UserStatistics{
                ArtistsListened: artistsListened,
                TracksListened:  tracksListened,
                MinutesListened: minutesListened,
        }
        userFullDataUsecase.Statistics = stats
        avatarURL, err := (*u.userClient).GetUserAvatarURL(ctx, model.FileKeyFromUsecaseToProto(userFullDataUsecase.AvatarUrl))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">avatarURLUsecase := model.AvatarUrlFromProtoToUsecase(avatarURL)
        userFullDataUsecase.AvatarUrl = avatarURLUsecase
        return userFullDataUsecase, nil</span>
}

func (u *userUsecase) ChangeUserData(ctx context.Context, username string, userChangeData *usecaseModel.UserChangeSettings, userID int64) (*usecaseModel.UserFullData, error) <span class="cov1" title="1">{
        if userChangeData.Privacy != nil </span><span class="cov1" title="1">{
                _, err := (*u.userClient).ChangeUserPrivacySettings(ctx, model.PrivacyFromUsecaseToProto(username, userChangeData.Privacy))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, cusstomErrors.HandleUserGRPCError(err)
                }</span>

                <span class="cov1" title="1">_, err = (*u.playlistClient).UpdatePlaylistsPublisityByUserID(ctx, model.UpdatePlaylistsPublisityByUserIDRequestFromUsecaseToProto(userChangeData.Privacy.IsPublicPlaylists, userID))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov1" title="1">_, err := (*u.userClient).ChangeUserData(ctx, model.ChangeUserDataFromUsecaseToProto(username, userChangeData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov1" title="1">updatedUsername := username
        if userChangeData.NewUsername != "" </span><span class="cov1" title="1">{
                updatedUsername = userChangeData.NewUsername
        }</span>
        <span class="cov1" title="1">userFullDataUsecase, err := u.GetUserData(ctx, updatedUsername)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return userFullDataUsecase, nil</span>
}

func (u *userUsecase) GetUserByID(ctx context.Context, id int64) (*usecaseModel.User, error) <span class="cov1" title="1">{
        user, err := (*u.userClient).GetUserByID(ctx, model.UserIDFromUsecaseToProtoUser(id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov1" title="1">userUsecase := model.UserFromProtoToUsecase(user)
        avatarURL, err := (*u.userClient).GetUserAvatarURL(ctx, model.FileKeyFromUsecaseToProto(userUsecase.AvatarUrl))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">avatarURLUsecase := model.AvatarUrlFromProtoToUsecase(avatarURL)
        userUsecase.AvatarUrl = avatarURLUsecase
        return userUsecase, nil</span>
}

func (u *userUsecase) GetLabelIDByUserID(ctx context.Context, userID int64) (int64, error) <span class="cov0" title="0">{
        labelID, err := (*u.userClient).GetLabelIDByUserID(ctx, model.UserIDFromUsecaseToProtoUser(userID))
        if err != nil </span><span class="cov0" title="0">{
                return -1, cusstomErrors.HandleUserGRPCError(err)
        }</span>
        <span class="cov0" title="0">labelIDUsecase := model.LabelIDFromProtoToUsecase(labelID)
        return labelIDUsecase, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package main

import (
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        albumProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/album"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/postgres"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/s3"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/repository"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/usecase"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/interceptors"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.uber.org/zap"
        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        logger, err := loggerPkg.NewZapLogger()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creating logger:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error syncing logger:", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error loading config:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">port := fmt.Sprintf(":%d", cfg.Services.AlbumService.Port)
        conn, err := net.Listen("tcp", port)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Can't start album service:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">reg := prometheus.NewRegistry()
        metrics := metrics.NewMetrics(reg, "album_service")

        accessInterceptor := interceptors.NewAccessInterceptor(logger, metrics)

        server := grpc.NewServer(
                grpc.UnaryInterceptor(accessInterceptor.UnaryServerInterceptor()),
                grpc.MaxRecvMsgSize(50*1024*1024), // 50 MB
                grpc.MaxSendMsgSize(50*1024*1024), // 50 MB
        )

        postgresPool, err := postgres.ConnectPostgres(cfg.Postgres)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error connecting to postgres:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := postgresPool.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing postgres pool:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">fmt.Println("config ", cfg.S3.S3ImagesBucket)
        s3, err := s3.InitS3(cfg.S3)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initializing S3:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
                address := fmt.Sprintf(":%d", cfg.Prometheus.AlbumPort)
                logger.Info(fmt.Sprintf("Serving metrics responds on port %d", cfg.Prometheus.AlbumPort))
                if err := http.ListenAndServe(address, nil); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Error starting metrics server", zap.String("error", err.Error()))
                }</span>
        }()

        <span class="cov0" title="0">albumRepository := repository.NewAlbumPostgresRepository(postgresPool, metrics)
        s3Repository := repository.NewS3Repository(s3, cfg.S3.S3ImagesBucket, metrics)
        albumUsecase := usecase.NewAlbumUsecase(albumRepository, s3Repository)
        albumService := delivery.NewAlbumService(albumUsecase)
        albumProto.RegisterAlbumServiceServer(server, albumService)

        logger.Info("Album service started", zap.String("port", port))

        err = server.Serve(conn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error starting album service:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)
        &lt;-c

        server.GracefulStop()
        logger.Info("Album service stopped")</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package delivery

import (
        "context"

        albumProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/album"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model"
        "google.golang.org/protobuf/types/known/emptypb"
)

type AlbumService struct {
        albumProto.UnimplementedAlbumServiceServer
        albumUsecase domain.Usecase
}

func NewAlbumService(albumUsecase domain.Usecase) albumProto.AlbumServiceServer <span class="cov0" title="0">{
        return &amp;AlbumService{
                albumUsecase: albumUsecase,
        }
}</span>

func (s *AlbumService) GetAllAlbums(ctx context.Context, req *albumProto.FiltersWithUserID) (*albumProto.AlbumList, error) <span class="cov0" title="0">{
        userID := req.UserId.Id
        albums, err := s.albumUsecase.GetAllAlbums(ctx, model.AlbumFiltersFromProtoToUsecase(req.Filters), userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.AlbumListFromUsecaseToProto(albums), nil</span>
}

func (s *AlbumService) GetAlbumByID(ctx context.Context, req *albumProto.AlbumIDWithUserID) (*albumProto.Album, error) <span class="cov0" title="0">{
        album, err := s.albumUsecase.GetAlbumByID(ctx, req.AlbumId.Id, req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.AlbumFromUsecaseToProto(album), nil</span>
}

func (s *AlbumService) GetAlbumTitleByID(ctx context.Context, req *albumProto.AlbumID) (*albumProto.AlbumTitle, error) <span class="cov0" title="0">{
        albumTitle, err := s.albumUsecase.GetAlbumTitleByID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;albumProto.AlbumTitle{
                Title: albumTitle,
        }, nil</span>
}

func (s *AlbumService) GetAlbumTitleByIDs(ctx context.Context, req *albumProto.AlbumIDList) (*albumProto.AlbumTitleMap, error) <span class="cov0" title="0">{
        ids := make([]int64, len(req.Ids))
        for i, id := range req.Ids </span><span class="cov0" title="0">{
                ids[i] = id.Id
        }</span>
        <span class="cov0" title="0">albumTitles, err := s.albumUsecase.GetAlbumTitleByIDs(ctx, ids)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.AlbumTitleMapFromUsecaseToProto(albumTitles), nil</span>
}

func (s *AlbumService) GetAlbumsByIDs(ctx context.Context, req *albumProto.AlbumIDListWithUserID) (*albumProto.AlbumList, error) <span class="cov0" title="0">{
        ids := make([]int64, len(req.Ids.Ids))
        for i, id := range req.Ids.Ids </span><span class="cov0" title="0">{
                ids[i] = id.Id
        }</span>
        <span class="cov0" title="0">albums, err := s.albumUsecase.GetAlbumsByIDs(ctx, ids, req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.AlbumListFromUsecaseToProto(albums), nil</span>
}

func (s *AlbumService) CreateStream(ctx context.Context, req *albumProto.AlbumStreamCreateData) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.albumUsecase.CreateStream(ctx, req.AlbumId.Id, req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AlbumService) LikeAlbum(ctx context.Context, req *albumProto.LikeRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.albumUsecase.LikeAlbum(ctx, model.LikeRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AlbumService) GetFavoriteAlbums(ctx context.Context, req *albumProto.FiltersWithUserID) (*albumProto.AlbumList, error) <span class="cov0" title="0">{
        albums, err := s.albumUsecase.GetFavoriteAlbums(ctx, model.AlbumFiltersFromProtoToUsecase(req.Filters), req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.AlbumListFromUsecaseToProto(albums), nil</span>
}

func (s *AlbumService) SearchAlbums(ctx context.Context, req *albumProto.Query) (*albumProto.AlbumList, error) <span class="cov0" title="0">{
        albums, err := s.albumUsecase.SearchAlbums(ctx, req.Query, req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.AlbumListFromUsecaseToProto(albums), nil</span>
}

func (s *AlbumService) CreateAlbum(ctx context.Context, req *albumProto.CreateAlbumRequest) (*albumProto.AlbumIDAndURL, error) <span class="cov0" title="0">{
        albumID, url, err := s.albumUsecase.CreateAlbum(ctx, model.AlbumRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;albumProto.AlbumIDAndURL{
                Id:  albumID,
                Url: url,
        }, nil</span>
}

func (s *AlbumService) DeleteAlbum(ctx context.Context, req *albumProto.AlbumID) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.albumUsecase.DeleteAlbum(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AlbumService) GetAlbumsLabelID(ctx context.Context, req *albumProto.FiltersWithLabelID) (*albumProto.AlbumList, error) <span class="cov0" title="0">{
        albums, err := s.albumUsecase.GetAlbumsLabelID(ctx, model.AlbumFiltersFromProtoToUsecase(req.Filters), req.LabelId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.AlbumListFromUsecaseToProto(albums), nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "strings"
        "time"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/domain"
        albumErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model/errors"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model/repository"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/lib/pq"
        "go.uber.org/zap"
)

const (
        GetAllAlbumsQuery = `
                SELECT a.id, a.title, a.type, a.thumbnail_url, a.release_date, (fa.user_id IS NOT NULL) AS is_favorite
                FROM album a
                LEFT JOIN album_stats als ON a.id = als.album_id
                LEFT JOIN favorite_album fa ON a.id = fa.album_id AND fa.user_id = $3
                ORDER BY als.listeners_count DESC, a.id DESC
                LIMIT $1 OFFSET $2
        `
        GetAlbumByIDQuery = `
                SELECT a.id, a.title, a.type, a.thumbnail_url, a.release_date, (fa.user_id IS NOT NULL) AS is_favorite
                FROM album a
                LEFT JOIN favorite_album fa ON a.id = fa.album_id AND fa.user_id = $2
                WHERE a.id = $1
        `
        GetAlbumTitleByIDQuery = `
                SELECT title
                FROM album
                WHERE id = $1
        `
        GetAlbumTitleByIDsQuery = `
                SELECT id, title
                FROM album
                WHERE id = ANY($1)
        `
        GetAlbumsByIDsQuery = `
                SELECT a.id, a.title, a.type, a.thumbnail_url, a.release_date, (fa.user_id IS NOT NULL) AS is_favorite
                FROM album a
                LEFT JOIN album_stats als ON a.id = als.album_id
                LEFT JOIN favorite_album fa ON a.id = fa.album_id AND fa.user_id = $2
                WHERE a.id = ANY($1)
                ORDER BY als.listeners_count DESC, a.id DESC
        `

        CreateStreamQuery = `
                INSERT INTO album_stream (album_id, user_id)
                VALUES ($1, $2)
        `

        CheckAlbumExistsQuery = `
                SELECT EXISTS (
                        SELECT 1
                        FROM album
                        WHERE id = $1
                )
        `

        LikeAlbumQuery = `
                INSERT INTO favorite_album (album_id, user_id)
                VALUES ($1, $2) ON CONFLICT DO NOTHING
        `

        UnlikeAlbumQuery = `
                DELETE FROM favorite_album
                WHERE album_id = $1 AND user_id = $2
        `

        GetFavoriteAlbumsQuery = `
                SELECT a.id, a.title, a.type, a.thumbnail_url, a.release_date
                FROM album a
                JOIN favorite_album fa ON a.id = fa.album_id
                WHERE fa.user_id = $1
                ORDER BY fa.created_at DESC, a.id DESC
                LIMIT $2 OFFSET $3
        `

        SearchAlbumsQuery = `
                SELECT a.id, a.title, a.type, a.thumbnail_url, a.release_date, (fa.user_id IS NOT NULL) AS is_favorite
                FROM album a
                LEFT JOIN favorite_album fa ON a.id = fa.album_id AND fa.user_id = $2
                WHERE a.search_vector @@ to_tsquery('multilingual', $1)
                   OR similarity(a.title_trgm, $3) &gt; 0.3
                ORDER BY 
                    CASE WHEN a.search_vector @@ to_tsquery('multilingual', $1) THEN 0 ELSE 1 END,
                    ts_rank(a.search_vector, to_tsquery('multilingual', $1)) DESC,
                    similarity(a.title_trgm, $3) DESC
        `

        CreateAlbumQuery = `
                INSERT INTO album (title, type, thumbnail_url, label_id)
                VALUES ($1, $2, $3, $4)
                RETURNING id`

        DeleteAlbumQuery = `
                DELETE FROM album
                WHERE id = $1
        `
        GetAlbumsLabelIDQuery = `
                SELECT a.id, a.title, a.type, a.thumbnail_url, a.release_date, FALSE AS is_favorite
                FROM album a
                JOIN album_stats als ON a.id = als.album_id
                WHERE a.label_id = $1
                ORDER BY als.listeners_count DESC, a.id DESC
                LIMIT $2 OFFSET $3
        `
)

type albumPostgresRepository struct {
        db      *sql.DB
        metrics *metrics.Metrics
}

func NewAlbumPostgresRepository(db *sql.DB, metrics *metrics.Metrics) domain.Repository <span class="cov10" title="18">{
        return &amp;albumPostgresRepository{
                db:      db,
                metrics: metrics,
        }
}</span>

func (r *albumPostgresRepository) GetAllAlbums(ctx context.Context, filters *repoModel.AlbumFilters, userID int64) ([]*repoModel.Album, error) <span class="cov3" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting all albums from db", zap.Any("filters", filters), zap.String("query", GetAllAlbumsQuery))

        stmt, err := r.db.PrepareContext(ctx, GetAllAlbumsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAllAlbums").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="2">rows, err := stmt.QueryContext(ctx, filters.Pagination.Limit, filters.Pagination.Offset, userID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAllAlbums").Inc()
                logger.Error("failed to get all albums", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get all albums: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">albums := make([]*repoModel.Album, 0)
        for rows.Next() </span><span class="cov3" title="2">{
                var album repoModel.Album
                err = rows.Scan(&amp;album.ID, &amp;album.Title, &amp;album.Type, &amp;album.Thumbnail, &amp;album.ReleaseDate, &amp;album.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetAllAlbums").Inc()
                        logger.Error("failed to scan album", zap.Error(err))
                        return nil, albumErrors.NewInternalError("failed to scan album: %v", err)
                }</span>
                <span class="cov3" title="2">albums = append(albums, &amp;album)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAllAlbums").Inc()
                logger.Error("failed to get all albums", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get all albums: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAllAlbums").Observe(duration)
        return albums, nil</span>
}

func (r *albumPostgresRepository) GetAlbumByID(ctx context.Context, id int64, userID int64) (*repoModel.Album, error) <span class="cov3" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting album by id from db", zap.Int64("id", id), zap.String("query", GetAlbumByIDQuery))

        stmt, err := r.db.PrepareContext(ctx, GetAlbumByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumByID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="2">row := stmt.QueryRowContext(ctx, id, userID)

        var albumObject repoModel.Album
        err = row.Scan(&amp;albumObject.ID, &amp;albumObject.Title, &amp;albumObject.Type, &amp;albumObject.Thumbnail, &amp;albumObject.ReleaseDate, &amp;albumObject.IsFavorite)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumByID").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        logger.Error("album not found", zap.Error(err))
                        return nil, albumErrors.ErrAlbumNotFound
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get album by id", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get album by id: %v", err)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAlbumByID").Observe(duration)
        return &amp;albumObject, nil</span>
}

func (r *albumPostgresRepository) GetAlbumTitleByIDs(ctx context.Context, ids []int64) (map[int64]string, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting album title by ids from db", zap.Any("ids", ids), zap.String("query", GetAlbumTitleByIDsQuery))

        stmt, err := r.db.PrepareContext(ctx, GetAlbumTitleByIDsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumTitleByIDs").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, pq.Array(ids))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumTitleByIDs").Inc()
                logger.Error("failed to get album title by ids", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get album title by ids: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">albums := make(map[int64]string)
        for rows.Next() </span><span class="cov3" title="2">{
                var id int64
                var title string
                err = rows.Scan(&amp;id, &amp;title)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetAlbumTitleByIDs").Inc()
                        logger.Error("failed to scan album title", zap.Error(err))
                        return nil, albumErrors.NewInternalError("failed to scan album title: %v", err)
                }</span>
                <span class="cov3" title="2">albums[id] = title</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumTitleByIDs").Inc()
                logger.Error("failed to get album title by ids", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get album title by ids: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAlbumTitleByIDs").Observe(duration)
        return albums, nil</span>
}

func (r *albumPostgresRepository) GetAlbumTitleByID(ctx context.Context, id int64) (string, error) <span class="cov3" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting album title by id from db", zap.Int64("id", id), zap.String("query", GetAlbumTitleByIDQuery))

        stmt, err := r.db.PrepareContext(ctx, GetAlbumTitleByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumTitleByID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return "", albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="2">row := stmt.QueryRowContext(ctx, id)

        var title string
        err = row.Scan(&amp;title)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumTitleByID").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        logger.Error("album not found", zap.Error(err))
                        return "", albumErrors.ErrAlbumNotFound
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get album title by id", zap.Error(err))
                return "", albumErrors.NewInternalError("failed to get album title by id: %v", err)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAlbumTitleByID").Observe(duration)
        return title, nil</span>
}

func (r *albumPostgresRepository) GetAlbumsByIDs(ctx context.Context, ids []int64, userID int64) ([]*repoModel.Album, error) <span class="cov3" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting albums by ids from db", zap.Any("ids", ids), zap.String("query", GetAlbumsByIDsQuery))

        stmt, err := r.db.PrepareContext(ctx, GetAlbumsByIDsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumsByIDs").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="2">rows, err := stmt.QueryContext(ctx, pq.Array(ids), userID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumsByIDs").Inc()
                logger.Error("failed to get albums by ids", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get albums by ids: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">var albums []*repoModel.Album
        for rows.Next() </span><span class="cov3" title="2">{
                var album repoModel.Album
                err = rows.Scan(&amp;album.ID, &amp;album.Title, &amp;album.Type, &amp;album.Thumbnail, &amp;album.ReleaseDate, &amp;album.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetAlbumsByIDs").Inc()
                        logger.Error("failed to scan album", zap.Error(err))
                        return nil, albumErrors.NewInternalError("failed to scan album: %v", err)
                }</span>
                <span class="cov3" title="2">albums = append(albums, &amp;album)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumsByIDs").Inc()
                logger.Error("failed to get albums by ids", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get albums by ids: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAlbumsByIDs").Observe(duration)
        return albums, nil</span>
}

func (r *albumPostgresRepository) CreateStream(ctx context.Context, albumID int64, userID int64) error <span class="cov3" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Creating stream for album", zap.Int64("albumID", albumID), zap.Int64("userID", userID), zap.String("query", CreateStreamQuery))
        stmt, err := r.db.PrepareContext(ctx, CreateStreamQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStream").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="2">_, err = stmt.ExecContext(ctx, albumID, userID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStream").Inc()
                logger.Error("failed to create stream", zap.Error(err))
                return albumErrors.NewInternalError("failed to create stream: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CreateStream").Observe(duration)
        return nil</span>
}

func (r *albumPostgresRepository) CheckAlbumExists(ctx context.Context, albumID int64) (bool, error) <span class="cov3" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking if album exists in db", zap.Int64("albumID", albumID), zap.String("query", CheckAlbumExistsQuery))
        stmt, err := r.db.PrepareContext(ctx, CheckAlbumExistsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStream").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return false, albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">row := stmt.QueryRowContext(ctx, albumID)

        var exists bool
        err = row.Scan(&amp;exists)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to check if album exists", zap.Error(err))
                return false, albumErrors.NewInternalError("failed to check if album exists: %v", err)
        }</span>
        <span class="cov1" title="1">return exists, nil</span>
}

func (r *albumPostgresRepository) LikeAlbum(ctx context.Context, request *repoModel.LikeRequest) error <span class="cov1" title="1">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Liking album", zap.Int64("albumID", request.AlbumID), zap.Int64("userID", request.UserID), zap.String("query", LikeAlbumQuery))
        stmt, err := r.db.PrepareContext(ctx, LikeAlbumQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("Like album").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">_, err = stmt.ExecContext(ctx, request.AlbumID, request.UserID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to like album", zap.Error(err))
                return albumErrors.NewInternalError("failed to like album: %v", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (r *albumPostgresRepository) UnlikeAlbum(ctx context.Context, request *repoModel.LikeRequest) error <span class="cov1" title="1">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Unliking album", zap.Int64("albumID", request.AlbumID), zap.Int64("userID", request.UserID), zap.String("query", UnlikeAlbumQuery))
        stmt, err := r.db.PrepareContext(ctx, UnlikeAlbumQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("Unlike album").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">_, err = stmt.ExecContext(ctx, request.AlbumID, request.UserID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to unlike album", zap.Error(err))
                return albumErrors.NewInternalError("failed to unlike album: %v", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (r *albumPostgresRepository) GetFavoriteAlbums(ctx context.Context, filters *repoModel.AlbumFilters, userID int64) ([]*repoModel.Album, error) <span class="cov1" title="1">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting favorite albums from db", zap.Any("filters", filters), zap.String("query", GetFavoriteAlbumsQuery))

        stmt, err := r.db.PrepareContext(ctx, GetFavoriteAlbumsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetFavoriteAlbums").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, userID, filters.Pagination.Limit, filters.Pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get favorite albums", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get favorite albums: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">var albums []*repoModel.Album
        for rows.Next() </span><span class="cov3" title="2">{
                var album repoModel.Album
                // Ставим по дефолту, так как запрашивашиваются избранные, то есть заведомо известно, что они лайкнуты
                album.IsFavorite = true
                err = rows.Scan(&amp;album.ID, &amp;album.Title, &amp;album.Type, &amp;album.Thumbnail, &amp;album.ReleaseDate)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to scan album", zap.Error(err))
                        return nil, albumErrors.NewInternalError("failed to scan album: %v", err)
                }</span>
                <span class="cov3" title="2">albums = append(albums, &amp;album)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get favorite albums", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get favorite albums: %v", err)
        }</span>

        <span class="cov1" title="1">return albums, nil</span>
}

func (r *albumPostgresRepository) SearchAlbums(ctx context.Context, query string, userID int64) ([]*repoModel.Album, error) <span class="cov3" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Searching albums by query", zap.String("query", query), zap.String("query", SearchAlbumsQuery))
        stmt, err := r.db.PrepareContext(ctx, SearchAlbumsQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">words := strings.Fields(query)
        for i, word := range words </span><span class="cov4" title="3">{
                words[i] = word + ":*"
        }</span>
        <span class="cov3" title="2">tsQueryString := strings.Join(words, " &amp; ")

        rows, err := stmt.QueryContext(ctx, tsQueryString, userID, query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to search albums", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to search albums: %v", err)
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="2">var albums []*repoModel.Album
        for rows.Next() </span><span class="cov4" title="3">{
                var album repoModel.Album
                err = rows.Scan(&amp;album.ID, &amp;album.Title, &amp;album.Type, &amp;album.Thumbnail, &amp;album.ReleaseDate, &amp;album.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to scan album", zap.Error(err))
                        return nil, albumErrors.NewInternalError("failed to scan album: %v", err)
                }</span>
                <span class="cov4" title="3">albums = append(albums, &amp;album)</span>
        }

        <span class="cov3" title="2">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to search albums", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to search albums: %v", err)
        }</span>

        <span class="cov3" title="2">return albums, nil</span>
}

func (r *albumPostgresRepository) CreateAlbum(ctx context.Context, album *repoModel.CreateAlbumRequest) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Creating album in db", zap.Any("album", album), zap.String("query", "CreateAlbum"))

        stmt, err := r.db.PrepareContext(ctx, CreateAlbumQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateAlbum").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return 0, albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">var albumID int64
        err = stmt.QueryRowContext(ctx, album.Title, album.Type, album.Thumbnail, album.LabelID).Scan(&amp;albumID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateAlbum").Inc()
                logger.Error("failed to create album", zap.Error(err))
                return 0, albumErrors.NewInternalError("failed to create album: %v", err)
        }</span>

        <span class="cov0" title="0">_, err = r.db.ExecContext(ctx, "REFRESH MATERIALIZED VIEW CONCURRENTLY album_stats")
    if err != nil </span><span class="cov0" title="0">{
        logger.Warn("failed to refresh album_stats view, album may not be visible for up to 1 minute", zap.Error(err))
    }</span>

        <span class="cov0" title="0">r.metrics.DatabaseDuration.WithLabelValues("CreateAlbum").Observe(time.Since(start).Seconds())
        logger.Info("Album created successfully", zap.Int64("albumID", albumID))

        return albumID, nil</span>
}

func (r *albumPostgresRepository) DeleteAlbum(ctx context.Context, albumID int64) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Deleting album from db", zap.Int64("albumID", albumID), zap.String("query", "DeleteAlbum"))

        stmt, err := r.db.PrepareContext(ctx, DeleteAlbumQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteAlbum").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = stmt.ExecContext(ctx, albumID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteAlbum").Inc()
                logger.Error("failed to delete album", zap.Error(err))
                return albumErrors.NewInternalError("failed to delete album: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *albumPostgresRepository) GetAlbumsLabelID(ctx context.Context, filters *repoModel.AlbumFilters, labelID int64) ([]*repoModel.Album, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting albums by label ID from db", zap.Int64("labelID", labelID), zap.Any("filters", filters), zap.String("query", "GetAlbumsLabelID"))

        stmt, err := r.db.PrepareContext(ctx, GetAlbumsLabelIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumsLabelID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">rows, err := stmt.QueryContext(ctx, labelID, filters.Pagination.Limit, filters.Pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumsLabelID").Inc()
                logger.Error("failed to get all albums", zap.Error(err))
                return nil, albumErrors.NewInternalError("failed to get all albums: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">albums := make([]*repoModel.Album, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var album repoModel.Album
                var isFavorite sql.NullBool
                err = rows.Scan(&amp;album.ID, &amp;album.Title, &amp;album.Type, &amp;album.Thumbnail, &amp;album.ReleaseDate, &amp;isFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetAlbumsLabelID").Inc()
                        logger.Error("failed to scan album", zap.Error(err))
                        return nil, albumErrors.NewInternalError("failed to scan album: %v", err)
                }</span>
                <span class="cov0" title="0">album.IsFavorite = isFavorite.Valid &amp;&amp; isFavorite.Bool
                albums = append(albums, &amp;album)</span>
        }
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAlbumsLabelID").Observe(duration)
        return albums, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package repository

import (
        "bytes"
        "context"
        "fmt"
        "time"

        "image"

        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/domain"
        albumErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model/errors"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "go.uber.org/zap"
)

type artistS3Repository struct {
        s3         *s3.S3
        uploader   *s3manager.Uploader
        bucketName string
        metrics    *metrics.Metrics
}

func NewS3Repository(s3 *s3.S3, bucketName string, metrics *metrics.Metrics) domain.S3Repository <span class="cov0" title="0">{
        uploader := s3manager.NewUploaderWithClient(s3)
        return &amp;artistS3Repository{
                s3:         s3,
                bucketName: bucketName,
                uploader:   uploader,
                metrics:    metrics,
        }
}</span>

func (r *artistS3Repository) GetAvatarURL(ctx context.Context, fileKey string) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        if fileKey == "" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAvatarURL").Inc()
                logger.Error("fileKey is empty")
                return "", albumErrors.NewEmptyS3KeyError("fileKey is empty")
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAvatarURL").Observe(duration)
        return fmt.Sprintf(
                "https://%s.fra1.digitaloceanspaces.com/albums%s",
                r.bucketName,
                fileKey,
        ), nil</span>
}

func (r *artistS3Repository) UploadAlbumAvatar(ctx context.Context, artistTitle string, file []byte) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        date := time.Now()
        dateString := date.Format("20060102150405")

        _, format, err := image.Decode(bytes.NewReader(file))
        fmt.Println("ALBUM FORMAT: ", format)
        logger.Info("format", zap.String("format", format))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadAlbumAvatar").Inc()
                logger.Error("unsupported or invalid image format", zap.Error(err))
                return "", albumErrors.NewUnsupportedImageFormatError("unsupported or invalid image format")
        }</span>

        <span class="cov0" title="0">if format != "jpeg" &amp;&amp; format != "png" &amp;&amp; format != "gif" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadAlbumAvatar").Inc()
                logger.Error("unsupported image format", zap.String("format", format))
                return "", albumErrors.NewUnsupportedImageFormatError("unsupported or invalid image format")
        }</span>

        // webpBuf := new(bytes.Buffer)
        // if err := webp.Encode(webpBuf, img, &amp;webp.Options{Lossless: true}); err != nil {
        //         logger.Error("failed to encode webp", zap.Error(err))
        //         return "", userAvatarFile.ErrFailedToEncodeWebp
        // }

        <span class="cov0" title="0">fileKey := fmt.Sprintf("/%s-%s.%s", artistTitle, dateString, format)
        s3Key := fmt.Sprintf("albums%s", fileKey)

        _, err = r.uploader.UploadWithContext(ctx, &amp;s3manager.UploadInput{
                Bucket:      aws.String(r.bucketName),
                Key:         aws.String(s3Key),
                Body:        bytes.NewReader(file),
                ContentType: aws.String("image/" + format),
                ACL:         aws.String("public-read"),
        })

        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadArtistAvatar").Inc()
                logger.Error("upload failed", zap.Error(err))
                return "", albumErrors.NewFailedToUploadAvatarError("failed to upload avatar")
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UploadArtistAvatar").Observe(duration)

        return fmt.Sprintf("https://%s.fra1.digitaloceanspaces.com/albums%s", r.bucketName, fileKey), nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package usecase

import (
        "context"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model"
        albumErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model/errors"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model/usecase"
)

type AlbumUsecase struct {
        albumRepository domain.Repository
        s3Repository    domain.S3Repository
}

func NewAlbumUsecase(albumRepository domain.Repository, s3Repository domain.S3Repository) domain.Usecase <span class="cov0" title="0">{
        return &amp;AlbumUsecase{albumRepository: albumRepository, s3Repository: s3Repository}
}</span>

func (u *AlbumUsecase) GetAllAlbums(ctx context.Context, filters *usecaseModel.AlbumFilters, userID int64) ([]*usecaseModel.Album, error) <span class="cov0" title="0">{
        repoFilters := model.FiltersFromUsecaseToRepository(filters)
        albums, err := u.albumRepository.GetAllAlbums(ctx, repoFilters, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.AlbumListFromRepositoryToUsecase(albums), nil</span>
}

func (u *AlbumUsecase) GetAlbumByID(ctx context.Context, id int64, userID int64) (*usecaseModel.Album, error) <span class="cov0" title="0">{
        album, err := u.albumRepository.GetAlbumByID(ctx, id, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.AlbumFromRepositoryToUsecase(album), nil</span>
}

func (u *AlbumUsecase) GetAlbumTitleByID(ctx context.Context, id int64) (string, error) <span class="cov0" title="0">{
        title, err := u.albumRepository.GetAlbumTitleByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return title, nil</span>
}

func (u *AlbumUsecase) GetAlbumTitleByIDs(ctx context.Context, ids []int64) (*usecaseModel.AlbumTitleMap, error) <span class="cov0" title="0">{
        repoIds := make([]int64, len(ids))
        copy(repoIds, ids)

        albumTitles, err := u.albumRepository.GetAlbumTitleByIDs(ctx, repoIds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.AlbumTitleMapFromRepositoryToUsecase(albumTitles), nil</span>
}

func (u *AlbumUsecase) GetAlbumsByIDs(ctx context.Context, ids []int64, userID int64) ([]*usecaseModel.Album, error) <span class="cov0" title="0">{
        repoIds := make([]int64, len(ids))
        copy(repoIds, ids)

        albums, err := u.albumRepository.GetAlbumsByIDs(ctx, repoIds, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.AlbumListFromRepositoryToUsecase(albums), nil</span>
}

func (u *AlbumUsecase) CreateStream(ctx context.Context, albumID int64, userID int64) error <span class="cov0" title="0">{
        return u.albumRepository.CreateStream(ctx, albumID, userID)
}</span>

func (u *AlbumUsecase) LikeAlbum(ctx context.Context, request *usecaseModel.LikeRequest) error <span class="cov0" title="0">{
        repoRequest := model.LikeRequestFromUsecaseToRepository(request)

        exists, err := u.albumRepository.CheckAlbumExists(ctx, request.AlbumID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return albumErrors.NewNotFoundError("album not found")
        }</span>
        <span class="cov0" title="0">if request.IsLike </span><span class="cov0" title="0">{
                err := u.albumRepository.LikeAlbum(ctx, repoRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">err = u.albumRepository.UnlikeAlbum(ctx, repoRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *AlbumUsecase) GetFavoriteAlbums(ctx context.Context, filters *usecaseModel.AlbumFilters, userID int64) ([]*usecaseModel.Album, error) <span class="cov0" title="0">{
        repoFilters := model.FiltersFromUsecaseToRepository(filters)
        albums, err := u.albumRepository.GetFavoriteAlbums(ctx, repoFilters, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.AlbumListFromRepositoryToUsecase(albums), nil</span>
}

func (u *AlbumUsecase) SearchAlbums(ctx context.Context, query string, userID int64) ([]*usecaseModel.Album, error) <span class="cov0" title="0">{
        albums, err := u.albumRepository.SearchAlbums(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.AlbumListFromRepositoryToUsecase(albums), nil</span>
}

func (u *AlbumUsecase) CreateAlbum(ctx context.Context, album *usecaseModel.CreateAlbumRequest) (int64, string, error) <span class="cov0" title="0">{
        repoAlbum := model.AlbumRequestFromUsecaseToRepository(album)
        avatarThumbnail, err := u.s3Repository.UploadAlbumAvatar(ctx, album.Title, album.Image)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", err
        }</span>
        <span class="cov0" title="0">repoAlbum.Thumbnail = avatarThumbnail
        albumID, err := u.albumRepository.CreateAlbum(ctx, repoAlbum)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", err
        }</span>

        <span class="cov0" title="0">return albumID, avatarThumbnail, nil</span>
}

func (u *AlbumUsecase) DeleteAlbum(ctx context.Context, albumID int64) error <span class="cov0" title="0">{
        exists, err := u.albumRepository.CheckAlbumExists(ctx, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return albumErrors.NewNotFoundError("album not found")
        }</span>
        <span class="cov0" title="0">err = u.albumRepository.DeleteAlbum(ctx, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *AlbumUsecase) GetAlbumsLabelID(ctx context.Context, filters *usecaseModel.AlbumFilters, labelID int64) ([]*usecaseModel.Album, error) <span class="cov0" title="0">{
        repoFilters := model.FiltersFromUsecaseToRepository(filters)
        albums, err := u.albumRepository.GetAlbumsLabelID(ctx, repoFilters, labelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.AlbumListFromRepositoryToUsecase(albums), nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package model

import (
        albumProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/album"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model/repository"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/album/model/usecase"
        "google.golang.org/protobuf/types/known/timestamppb"
)

func PaginationFromUsecaseToRepository(pagination *usecaseModel.Pagination) *repoModel.Pagination <span class="cov3" title="2">{
        return &amp;repoModel.Pagination{
                Offset: pagination.Offset,
                Limit:  pagination.Limit,
        }
}</span>

func FiltersFromUsecaseToRepository(filters *usecaseModel.AlbumFilters) *repoModel.AlbumFilters <span class="cov1" title="1">{
        return &amp;repoModel.AlbumFilters{
                Pagination: PaginationFromUsecaseToRepository(filters.Pagination),
        }
}</span>

func PaginationFromProtoToUsecase(pagination *albumProto.Pagination) *usecaseModel.Pagination <span class="cov3" title="2">{
        return &amp;usecaseModel.Pagination{
                Offset: pagination.Offset,
                Limit:  pagination.Limit,
        }
}</span>

func AlbumFiltersFromProtoToUsecase(filters *albumProto.Filters) *usecaseModel.AlbumFilters <span class="cov1" title="1">{
        return &amp;usecaseModel.AlbumFilters{
                Pagination: PaginationFromProtoToUsecase(filters.Pagination),
        }
}</span>

func AlbumTypeFromRepositoryToUsecase(albumType repoModel.AlbumType) usecaseModel.AlbumType <span class="cov8" title="7">{
        return usecaseModel.AlbumType(albumType)
}</span>

func AlbumTypeFromUsecaseToProto(albumType usecaseModel.AlbumType) albumProto.AlbumType <span class="cov10" title="10">{
        switch albumType </span>{
        case usecaseModel.AlbumTypeAlbum:<span class="cov6" title="4">
                return albumProto.AlbumType_AlbumTypeAlbum</span>
        case usecaseModel.AlbumTypeEP:<span class="cov5" title="3">
                return albumProto.AlbumType_AlbumTypeEP</span>
        case usecaseModel.AlbumTypeSingle:<span class="cov1" title="1">
                return albumProto.AlbumType_AlbumTypeSingle</span>
        case usecaseModel.AlbumTypeCompilation:<span class="cov1" title="1">
                return albumProto.AlbumType_AlbumTypeCompilation</span>
        }
        <span class="cov1" title="1">return albumProto.AlbumType_AlbumTypeAlbum</span>
}

func AlbumFromRepositoryToUsecase(album *repoModel.Album) *usecaseModel.Album <span class="cov5" title="3">{
        return &amp;usecaseModel.Album{
                ID:          album.ID,
                Title:       album.Title,
                Type:        AlbumTypeFromRepositoryToUsecase(album.Type),
                Thumbnail:   album.Thumbnail,
                ReleaseDate: album.ReleaseDate,
                IsFavorite:  album.IsFavorite,
        }
}</span>

func AlbumFromUsecaseToProto(album *usecaseModel.Album) *albumProto.Album <span class="cov5" title="3">{
        return &amp;albumProto.Album{
                Id:          album.ID,
                Title:       album.Title,
                Type:        AlbumTypeFromUsecaseToProto(album.Type),
                Thumbnail:   album.Thumbnail,
                ReleaseDate: timestamppb.New(album.ReleaseDate),
                IsFavorite:  album.IsFavorite,
        }
}</span>

func AlbumListFromRepositoryToUsecase(albums []*repoModel.Album) []*usecaseModel.Album <span class="cov1" title="1">{
        albumList := make([]*usecaseModel.Album, len(albums))
        for i, album := range albums </span><span class="cov3" title="2">{
                albumList[i] = AlbumFromRepositoryToUsecase(album)
        }</span>
        <span class="cov1" title="1">return albumList</span>
}

func AlbumListFromUsecaseToProto(albums []*usecaseModel.Album) *albumProto.AlbumList <span class="cov1" title="1">{
        albumList := make([]*albumProto.Album, len(albums))
        for i, album := range albums </span><span class="cov3" title="2">{
                albumList[i] = AlbumFromUsecaseToProto(album)
        }</span>
        <span class="cov1" title="1">return &amp;albumProto.AlbumList{
                Albums: albumList,
        }</span>
}

func AlbumTitleFromUsecaseToProto(albumTitle *usecaseModel.AlbumTitle) *albumProto.AlbumTitle <span class="cov5" title="3">{
        return &amp;albumProto.AlbumTitle{
                Title: albumTitle.Title,
        }
}</span>

func AlbumTitleMapFromRepositoryToUsecase(albumTitles map[int64]string) *usecaseModel.AlbumTitleMap <span class="cov1" title="1">{
        albumTitleMap := make(map[int64]*usecaseModel.AlbumTitle)
        for key, albumTitle := range albumTitles </span><span class="cov3" title="2">{
                albumTitleMap[key] = &amp;usecaseModel.AlbumTitle{
                        Title: albumTitle,
                }
        }</span>

        <span class="cov1" title="1">return &amp;usecaseModel.AlbumTitleMap{
                Titles: albumTitleMap,
        }</span>
}

func AlbumTitleMapFromUsecaseToProto(albumTitles *usecaseModel.AlbumTitleMap) *albumProto.AlbumTitleMap <span class="cov1" title="1">{
        albumTitleMap := make(map[int64]*albumProto.AlbumTitle)
        for key, albumTitle := range albumTitles.Titles </span><span class="cov3" title="2">{
                albumTitleMap[key] = AlbumTitleFromUsecaseToProto(albumTitle)
        }</span>
        <span class="cov1" title="1">return &amp;albumProto.AlbumTitleMap{
                Titles: albumTitleMap,
        }</span>
}

func AlbumStreamCreateDataFromUsecaseToProto(albumStreamCreateData *usecaseModel.AlbumStreamCreateData) *albumProto.AlbumStreamCreateData <span class="cov1" title="1">{
        return &amp;albumProto.AlbumStreamCreateData{
                AlbumId: &amp;albumProto.AlbumID{Id: albumStreamCreateData.AlbumID},
                UserId:  &amp;albumProto.UserID{Id: albumStreamCreateData.UserID},
        }
}</span>

func AlbumStreamCreateDataFromProtoToUsecase(albumStreamCreateData *albumProto.AlbumStreamCreateData) *usecaseModel.AlbumStreamCreateData <span class="cov1" title="1">{
        return &amp;usecaseModel.AlbumStreamCreateData{
                AlbumID: albumStreamCreateData.AlbumId.Id,
                UserID:  albumStreamCreateData.UserId.Id,
        }
}</span>

func LikeRequestFromProtoToUsecase(likeRequest *albumProto.LikeRequest) *usecaseModel.LikeRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.LikeRequest{
                AlbumID: likeRequest.AlbumId.Id,
                UserID:  likeRequest.UserId.Id,
                IsLike:  likeRequest.IsLike,
        }
}</span>

func LikeRequestFromUsecaseToRepository(likeRequest *usecaseModel.LikeRequest) *repoModel.LikeRequest <span class="cov1" title="1">{
        return &amp;repoModel.LikeRequest{
                AlbumID: likeRequest.AlbumID,
                UserID:  likeRequest.UserID,
        }
}</span>

func AlbumTypeFromProtoToUsecase(albumType albumProto.AlbumType) usecaseModel.AlbumType <span class="cov0" title="0">{
        switch albumType </span>{
        case albumProto.AlbumType_AlbumTypeAlbum:<span class="cov0" title="0">
                return usecaseModel.AlbumTypeAlbum</span>
        case albumProto.AlbumType_AlbumTypeEP:<span class="cov0" title="0">
                return usecaseModel.AlbumTypeEP</span>
        case albumProto.AlbumType_AlbumTypeSingle:<span class="cov0" title="0">
                return usecaseModel.AlbumTypeSingle</span>
        case albumProto.AlbumType_AlbumTypeCompilation:<span class="cov0" title="0">
                return usecaseModel.AlbumTypeCompilation</span>
        }
        <span class="cov0" title="0">return usecaseModel.AlbumTypeAlbum</span>
}

func AlbumRequestFromProtoToUsecase(albumRequest *albumProto.CreateAlbumRequest) *usecaseModel.CreateAlbumRequest <span class="cov0" title="0">{
        return &amp;usecaseModel.CreateAlbumRequest{
                Type:    AlbumTypeFromProtoToUsecase(albumRequest.Type),
                Title:   albumRequest.Title,
                Image:   albumRequest.Image,
                LabelID: albumRequest.LabelId,
        }
}</span>

func AlbumRequestFromUsecaseToRepository(albumRequest *usecaseModel.CreateAlbumRequest) *repoModel.CreateAlbumRequest <span class="cov0" title="0">{
        return &amp;repoModel.CreateAlbumRequest{
                Type:    repoModel.AlbumType(albumRequest.Type),
                Title:   albumRequest.Title,
                Image:   albumRequest.Image,
                LabelID: albumRequest.LabelID,
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package errors

import (
        "fmt"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type AlbumError struct {
        Code    codes.Code
        Message string
}

func (e *AlbumError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func (e *AlbumError) GRPCStatus() *status.Status <span class="cov0" title="0">{
        return status.New(e.Code, e.Message)
}</span>

func NewNotFoundError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;AlbumError{
                Code:    codes.NotFound,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewInternalError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;AlbumError{
                Code:    codes.Internal,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewEmptyS3KeyError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;AlbumError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewUnsupportedImageFormatError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;AlbumError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewFailedToUploadAvatarError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;AlbumError{
                Code:    codes.Internal,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

var (
        ErrAlbumNotFound = NewNotFoundError("album not found")
)
</pre>
		
		<pre class="file" id="file48" style="display: none">package main

import (
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/postgres"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/s3"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/repository"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/usecase"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/interceptors"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.uber.org/zap"
        "google.golang.org/grpc"

        artistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
)

func main() <span class="cov0" title="0">{
        logger, err := loggerPkg.NewZapLogger()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creating logger:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error syncing logger:", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error loading config:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">port := fmt.Sprintf(":%d", cfg.Services.ArtistService.Port)
        conn, err := net.Listen("tcp", port)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Can't start artist service:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">reg := prometheus.NewRegistry()
        metrics := metrics.NewMetrics(reg, "artist_service")

        accessInterceptor := interceptors.NewAccessInterceptor(logger, metrics)

        server := grpc.NewServer(
                grpc.UnaryInterceptor(accessInterceptor.UnaryServerInterceptor()),
        )

        postgresPool, err := postgres.ConnectPostgres(cfg.Postgres)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error connecting to postgres:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := postgresPool.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing Postgres:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">fmt.Println("config ", cfg.S3.S3ImagesBucket)
        s3, err := s3.InitS3(cfg.S3)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initializing S3:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
                address := fmt.Sprintf(":%d", cfg.Prometheus.ArtistPort)
                logger.Info(fmt.Sprintf("Serving metrics responds on port %d", cfg.Prometheus.ArtistPort))
                if err := http.ListenAndServe(address, nil); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Error starting metrics server", zap.String("error", err.Error()))
                }</span>
        }()

        <span class="cov0" title="0">artistRepository := repository.NewArtistPostgresRepository(postgresPool, metrics)
        s3Repository := repository.NewS3Repository(s3, cfg.S3.S3ImagesBucket, metrics)
        artistUsecase := usecase.NewArtistUsecase(artistRepository, s3Repository)
        artistService := delivery.NewArtistService(artistUsecase)
        artistProto.RegisterArtistServiceServer(server, artistService)

        logger.Info("Artist service started", zap.String("port", port))

        err = server.Serve(conn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error starting artist service:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)
        &lt;-c

        server.GracefulStop()
        logger.Info("Artist service stopped")</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package delivery

import (
        "context"

        artistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model"
        "google.golang.org/protobuf/types/known/emptypb"
)

type ArtistService struct {
        artistProto.UnimplementedArtistServiceServer
        artistUsecase domain.Usecase
}

func NewArtistService(artistUsecase domain.Usecase) artistProto.ArtistServiceServer <span class="cov0" title="0">{
        return &amp;ArtistService{
                artistUsecase: artistUsecase,
        }
}</span>

func (s *ArtistService) GetArtistByID(ctx context.Context, req *artistProto.ArtistIDWithUserID) (*artistProto.ArtistDetailed, error) <span class="cov0" title="0">{
        userID := req.UserId.Id
        artist, err := s.artistUsecase.GetArtistByID(ctx, req.ArtistId.Id, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistDetailedFromUsecaseToProto(artist), nil</span>
}

func (s *ArtistService) GetAllArtists(ctx context.Context, req *artistProto.FiltersWithUserID) (*artistProto.ArtistList, error) <span class="cov0" title="0">{
        userID := req.UserId.Id
        artists, err := s.artistUsecase.GetAllArtists(ctx, model.ArtistFiltersFromProtoToUsecase(req.Filters), userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistListFromUsecaseToProto(artists), nil</span>
}

func (s *ArtistService) GetArtistTitleByID(ctx context.Context, req *artistProto.ArtistID) (*artistProto.ArtistTitle, error) <span class="cov0" title="0">{
        artist, err := s.artistUsecase.GetArtistTitleByID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;artistProto.ArtistTitle{
                Title: artist,
        }, nil</span>
}

func (s *ArtistService) GetArtistsByTrackID(ctx context.Context, req *artistProto.TrackID) (*artistProto.ArtistWithRoleList, error) <span class="cov0" title="0">{
        artists, err := s.artistUsecase.GetArtistsByTrackID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistWithRoleListFromUsecaseToProto(artists), nil</span>
}

func (s *ArtistService) GetArtistsByTrackIDs(ctx context.Context, req *artistProto.TrackIDList) (*artistProto.ArtistWithRoleMap, error) <span class="cov0" title="0">{
        artists, err := s.artistUsecase.GetArtistsByTrackIDs(ctx, model.TrackIDListFromProtoToUsecase(req.Ids))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistWithRoleMapFromUsecaseToProto(artists), nil</span>
}

func (s *ArtistService) GetArtistsByAlbumID(ctx context.Context, req *artistProto.AlbumID) (*artistProto.ArtistWithTitleList, error) <span class="cov0" title="0">{
        artists, err := s.artistUsecase.GetArtistsByAlbumID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistWithTitleListFromUsecaseToProto(artists), nil</span>
}

func (s *ArtistService) GetArtistsByAlbumIDs(ctx context.Context, req *artistProto.AlbumIDList) (*artistProto.ArtistWithTitleMap, error) <span class="cov0" title="0">{
        artists, err := s.artistUsecase.GetArtistsByAlbumIDs(ctx, model.AlbumIDListFromProtoToUsecase(req.Ids))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistWithTitleMapFromUsecaseToProto(artists), nil</span>
}

func (s *ArtistService) GetAlbumIDsByArtistID(ctx context.Context, req *artistProto.ArtistID) (*artistProto.AlbumIDList, error) <span class="cov0" title="0">{
        albumIDs, err := s.artistUsecase.GetAlbumIDsByArtistID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">albumIDList := make([]*artistProto.AlbumID, 0, len(albumIDs))
        for _, albumID := range albumIDs </span><span class="cov0" title="0">{
                albumIDList = append(albumIDList, &amp;artistProto.AlbumID{Id: albumID})
        }</span>
        <span class="cov0" title="0">return &amp;artistProto.AlbumIDList{Ids: albumIDList}, nil</span>
}

func (s *ArtistService) GetTrackIDsByArtistID(ctx context.Context, req *artistProto.ArtistID) (*artistProto.TrackIDList, error) <span class="cov0" title="0">{
        trackIDs, err := s.artistUsecase.GetTrackIDsByArtistID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">trackIDList := make([]*artistProto.TrackID, 0, len(trackIDs))
        for _, trackID := range trackIDs </span><span class="cov0" title="0">{
                trackIDList = append(trackIDList, &amp;artistProto.TrackID{Id: trackID})
        }</span>
        <span class="cov0" title="0">return &amp;artistProto.TrackIDList{Ids: trackIDList}, nil</span>
}

func (s *ArtistService) CreateStreamsByArtistIDs(ctx context.Context, req *artistProto.ArtistStreamCreateDataList) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.artistUsecase.CreateStreamsByArtistIDs(ctx, model.ArtistStreamCreateDataFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ArtistService) GetArtistsListenedByUserID(ctx context.Context, req *artistProto.UserID) (*artistProto.ArtistListened, error) <span class="cov0" title="0">{
        artistsListened, err := s.artistUsecase.GetArtistsListenedByUserID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;artistProto.ArtistListened{ArtistsListened: artistsListened}, nil</span>
}

func (s *ArtistService) LikeArtist(ctx context.Context, req *artistProto.LikeRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.artistUsecase.LikeArtist(ctx, model.LikeRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ArtistService) GetFavoriteArtists(ctx context.Context, req *artistProto.FiltersWithUserID) (*artistProto.ArtistList, error) <span class="cov0" title="0">{
        artists, err := s.artistUsecase.GetFavoriteArtists(ctx, model.ArtistFiltersFromProtoToUsecase(req.Filters), req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistListFromUsecaseToProto(artists), nil</span>
}

func (s *ArtistService) SearchArtists(ctx context.Context, req *artistProto.Query) (*artistProto.ArtistList, error) <span class="cov0" title="0">{
        artists, err := s.artistUsecase.SearchArtists(ctx, req.Query, req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistListFromUsecaseToProto(artists), nil</span>
}

func (s *ArtistService) CreateArtist(ctx context.Context, req *artistProto.ArtistLoad) (*artistProto.Artist, error) <span class="cov0" title="0">{
        artist, err := s.artistUsecase.CreateArtist(ctx, model.ArtistLoadFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistFromUsecaseToProto(artist), nil</span>
}

func (s *ArtistService) EditArtist(ctx context.Context, req *artistProto.ArtistEdit) (*artistProto.Artist, error) <span class="cov0" title="0">{
        artist, err := s.artistUsecase.EditArtist(ctx, model.ArtistEditFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistFromUsecaseToProto(artist), nil</span>
}

func (s *ArtistService) GetArtistsLabelID(ctx context.Context, req *artistProto.FiltersWithLabelID) (*artistProto.ArtistList, error) <span class="cov0" title="0">{
        artists, err := s.artistUsecase.GetArtistsLabelID(ctx, model.ArtistFiltersFromProtoToUsecase(req.Filters), req.LabelId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistListFromUsecaseToProto(artists), nil</span>
}

func (s *ArtistService) DeleteArtist(ctx context.Context, req *artistProto.ArtistDelete) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.artistUsecase.DeleteArtist(ctx, model.ArtistDeleteFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *ArtistService) ConnectArtists(ctx context.Context, req *artistProto.ArtistsIDWithAlbumID) (*emptypb.Empty, error) <span class="cov0" title="0">{
        artistsID, albumID, tracksID := model.ArtistsIDWithAlbumIDFromProtoToUsecase(req)
        err := s.artistUsecase.ConnectArtists(ctx, artistsID, albumID, tracksID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "strings"
        "time"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/domain"
        artistErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model/errors"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model/repository"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/lib/pq"
        "go.uber.org/zap"
)

const (
        GetAllArtistsQuery = `
                SELECT artist.id, artist.title, artist.description, artist.thumbnail_url, (favorite_artist.user_id IS NOT NULL) AS is_favorite
                FROM artist
                JOIN artist_stats ON artist.id = artist_stats.artist_id
                LEFT JOIN favorite_artist ON artist.id = favorite_artist.artist_id AND favorite_artist.user_id = $3
                ORDER BY artist_stats.listeners_count DESC, id DESC
                LIMIT $1 OFFSET $2
        `
        GetArtistByIDQuery = `
                SELECT artist.id, artist.title, artist.description, artist.thumbnail_url, (favorite_artist.user_id IS NOT NULL) AS is_favorite
                FROM artist
                LEFT JOIN favorite_artist ON artist.id = favorite_artist.artist_id AND favorite_artist.user_id = $2
                WHERE artist.id = $1
        `
        GetArtistTitleByIDQuery = `
                SELECT title
                FROM artist
                WHERE id = $1
        `
        GetArtistsByTrackIDQuery = `
                SELECT a.id, a.title, ta.role
                FROM artist a
                JOIN track_artist ta ON ta.artist_id = a.id
                WHERE ta.track_id = $1
                ORDER BY CASE 
                        WHEN ta.role = 'main' THEN 1
                        WHEN ta.role = 'featured' THEN 2
                        WHEN ta.role = 'producer' THEN 3
                        ELSE 4
                END ASC
        `

        GetArtistsByTrackIDsQuery = `
                SELECT a.id, a.title, ta.role, ta.track_id
                FROM artist a
                JOIN track_artist ta ON ta.artist_id = a.id
                WHERE ta.track_id = ANY($1)
                ORDER BY CASE
                        WHEN ta.role = 'main' THEN 1
                        WHEN ta.role = 'featured' THEN 2
                        WHEN ta.role = 'producer' THEN 3
                        ELSE 4
                END ASC
        `

        GetArtistStatsQuery = `
                SELECT 
                        listeners_count,
                        favorites_count
                FROM artist_stats
                WHERE artist_id = $1
        `

        GetArtistsByAlbumIDQuery = `
                SELECT a.id, a.title
                FROM artist a
                JOIN album_artist aa ON a.id = aa.artist_id
                WHERE aa.album_id = $1
                ORDER BY aa.created_at DESC, aa.id DESC
        `

        GetArtistsByAlbumIDsQuery = `
                SELECT a.id, a.title, aa.album_id
                FROM artist a
                JOIN album_artist aa ON a.id = aa.artist_id
                WHERE aa.album_id = ANY($1)
                ORDER BY aa.created_at DESC, aa.id DESC
        `

        GetAlbumIDsByArtistIDQuery = `
                SELECT album_id
                FROM album_artist
                WHERE artist_id = $1
        `

        GetTrackIDsByArtistID = `
                SELECT track_id
                FROM track_artist
                WHERE artist_id = $1
        `

        GetArtistsListenedByUserIDQuery = `
                SELECT COUNT(DISTINCT artist_id)
                FROM artist_stream
                WHERE user_id = $1
        `

        LikeArtistByUserIDQuery = `
                INSERT INTO favorite_artist (artist_id, user_id) VALUES ($1, $2)
                ON CONFLICT (artist_id, user_id) DO NOTHING
        `

        UnlikeArtistByUserIDQuery = `
                DELETE FROM favorite_artist WHERE artist_id = $1 AND user_id = $2
        `

        CheckArtistExistsQuery = `
                SELECT EXISTS (SELECT 1 FROM artist WHERE id = $1)
        `

        GetFavoriteArtistsQuery = `
                SELECT artist.id, artist.title, artist.description, artist.thumbnail_url
                FROM artist
                JOIN favorite_artist ON artist.id = favorite_artist.artist_id
                WHERE favorite_artist.user_id = $1
                ORDER BY favorite_artist.created_at DESC, artist.id DESC
                LIMIT $2 OFFSET $3
        `

        SearchArtistsQuery = `
                SELECT a.id, a.title, a.description, a.thumbnail_url
                FROM artist a
                LEFT JOIN favorite_artist fa ON a.id = fa.artist_id AND fa.user_id = $2
                WHERE a.search_vector @@ to_tsquery('multilingual', $1)
                   OR similarity(a.title_trgm, $3) &gt; 0.3
                ORDER BY 
                    CASE WHEN a.search_vector @@ to_tsquery('multilingual', $1) THEN 0 ELSE 1 END,
                    ts_rank(a.search_vector, to_tsquery('multilingual', $1)) DESC,
                    similarity(a.title_trgm, $3) DESC
        `

        CreateArtistQuery = `
                INSERT INTO artist (title, thumbnail_url, label_id)
                VALUES ($1, $2, $3)
                RETURNING id
        `

        CheckArtistNameExist = `
                SELECT 1 
                FROM artist
                WHERE id = $1
        `

        UpdateArtistNameQuery = `
                UPDATE artist
                SET title = $1
                WHERE id = $2
        `

        GetArtistByIdWithoutUserQuery = `
                SELECT id, title, description, thumbnail_url
                FROM artist
                WHERE id = $1
        `

        UpdateArtistAvatarQuery = `
                UPDATE artist
                SET thumbnail_url = $1
                WHERE id = $2
        `

        GetArtistLabelIdByIDQuery = `
                SELECT label_id
                FROM artist
                WHERE id = $1
        `

        GetArtistsLabelIDQuery = `
        SELECT artist.id, artist.title, artist.description, artist.thumbnail_url, FALSE AS is_favorite
        FROM artist
        JOIN artist_stats ON artist.id = artist_stats.artist_id
        WHERE artist.label_id = $3
        ORDER BY artist_stats.listeners_count DESC, id DESC
        LIMIT $1 OFFSET $2
    `

        DeleteArtistQuery = `
                DELETE 
                FROM artist
                WHERE id = $1
        `

        AddArtistsToAlbum = `
                INSERT INTO album_artist (artist_id, album_id) 
                SELECT unnest($1::bigint[]), $2
        `

        AddArtistsToTracks = `
                INSERT INTO track_artist (artist_id, track_id, role)
        SELECT a, t, 'main'
        FROM unnest($1::bigint[]) AS a
        CROSS JOIN unnest($2::bigint[]) AS t
        ON CONFLICT (track_id, artist_id, role) DO NOTHING
        `
)

type artistPostgresRepository struct {
        db      *sql.DB
        metrics *metrics.Metrics
}

func NewArtistPostgresRepository(db *sql.DB, metrics *metrics.Metrics) domain.Repository <span class="cov10" title="21">{
        return &amp;artistPostgresRepository{db: db, metrics: metrics}
}</span>

func (r *artistPostgresRepository) GetAllArtists(ctx context.Context, filters *repoModel.Filters, userID int64) ([]*repoModel.Artist, error) <span class="cov3" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting all artists with filters from db", zap.Any("filters", filters), zap.String("query", GetAllArtistsQuery))
        stmt, err := r.db.PrepareContext(ctx, GetAllArtistsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAllArtitst").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov3" title="2">rows, err := stmt.QueryContext(ctx, filters.Pagination.Limit, filters.Pagination.Offset, userID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAllArtitst").Inc()
                logger.Error("failed to get all artists", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get all artists: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">artists := make([]*repoModel.Artist, 0)
        for rows.Next() </span><span class="cov3" title="2">{
                var artist repoModel.Artist
                var isFavorite sql.NullBool
                err = rows.Scan(&amp;artist.ID, &amp;artist.Title, &amp;artist.Description, &amp;artist.Thumbnail, &amp;isFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetAllArtitst").Inc()
                        logger.Error("failed to scan artist", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan artist: %v", err)
                }</span>
                <span class="cov3" title="2">artist.IsFavorite = isFavorite.Valid &amp;&amp; isFavorite.Bool
                artists = append(artists, &amp;artist)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAllArtists").Observe(duration)
        return artists, nil</span>
}

func (r *artistPostgresRepository) GetArtistByID(ctx context.Context, id int64, userID int64) (*repoModel.Artist, error) <span class="cov3" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artist by id from db", zap.Int64("id", id), zap.String("query", GetArtistByIDQuery))
        stmt, err := r.db.PrepareContext(ctx, GetArtistByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistByID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov3" title="2">row := stmt.QueryRowContext(ctx, id, userID)

        var artistObject repoModel.Artist
        var isFavorite sql.NullBool
        err = row.Scan(&amp;artistObject.ID, &amp;artistObject.Title, &amp;artistObject.Description, &amp;artistObject.Thumbnail, &amp;isFavorite)

        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistByID").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        logger.Error("artist not found", zap.Error(err))
                        return nil, artistErrors.ErrArtistNotFound
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get artist by id", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get artist by id: %v", err)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetArtistByID").Observe(duration)

        artistObject.IsFavorite = isFavorite.Valid &amp;&amp; isFavorite.Bool

        return &amp;artistObject, nil</span>
}

func (r *artistPostgresRepository) GetArtistTitleByID(ctx context.Context, id int64) (string, error) <span class="cov3" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artist title by id from db", zap.Int64("id", id), zap.String("query", GetArtistTitleByIDQuery))
        stmt, err := r.db.PrepareContext(ctx, GetArtistTitleByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistTitleByID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return "", artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="2">row := stmt.QueryRowContext(ctx, id)

        var title string
        err = row.Scan(&amp;title)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistTitleByID").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        logger.Error("artist not found", zap.Error(err))
                        return "", artistErrors.ErrArtistNotFound
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get artist title by id", zap.Error(err))
                return "", artistErrors.NewInternalError("failed to get artist title by id: %v", err)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetArtistTitleByID").Observe(duration)
        return title, nil</span>
}

func (r *artistPostgresRepository) GetArtistsByTrackID(ctx context.Context, id int64) ([]*repoModel.ArtistWithRole, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artists by track id from db", zap.Int64("id", id), zap.String("query", GetArtistsByTrackIDQuery))
        stmt, err := r.db.PrepareContext(ctx, GetArtistsByTrackIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByTrackID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByTrackID").Inc()
                logger.Error("failed to get artists by track id", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get artists by track id: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">artists := make([]*repoModel.ArtistWithRole, 0)
        for rows.Next() </span><span class="cov3" title="2">{
                var artist repoModel.ArtistWithRole
                err := rows.Scan(&amp;artist.ID, &amp;artist.Title, &amp;artist.Role)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByTrackID").Inc()
                        logger.Error("failed to scan artist", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan artist: %v", err)
                }</span>
                <span class="cov3" title="2">artists = append(artists, &amp;artist)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetArtistsByTrackID").Observe(duration)
        return artists, nil</span>
}

func (r *artistPostgresRepository) GetArtistsByTrackIDs(ctx context.Context, trackIDs []int64) (map[int64][]*repoModel.ArtistWithRole, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artists by track ids from db", zap.Any("ids", trackIDs), zap.String("query", GetArtistsByTrackIDsQuery))
        stmt, err := r.db.PrepareContext(ctx, GetArtistsByTrackIDsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByTrackIDs").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, pq.Array(trackIDs))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByTrackIDs").Inc()
                logger.Error("failed to get artists by track ids", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get artists by track ids: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">artists := make(map[int64][]*repoModel.ArtistWithRole)
        for rows.Next() </span><span class="cov4" title="3">{
                var artist repoModel.ArtistWithRole
                var id int64
                err := rows.Scan(&amp;artist.ID, &amp;artist.Title, &amp;artist.Role, &amp;id)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByTrackIDs").Inc()
                        logger.Error("failed to scan artist", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan artist: %v", err)
                }</span>
                <span class="cov4" title="3">artists[id] = append(artists[id], &amp;artist)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetArtistsByTrackIDs").Observe(duration)
        return artists, nil</span>
}

func (r *artistPostgresRepository) GetArtistStats(ctx context.Context, id int64) (*repoModel.ArtistStats, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artist stats by id from db", zap.Int64("id", id), zap.String("query", GetArtistStatsQuery))
        stmt, err := r.db.PrepareContext(ctx, GetArtistStatsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistStats").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov1" title="1">row := stmt.QueryRowContext(ctx, id)

        var stats repoModel.ArtistStats
        err = row.Scan(&amp;stats.ListenersCount, &amp;stats.FavoritesCount)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistStats").Inc()
                logger.Error("failed to get artist stats by id", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get artist stats by id: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetArtistStats").Observe(duration)
        return &amp;stats, nil</span>
}

func (r *artistPostgresRepository) GetArtistsByAlbumID(ctx context.Context, albumID int64) ([]*repoModel.ArtistWithTitle, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artists by album id from db", zap.Int64("id", albumID), zap.String("query", GetArtistsByAlbumIDQuery))
        stmt, err := r.db.PrepareContext(ctx, GetArtistsByAlbumIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByAlbumID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, albumID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByAlbumID").Inc()
                logger.Error("failed to get artists by album id", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get artists by album id: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">artists := make([]*repoModel.ArtistWithTitle, 0)
        for rows.Next() </span><span class="cov3" title="2">{
                var artist repoModel.ArtistWithTitle
                err := rows.Scan(&amp;artist.ID, &amp;artist.Title)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByAlbumID").Inc()
                        logger.Error("failed to scan artist", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan artist: %v", err)
                }</span>
                <span class="cov3" title="2">artists = append(artists, &amp;artist)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetArtistsByAlbumID").Observe(duration)
        return artists, nil</span>
}

func (r *artistPostgresRepository) GetArtistsByAlbumIDs(ctx context.Context, albumIDs []int64) (map[int64][]*repoModel.ArtistWithTitle, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artists by album ids from db", zap.Any("ids", albumIDs), zap.String("query", GetArtistsByAlbumIDsQuery))
        stmt, err := r.db.PrepareContext(ctx, GetArtistsByAlbumIDsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByAlbumIDs").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, pq.Array(albumIDs))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByAlbumIDs").Inc()
                logger.Error("failed to get artists by album ids", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get artists by album ids: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">artists := make(map[int64][]*repoModel.ArtistWithTitle)
        for rows.Next() </span><span class="cov4" title="3">{
                var artist repoModel.ArtistWithTitle
                var albumID int64
                err := rows.Scan(&amp;artist.ID, &amp;artist.Title, &amp;albumID)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetArtistsByAlbumIDs").Inc()
                        logger.Error("failed to scan artist", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan artist: %v", err)
                }</span>
                <span class="cov4" title="3">artists[albumID] = append(artists[albumID], &amp;artist)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetArtistsByAlbumIDs").Observe(duration)
        return artists, nil</span>
}

func (r *artistPostgresRepository) GetAlbumIDsByArtistID(ctx context.Context, id int64) ([]int64, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting album ids by artist id from db", zap.Int64("id", id), zap.String("query", GetAlbumIDsByArtistIDQuery))
        stmt, err := r.db.PrepareContext(ctx, GetAlbumIDsByArtistIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumIDsByArtistID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumIDsByArtistID").Inc()
                logger.Error("failed to get album ids by artist id", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get album ids by artist id: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">albumIDs := make([]int64, 0)
        for rows.Next() </span><span class="cov3" title="2">{
                var albumID int64
                err := rows.Scan(&amp;albumID)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetAlbumIDsByArtistID").Inc()
                        logger.Error("failed to scan album id", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan album id: %v", err)
                }</span>
                <span class="cov3" title="2">albumIDs = append(albumIDs, albumID)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAlbumIDsByArtistID").Observe(duration)
        return albumIDs, nil</span>
}

func (r *artistPostgresRepository) GetTrackIDsByArtistID(ctx context.Context, id int64) ([]int64, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting track ids by artist id from db", zap.Int64("id", id), zap.String("query", GetTrackIDsByArtistID))
        stmt, err := r.db.PrepareContext(ctx, GetTrackIDsByArtistID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTrackIDsByArtistID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTrackIDsByArtistID").Inc()
                logger.Error("failed to get track ids by artist id", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get track ids by artist id: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">trackIDs := make([]int64, 0)
        for rows.Next() </span><span class="cov3" title="2">{
                var trackID int64
                err := rows.Scan(&amp;trackID)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetTrackIDsByArtistID").Inc()
                        logger.Error("failed to scan track id", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan track id: %v", err)
                }</span>
                <span class="cov3" title="2">trackIDs = append(trackIDs, trackID)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetTrackIDsByArtistID").Observe(duration)
        return trackIDs, nil</span>
}

func (r *artistPostgresRepository) CreateStreamsByArtistIDs(ctx context.Context, data *repoModel.ArtistStreamCreateDataList) error <span class="cov3" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Creating streams for artists", zap.Any("data", data))

        if len(data.ArtistIDs) == 0 </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStreamsByArtistIDs").Inc()
                return nil
        }</span>

        <span class="cov1" title="1">tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStreamsByArtistIDs").Inc()
                logger.Error("failed to begin transaction", zap.Error(err))
                return artistErrors.NewInternalError("failed to begin transaction: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := tx.Rollback(); err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to rollback transaction", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">query := `INSERT INTO artist_stream (artist_id, user_id) 
              SELECT unnest($1::bigint[]), $2`

        stmt, err := tx.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStreamsByArtistIDs").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">_, err = stmt.ExecContext(ctx, pq.Array(data.ArtistIDs), data.UserID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStreamsByArtistIDs").Inc()
                logger.Error("failed to create streams for artists", zap.Error(err))
                return artistErrors.NewInternalError("failed to create streams for artists: %v", err)
        }</span>

        <span class="cov1" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStreamsByArtistIDs").Inc()
                logger.Error("failed to commit transaction", zap.Error(err))
                return artistErrors.NewInternalError("failed to commit transaction: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CreateStreamsByArtistIDs").Observe(duration)
        return nil</span>
}

func (r *artistPostgresRepository) GetArtistsListenedByUserID(ctx context.Context, userID int64) (int64, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artists listened by user id from db", zap.Int64("userID", userID), zap.String("query", GetArtistsListenedByUserIDQuery))
        stmt, err := r.db.PrepareContext(ctx, GetArtistsListenedByUserIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsListenedByUserID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return 0, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">row := stmt.QueryRowContext(ctx, userID)

        var artistsListened int64
        err = row.Scan(&amp;artistsListened)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsListenedByUserID").Inc()
                logger.Error("failed to get artists listened by user id", zap.Error(err))
                return 0, artistErrors.NewInternalError("failed to get artists listened by user id: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetArtistsListenedByUserID").Observe(duration)
        return artistsListened, nil</span>
}

func (r *artistPostgresRepository) CheckArtistExists(ctx context.Context, id int64) (bool, error) <span class="cov1" title="1">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking if artist exists", zap.Int64("id", id), zap.String("query", CheckArtistExistsQuery))
        stmt, err := r.db.PrepareContext(ctx, CheckArtistExistsQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return false, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov1" title="1">row := stmt.QueryRowContext(ctx, id)

        var exists bool
        err = row.Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to check if artist exists", zap.Error(err))
                return false, artistErrors.NewInternalError("failed to check if artist exists: %v", err)
        }</span>

        <span class="cov1" title="1">return exists, nil</span>
}

// Мы не проверяем, какое значение было у зафаворченного исполнителя, а просто задаем его новое значение игнорируя предидущее. Такое подход по идее должен избавить нас от лишних проверок и запросов в бд.
func (r *artistPostgresRepository) LikeArtist(ctx context.Context, request *repoModel.LikeRequest) error <span class="cov1" title="1">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting to like artist", zap.Any("request", request), zap.Int64("artistID", request.ArtistID), zap.Int64("userID", request.UserID))
        stmt, err := r.db.PrepareContext(ctx, LikeArtistByUserIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">_, err = stmt.ExecContext(ctx, request.ArtistID, request.UserID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to like artist", zap.Error(err))
                return artistErrors.NewInternalError("failed to like artist: %v", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *artistPostgresRepository) UnlikeArtist(ctx context.Context, request *repoModel.LikeRequest) error <span class="cov1" title="1">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting to unlike artist", zap.Any("request", request), zap.Int64("artistID", request.ArtistID), zap.Int64("userID", request.UserID))
        stmt, err := r.db.PrepareContext(ctx, UnlikeArtistByUserIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">_, err = stmt.ExecContext(ctx, request.ArtistID, request.UserID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to unlike artist", zap.Error(err))
                return artistErrors.NewInternalError("failed to unlike artist: %v", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *artistPostgresRepository) GetFavoriteArtists(ctx context.Context, filters *repoModel.Filters, userID int64) ([]*repoModel.Artist, error) <span class="cov1" title="1">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting favorite artists by user id from db", zap.Int64("userID", userID), zap.String("query", GetFavoriteArtistsQuery))
        stmt, err := r.db.PrepareContext(ctx, GetFavoriteArtistsQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, userID, filters.Pagination.Limit, filters.Pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get favorite artists", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get favorite artists: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">var artists []*repoModel.Artist
        for rows.Next() </span><span class="cov3" title="2">{
                var artist repoModel.Artist
                err := rows.Scan(&amp;artist.ID, &amp;artist.Title, &amp;artist.Description, &amp;artist.Thumbnail)
                // Так как это мы не отображаем в списке, то можно не делать лишнюю проверку
                // В идеале поменяем к рк4
                artist.IsFavorite = false
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to scan artist", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan artist: %v", err)
                }</span>
                <span class="cov3" title="2">artists = append(artists, &amp;artist)</span>
        }

        <span class="cov1" title="1">return artists, nil</span>
}

func (r *artistPostgresRepository) SearchArtists(ctx context.Context, query string, userID int64) ([]*repoModel.Artist, error) <span class="cov1" title="1">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting search artists by query from db", zap.String("query", query), zap.Int64("userID", userID), zap.String("query", SearchArtistsQuery))
        stmt, err := r.db.PrepareContext(ctx, SearchArtistsQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">words := strings.Fields(query)
        for i, word := range words </span><span class="cov3" title="2">{
                words[i] = word + ":*"
        }</span>
        <span class="cov1" title="1">tsQueryString := strings.Join(words, " &amp; ")

        rows, err := stmt.QueryContext(ctx, tsQueryString, userID, query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to search artists", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to search artists: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">var artists []*repoModel.Artist
        for rows.Next() </span><span class="cov3" title="2">{
                var artist repoModel.Artist
                err := rows.Scan(&amp;artist.ID, &amp;artist.Title, &amp;artist.Description, &amp;artist.Thumbnail)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to scan artist", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan artist: %v", err)
                }</span>
                <span class="cov3" title="2">artists = append(artists, &amp;artist)</span>
        }
        <span class="cov1" title="1">return artists, nil</span>
}

func (r *artistPostgresRepository) CreateArtist(ctx context.Context, artist *repoModel.Artist) (*repoModel.Artist, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Creating artist", zap.Any("artist", artist))
        stmt, err := r.db.PrepareContext(ctx, CreateArtistQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                r.metrics.DatabaseErrors.WithLabelValues("CreateArtist").Inc()
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">var artistID int64
        err = stmt.QueryRowContext(ctx, artist.Title, artist.Thumbnail, artist.LabelID).Scan(&amp;artistID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create artist", zap.Error(err))
                r.metrics.DatabaseErrors.WithLabelValues("CreateArtist").Inc()
                return nil, artistErrors.NewInternalError("failed to create artist: %v", err)
        }</span>
        <span class="cov0" title="0">artist.ID = artistID
        duration := time.Since(start).Seconds()

        _, err = r.db.ExecContext(ctx, "REFRESH MATERIALIZED VIEW CONCURRENTLY artist_stats")
    if err != nil </span><span class="cov0" title="0">{
        logger.Warn("failed to refresh artist_stats view, artist may not be visible for up to 1 minute", zap.Error(err))
    }</span>

        <span class="cov0" title="0">r.metrics.DatabaseDuration.WithLabelValues("CreateArtist").Observe(duration)
        return artist, nil</span>
}

func (r *artistPostgresRepository) CheckArtistNameExist(ctx context.Context, id int64) (bool, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking if artist name exists", zap.Int64("id", id))
        stmt, err := r.db.PrepareContext(ctx, CheckArtistNameExist)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return false, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">var exists bool
        err = stmt.QueryRowContext(ctx, id).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to check if artist name exists", zap.Error(err))
                return false, artistErrors.NewInternalError("failed to check if artist name exists: %v", err)</span>
        }

        <span class="cov0" title="0">return exists, nil</span>
}

func (r *artistPostgresRepository) ChangeArtistTitle(ctx context.Context, newTitle string, id int64) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Changing artist title", zap.Int64("id", id))
        stmt, err := r.db.PrepareContext(ctx, UpdateArtistNameQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = stmt.ExecContext(ctx, newTitle, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to change artist title", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *artistPostgresRepository) GetArtistByIDWithoutUser(ctx context.Context, id int64) (*repoModel.Artist, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artist by id from db", zap.Int64("id", id))
        stmt, err := r.db.PrepareContext(ctx, GetArtistByIdWithoutUserQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">row := stmt.QueryRowContext(ctx, id)

        var artistObject repoModel.Artist
        err = row.Scan(&amp;artistObject.ID, &amp;artistObject.Title, &amp;artistObject.Description, &amp;artistObject.Thumbnail)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Error("artist not found", zap.Error(err))
                        return nil, artistErrors.ErrArtistNotFound
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get artist by title", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get artist by title: %v", err)</span>
        }

        <span class="cov0" title="0">return &amp;artistObject, nil</span>
}

func (r *artistPostgresRepository) UploadAvatar(ctx context.Context, artistID int64, avatarURL string) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Uploading artist avatar", zap.Int64("artistID", artistID), zap.String("avatarURL", avatarURL))
        stmt, err := r.db.PrepareContext(ctx, UpdateArtistAvatarQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = stmt.ExecContext(ctx, avatarURL, artistID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to upload artist avatar", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *artistPostgresRepository) GetArtistLabelID(ctx context.Context, artistID int64) (int64, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting artist label id by id from db", zap.Int64("artistID", artistID))
        stmt, err := r.db.PrepareContext(ctx, GetArtistLabelIdByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to prepare statement", zap.Error(err))
                return 0, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">row := stmt.QueryRowContext(ctx, artistID)

        var labelID int64
        err = row.Scan(&amp;labelID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Error("artist not found", zap.Error(err))
                        return 0, artistErrors.ErrArtistNotFound
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get artist label id by title", zap.Error(err))
                return 0, artistErrors.NewInternalError("failed to get artist label id by title: %v", err)</span>
        }

        <span class="cov0" title="0">return labelID, nil</span>
}

func (r *artistPostgresRepository) GetArtistsLabelID(ctx context.Context, filters *repoModel.Filters, labelID int64) ([]*repoModel.Artist, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting all artists with filters from db", zap.Any("filters", filters), zap.String("query", GetAllArtistsQuery))
        stmt, err := r.db.PrepareContext(ctx, GetArtistsLabelIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsLabelID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">rows, err := stmt.QueryContext(ctx, filters.Pagination.Limit, filters.Pagination.Offset, labelID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetArtistsLabelID").Inc()
                logger.Error("failed to get all artists", zap.Error(err))
                return nil, artistErrors.NewInternalError("failed to get all artists: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close rows", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">artists := make([]*repoModel.Artist, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var artist repoModel.Artist
                var isFavorite sql.NullBool
                err = rows.Scan(&amp;artist.ID, &amp;artist.Title, &amp;artist.Description, &amp;artist.Thumbnail, &amp;isFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetArtistsLabelID").Inc()
                        logger.Error("failed to scan artist", zap.Error(err))
                        return nil, artistErrors.NewInternalError("failed to scan artist: %v", err)
                }</span>
                <span class="cov0" title="0">artist.IsFavorite = isFavorite.Valid &amp;&amp; isFavorite.Bool
                artists = append(artists, &amp;artist)</span>
        }
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetArtistsLabelID").Observe(duration)
        return artists, nil</span>
}

func (r *artistPostgresRepository) DeleteArtist(ctx context.Context, artistID int64) error <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("deleting user", zap.Int64("artist id", artistID))

        stmt, err := r.db.PrepareContext(ctx, DeleteArtistQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteArtist").Inc()
                logger.Error("failed to delete artist", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = stmt.ExecContext(ctx, artistID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteArtist").Inc()
                logger.Error("failed to delete artist", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("DeleteArtist").Observe(duration)
        return nil</span>
}

func (r *artistPostgresRepository) AddArtistsToAlbum(ctx context.Context, artistsIDs []int64, albumID int64) error <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Adding artists to album", zap.Any("artistsIds", artistsIDs), zap.Int64("albumID", albumID))

        if len(artistsIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stmt, err := r.db.PrepareContext(ctx, AddArtistsToAlbum)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("AddArtistsToAlbum").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = stmt.ExecContext(ctx, pq.Array(artistsIDs), albumID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("AddArtistsToAlbum").Inc()
                logger.Error("failed to add artists to album", zap.Error(err))
                return artistErrors.NewInternalError("failed to add artists to album: %v", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("AddArtistsToAlbum").Observe(duration)
        return nil</span>
}

func (r *artistPostgresRepository) AddArtistsToTracks(ctx context.Context, artistsIDs []int64, trackIDs []int64) error <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Adding artists to tracks", zap.Any("artistsIds", artistsIDs), zap.Any("trackIDs", trackIDs))

        if len(artistsIDs) == 0 || len(trackIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stmt, err := r.db.PrepareContext(ctx, AddArtistsToTracks)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("AddArtistsToTracks").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return artistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to close statement", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = stmt.ExecContext(ctx, pq.Array(artistsIDs), pq.Array(trackIDs))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("AddArtistsToTracks").Inc()
                logger.Error("failed to add artists to tracks", zap.Error(err))
                return artistErrors.NewInternalError("failed to add artists to tracks: %v", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("AddArtistsToTracks").Observe(duration)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package repository

import (
        "bytes"
        "context"
        "fmt"
        "time"

        "image"

        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/domain"
        artistErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model/errors"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "go.uber.org/zap"
)

type artistS3Repository struct {
        s3         *s3.S3
        uploader   *s3manager.Uploader
        bucketName string
        metrics    *metrics.Metrics
}

func NewS3Repository(s3 *s3.S3, bucketName string, metrics *metrics.Metrics) domain.S3Repository <span class="cov0" title="0">{
        uploader := s3manager.NewUploaderWithClient(s3)
        return &amp;artistS3Repository{
                s3:         s3,
                bucketName: bucketName,
                uploader:   uploader,
                metrics:    metrics,
        }
}</span>

func (r *artistS3Repository) GetAvatarURL(ctx context.Context, fileKey string) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        if fileKey == "" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAvatarURL").Inc()
                logger.Error("fileKey is empty")
                return "", artistErrors.NewEmptyS3KeyError("fileKey is empty")
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAvatarURL").Observe(duration)
        return fmt.Sprintf(
                "https://%s.fra1.digitaloceanspaces.com/artists%s",
                r.bucketName,
                fileKey,
        ), nil</span>
}

func (r *artistS3Repository) UploadArtistAvatar(ctx context.Context, artistTitle string, file []byte) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        date := time.Now()
        dateString := date.Format("20060102150405")

        _, format, err := image.Decode(bytes.NewReader(file))
        logger.Info("format", zap.String("format", format))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadArtistAvatar").Inc()
                logger.Error("unsupported or invalid image format", zap.Error(err))
                return "", artistErrors.NewUnsupportedImageFormatError("unsupported or invalid image format")
        }</span>

        <span class="cov0" title="0">if format != "jpeg" &amp;&amp; format != "png" &amp;&amp; format != "gif" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadArtistAvatar").Inc()
                logger.Error("unsupported image format", zap.String("format", format))
                return "", artistErrors.NewUnsupportedImageFormatError("unsupported or invalid image format")
        }</span>

        // webpBuf := new(bytes.Buffer)
        // if err := webp.Encode(webpBuf, img, &amp;webp.Options{Lossless: true}); err != nil {
        //         logger.Error("failed to encode webp", zap.Error(err))
        //         return "", userAvatarFile.ErrFailedToEncodeWebp
        // }

        <span class="cov0" title="0">fileKey := fmt.Sprintf("/%s-%s.%s", artistTitle, dateString, format)
        s3Key := fmt.Sprintf("artists%s", fileKey)

        _, err = r.uploader.UploadWithContext(ctx, &amp;s3manager.UploadInput{
                Bucket:      aws.String(r.bucketName),
                Key:         aws.String(s3Key),
                Body:        bytes.NewReader(file),
                ContentType: aws.String("image/" + format),
                ACL:         aws.String("public-read"),
        })

        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadArtistAvatar").Inc()
                logger.Error("upload failed", zap.Error(err))
                return "", artistErrors.NewFailedToUploadAvatarError("failed to upload avatar")
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UploadArtistAvatar").Observe(duration)

        return fmt.Sprintf("https://%s.fra1.digitaloceanspaces.com/artists%s", r.bucketName, fileKey), nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package usecase

import (
        "context"

        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model"
        artistErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model/errors"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model/usecase"
)

func NewArtistUsecase(artistRepository domain.Repository, s3Repo domain.S3Repository) domain.Usecase <span class="cov0" title="0">{
        return &amp;artistUsecase{
                artistRepo: artistRepository,
                s3Repo:     s3Repo,
        }
}</span>

type artistUsecase struct {
        artistRepo domain.Repository
        s3Repo     domain.S3Repository
}

func (u *artistUsecase) GetArtistByID(ctx context.Context, id int64, userID int64) (*usecaseModel.ArtistDetailed, error) <span class="cov0" title="0">{
        repoArtist, err := u.artistRepo.GetArtistByID(ctx, id, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats, err := u.artistRepo.GetArtistStats(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return model.ArtistDetailedFromRepositoryToUsecase(repoArtist, stats), nil</span>
}

func (u *artistUsecase) GetAllArtists(ctx context.Context, filters *usecaseModel.Filters, userID int64) (*usecaseModel.ArtistList, error) <span class="cov0" title="0">{
        repoFilters := model.ArtistFiltersFromUsecaseToRepository(filters)
        repoArtists, err := u.artistRepo.GetAllArtists(ctx, repoFilters, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistListFromRepositoryToUsecase(repoArtists), nil</span>
}

func (u *artistUsecase) GetArtistTitleByID(ctx context.Context, id int64) (string, error) <span class="cov0" title="0">{
        repoTitle, err := u.artistRepo.GetArtistTitleByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return repoTitle, nil</span>
}

func (u *artistUsecase) GetArtistsByTrackID(ctx context.Context, id int64) (*usecaseModel.ArtistWithRoleList, error) <span class="cov0" title="0">{
        repoArtists, err := u.artistRepo.GetArtistsByTrackID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistWithRoleListFromRepositoryToUsecase(repoArtists), nil</span>
}

func (u *artistUsecase) GetArtistsByTrackIDs(ctx context.Context, ids []int64) (*usecaseModel.ArtistWithRoleMap, error) <span class="cov0" title="0">{
        repoArtists, err := u.artistRepo.GetArtistsByTrackIDs(ctx, ids)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistWithRoleMapFromRepositoryToUsecase(repoArtists), nil</span>
}

func (u *artistUsecase) GetArtistsByAlbumID(ctx context.Context, id int64) (*usecaseModel.ArtistWithTitleList, error) <span class="cov0" title="0">{
        repoArtists, err := u.artistRepo.GetArtistsByAlbumID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistWithTitleListFromRepositoryToUsecase(repoArtists), nil</span>
}

func (u *artistUsecase) GetArtistsByAlbumIDs(ctx context.Context, ids []int64) (*usecaseModel.ArtistWithTitleMap, error) <span class="cov0" title="0">{
        repoArtists, err := u.artistRepo.GetArtistsByAlbumIDs(ctx, ids)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistWithTitleMapFromRepositoryToUsecase(repoArtists), nil</span>
}

func (u *artistUsecase) GetAlbumIDsByArtistID(ctx context.Context, id int64) ([]int64, error) <span class="cov0" title="0">{
        repoAlbumIDs, err := u.artistRepo.GetAlbumIDsByArtistID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return repoAlbumIDs, nil</span>
}

func (u *artistUsecase) GetTrackIDsByArtistID(ctx context.Context, id int64) ([]int64, error) <span class="cov0" title="0">{
        repoTrackIDs, err := u.artistRepo.GetTrackIDsByArtistID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return repoTrackIDs, nil</span>
}

func (u *artistUsecase) CreateStreamsByArtistIDs(ctx context.Context, data *usecaseModel.ArtistStreamCreateDataList) error <span class="cov0" title="0">{
        repoData := model.ArtistStreamCreateDataFromUsecaseToRepository(data)
        err := u.artistRepo.CreateStreamsByArtistIDs(ctx, repoData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *artistUsecase) GetArtistsListenedByUserID(ctx context.Context, userID int64) (int64, error) <span class="cov0" title="0">{
        repoArtistsListened, err := u.artistRepo.GetArtistsListenedByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return repoArtistsListened, nil</span>
}

func (u *artistUsecase) LikeArtist(ctx context.Context, request *usecaseModel.LikeRequest) error <span class="cov0" title="0">{
        repoRequest := model.LikeRequestFromUsecaseToRepository(request)

        exists, err := u.artistRepo.CheckArtistExists(ctx, request.ArtistID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return artistErrors.NewNotFoundError("artist not found")
        }</span>
        <span class="cov0" title="0">if request.IsLike </span><span class="cov0" title="0">{
                err := u.artistRepo.LikeArtist(ctx, repoRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">err = u.artistRepo.UnlikeArtist(ctx, repoRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *artistUsecase) GetFavoriteArtists(ctx context.Context, filters *usecaseModel.Filters, userID int64) (*usecaseModel.ArtistList, error) <span class="cov0" title="0">{
        repoFilters := model.ArtistFiltersFromUsecaseToRepository(filters)
        repoArtists, err := u.artistRepo.GetFavoriteArtists(ctx, repoFilters, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistListFromRepositoryToUsecase(repoArtists), nil</span>
}

func (u *artistUsecase) SearchArtists(ctx context.Context, query string, userID int64) (*usecaseModel.ArtistList, error) <span class="cov0" title="0">{
        repoArtists, err := u.artistRepo.SearchArtists(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistListFromRepositoryToUsecase(repoArtists), nil</span>
}

func (u *artistUsecase) CreateArtist(ctx context.Context, artist *usecaseModel.ArtistLoad) (*usecaseModel.Artist, error) <span class="cov0" title="0">{
        artistLoad := model.ArtistLoadFromUsecaseToRepository(artist)
        avatarURL, err := u.s3Repo.UploadArtistAvatar(ctx, artistLoad.Title, artist.Image)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">artistLoad.Thumbnail = avatarURL
        createdArtist, err := u.artistRepo.CreateArtist(ctx, artistLoad)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">createdArtistUsecase := model.ArtistFromRepositoryToUsecase(createdArtist)
        return createdArtistUsecase, nil</span>
}

func (u *artistUsecase) UploadAvatar(ctx context.Context, artistID int64, avatar string) error <span class="cov0" title="0">{
        err := u.artistRepo.UploadAvatar(ctx, artistID, avatar)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *artistUsecase) EditArtist(ctx context.Context, artist *usecaseModel.ArtistEdit) (*usecaseModel.Artist, error) <span class="cov0" title="0">{
        artistLabelID, err := u.artistRepo.GetArtistLabelID(ctx, artist.ArtistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if artist.LabelID != artistLabelID </span><span class="cov0" title="0">{
                return nil, artistErrors.NewForbiddenError("you are not allowed to edit this artist")
        }</span>
        <span class="cov0" title="0">artistName, err := u.artistRepo.GetArtistTitleByID(ctx, artist.ArtistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">artistEdit := model.ArtistEditFromUsecaseToRepository(artist)
        var artistTitle string
        if artistEdit.NewTitle != "" </span><span class="cov0" title="0">{
                isArtistExist, err := u.artistRepo.CheckArtistNameExist(ctx, artist.ArtistID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !isArtistExist </span><span class="cov0" title="0">{
                        return nil, artistErrors.NewNotFoundError("artist not found")
                }</span>
                <span class="cov0" title="0">err = u.artistRepo.ChangeArtistTitle(ctx, artistEdit.NewTitle, artist.ArtistID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">artistTitle = artistEdit.NewTitle</span>
        } else<span class="cov0" title="0"> {
                artistTitle = artistName
        }</span>
        <span class="cov0" title="0">if artist.Image != nil </span><span class="cov0" title="0">{
                avatarURL, err := u.s3Repo.UploadArtistAvatar(ctx, artistTitle, artist.Image)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">err = u.UploadAvatar(ctx, artist.ArtistID, avatarURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">artistRepo, err := u.artistRepo.GetArtistByIDWithoutUser(ctx, artist.ArtistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">artistUsecase := model.ArtistFromRepositoryToUsecase(artistRepo)
        artistUsecase.LabelID = artist.LabelID
        return artistUsecase, nil</span>
}

func (u *artistUsecase) GetArtistsLabelID(ctx context.Context, filters *usecaseModel.Filters, labelID int64) (*usecaseModel.ArtistList, error) <span class="cov0" title="0">{
        repoFilters := model.ArtistFiltersFromUsecaseToRepository(filters)
        repoArtists, err := u.artistRepo.GetArtistsLabelID(ctx, repoFilters, labelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.ArtistListFromRepositoryToUsecase(repoArtists), nil</span>
}

func (u *artistUsecase) DeleteArtist(ctx context.Context, artist *usecaseModel.ArtistDelete) error <span class="cov0" title="0">{
        artistLabelID, err := u.artistRepo.GetArtistLabelID(ctx, artist.ArtistID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if artist.LabelID != artistLabelID </span><span class="cov0" title="0">{
                return artistErrors.NewForbiddenError("you are not allowed to edit this artist")
        }</span>
        <span class="cov0" title="0">err = u.artistRepo.DeleteArtist(ctx, artist.ArtistID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *artistUsecase) ConnectArtists(ctx context.Context, artistIDs []int64, albumID int64, trackIDs []int64) error <span class="cov0" title="0">{
        err := u.artistRepo.AddArtistsToAlbum(ctx, artistIDs, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = u.artistRepo.AddArtistsToTracks(ctx, artistIDs, trackIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package model

import (
        protoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/artist"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model/repository"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/artist/model/usecase"
)

func ArtistFromRepositoryToUsecase(artist *repoModel.Artist) *usecaseModel.Artist <span class="cov7" title="4">{
        return &amp;usecaseModel.Artist{
                ID:          artist.ID,
                Title:       artist.Title,
                Description: artist.Description,
                Thumbnail:   artist.Thumbnail,
                IsFavorite:  artist.IsFavorite,
        }
}</span>

func ArtistFromUsecaseToProto(artist *usecaseModel.Artist) *protoModel.Artist <span class="cov7" title="4">{
        return &amp;protoModel.Artist{
                Id:          artist.ID,
                Title:       artist.Title,
                Description: artist.Description,
                Thumbnail:   artist.Thumbnail,
                IsFavorite:  artist.IsFavorite,
        }
}</span>

func ArtistDetailedFromRepositoryToUsecase(artist *repoModel.Artist, stats *repoModel.ArtistStats) *usecaseModel.ArtistDetailed <span class="cov1" title="1">{
        return &amp;usecaseModel.ArtistDetailed{
                Artist:         ArtistFromRepositoryToUsecase(artist),
                ListenersCount: stats.ListenersCount,
                FavoritesCount: stats.FavoritesCount,
        }
}</span>

func ArtistDetailedFromUsecaseToProto(artist *usecaseModel.ArtistDetailed) *protoModel.ArtistDetailed <span class="cov1" title="1">{
        return &amp;protoModel.ArtistDetailed{
                Artist:         ArtistFromUsecaseToProto(artist.Artist),
                ListenersCount: artist.ListenersCount,
                FavoritesCount: artist.FavoritesCount,
        }
}</span>

func ArtistListFromRepositoryToUsecase(artists []*repoModel.Artist) *usecaseModel.ArtistList <span class="cov1" title="1">{
        usecaseArtists := make([]*usecaseModel.Artist, len(artists))
        for i, artist := range artists </span><span class="cov4" title="2">{
                usecaseArtists[i] = ArtistFromRepositoryToUsecase(artist)
        }</span>
        <span class="cov1" title="1">return &amp;usecaseModel.ArtistList{
                Artists: usecaseArtists,
        }</span>
}

func ArtistListFromUsecaseToProto(artists *usecaseModel.ArtistList) *protoModel.ArtistList <span class="cov1" title="1">{
        protoArtists := make([]*protoModel.Artist, len(artists.Artists))
        for i, artist := range artists.Artists </span><span class="cov4" title="2">{
                protoArtists[i] = ArtistFromUsecaseToProto(artist)
        }</span>
        <span class="cov1" title="1">return &amp;protoModel.ArtistList{
                Artists: protoArtists,
        }</span>
}

func ArtistWithTitleFromRepositoryToUsecase(artist *repoModel.ArtistWithTitle) *usecaseModel.ArtistWithTitle <span class="cov10" title="6">{
        return &amp;usecaseModel.ArtistWithTitle{
                ID:    artist.ID,
                Title: artist.Title,
        }
}</span>

func ArtistWithTitleFromUsecaseToProto(artist *usecaseModel.ArtistWithTitle) *protoModel.ArtistWithTitle <span class="cov10" title="6">{
        return &amp;protoModel.ArtistWithTitle{
                Id:    artist.ID,
                Title: artist.Title,
        }
}</span>

func ArtistWithTitleListFromUsecaseToProto(artists *usecaseModel.ArtistWithTitleList) *protoModel.ArtistWithTitleList <span class="cov6" title="3">{
        protoArtists := make([]*protoModel.ArtistWithTitle, len(artists.Artists))
        for i, artist := range artists.Artists </span><span class="cov9" title="5">{
                protoArtists[i] = ArtistWithTitleFromUsecaseToProto(artist)
        }</span>
        <span class="cov6" title="3">return &amp;protoModel.ArtistWithTitleList{
                Artists: protoArtists,
        }</span>
}

func ArtistWithTitleListFromRepositoryToUsecase(artists []*repoModel.ArtistWithTitle) *usecaseModel.ArtistWithTitleList <span class="cov6" title="3">{
        usecaseArtists := make([]*usecaseModel.ArtistWithTitle, len(artists))
        for i, artist := range artists </span><span class="cov9" title="5">{
                usecaseArtists[i] = ArtistWithTitleFromRepositoryToUsecase(artist)
        }</span>
        <span class="cov6" title="3">return &amp;usecaseModel.ArtistWithTitleList{
                Artists: usecaseArtists,
        }</span>
}

func ArtistWithTitleMapFromRepositoryToUsecase(artists map[int64][]*repoModel.ArtistWithTitle) *usecaseModel.ArtistWithTitleMap <span class="cov1" title="1">{
        usecaseArtists := make(map[int64]*usecaseModel.ArtistWithTitleList)
        for id, artist := range artists </span><span class="cov4" title="2">{
                usecaseArtists[id] = ArtistWithTitleListFromRepositoryToUsecase(artist)
        }</span>
        <span class="cov1" title="1">return &amp;usecaseModel.ArtistWithTitleMap{
                Artists: usecaseArtists,
        }</span>
}

func ArtistWithTitleMapFromUsecaseToProto(artists *usecaseModel.ArtistWithTitleMap) *protoModel.ArtistWithTitleMap <span class="cov1" title="1">{
        protoArtists := make(map[int64]*protoModel.ArtistWithTitleList)
        for id, artist := range artists.Artists </span><span class="cov4" title="2">{
                protoArtists[id] = ArtistWithTitleListFromUsecaseToProto(artist)
        }</span>
        <span class="cov1" title="1">return &amp;protoModel.ArtistWithTitleMap{
                Artists: protoArtists,
        }</span>
}

func ArtistWithRoleFromRepositoryToUsecase(artist *repoModel.ArtistWithRole) *usecaseModel.ArtistWithRole <span class="cov10" title="6">{
        return &amp;usecaseModel.ArtistWithRole{
                ID:    artist.ID,
                Title: artist.Title,
                Role:  artist.Role,
        }
}</span>

func ArtistWithRoleFromUsecaseToProto(artist *usecaseModel.ArtistWithRole) *protoModel.ArtistWithRole <span class="cov10" title="6">{
        return &amp;protoModel.ArtistWithRole{
                Id:    artist.ID,
                Title: artist.Title,
                Role:  artist.Role,
        }
}</span>

func ArtistWithRoleListFromUsecaseToProto(artists *usecaseModel.ArtistWithRoleList) *protoModel.ArtistWithRoleList <span class="cov6" title="3">{
        protoArtists := make([]*protoModel.ArtistWithRole, len(artists.Artists))
        for i, artist := range artists.Artists </span><span class="cov9" title="5">{
                protoArtists[i] = ArtistWithRoleFromUsecaseToProto(artist)
        }</span>
        <span class="cov6" title="3">return &amp;protoModel.ArtistWithRoleList{
                Artists: protoArtists,
        }</span>
}

func ArtistWithRoleMapFromRepositoryToUsecase(artists map[int64][]*repoModel.ArtistWithRole) *usecaseModel.ArtistWithRoleMap <span class="cov1" title="1">{
        usecaseArtists := make(map[int64]*usecaseModel.ArtistWithRoleList)
        for id, artist := range artists </span><span class="cov4" title="2">{
                usecaseArtists[id] = ArtistWithRoleListFromRepositoryToUsecase(artist)
        }</span>
        <span class="cov1" title="1">return &amp;usecaseModel.ArtistWithRoleMap{
                Artists: usecaseArtists,
        }</span>
}

func ArtistWithRoleMapFromUsecaseToProto(artists *usecaseModel.ArtistWithRoleMap) *protoModel.ArtistWithRoleMap <span class="cov1" title="1">{
        protoArtists := make(map[int64]*protoModel.ArtistWithRoleList)
        for id, artist := range artists.Artists </span><span class="cov4" title="2">{
                protoArtists[id] = ArtistWithRoleListFromUsecaseToProto(artist)
        }</span>
        <span class="cov1" title="1">return &amp;protoModel.ArtistWithRoleMap{
                Artists: protoArtists,
        }</span>
}
func ArtistWithRoleListFromRepositoryToUsecase(artists []*repoModel.ArtistWithRole) *usecaseModel.ArtistWithRoleList <span class="cov6" title="3">{
        usecaseArtists := make([]*usecaseModel.ArtistWithRole, len(artists))
        for i, artist := range artists </span><span class="cov9" title="5">{
                usecaseArtists[i] = ArtistWithRoleFromRepositoryToUsecase(artist)
        }</span>
        <span class="cov6" title="3">return &amp;usecaseModel.ArtistWithRoleList{
                Artists: usecaseArtists,
        }</span>
}

func PaginationFromUsecaseToRepository(pagination *usecaseModel.Pagination) *repoModel.Pagination <span class="cov4" title="2">{
        return &amp;repoModel.Pagination{
                Offset: pagination.Offset,
                Limit:  pagination.Limit,
        }
}</span>

func ArtistFiltersFromUsecaseToRepository(filters *usecaseModel.Filters) *repoModel.Filters <span class="cov1" title="1">{
        return &amp;repoModel.Filters{
                Pagination: PaginationFromUsecaseToRepository(filters.Pagination),
        }
}</span>

func TrackIDListFromProtoToUsecase(ids []*protoModel.TrackID) []int64 <span class="cov1" title="1">{
        trackIDs := make([]int64, len(ids))
        for i, id := range ids </span><span class="cov6" title="3">{
                trackIDs[i] = id.Id
        }</span>
        <span class="cov1" title="1">return trackIDs</span>
}

func AlbumIDListFromProtoToUsecase(ids []*protoModel.AlbumID) []int64 <span class="cov1" title="1">{
        albumIDs := make([]int64, len(ids))
        for i, id := range ids </span><span class="cov6" title="3">{
                albumIDs[i] = id.Id
        }</span>
        <span class="cov1" title="1">return albumIDs</span>
}

func PaginationFromProtoToUsecase(pagination *protoModel.Pagination) *usecaseModel.Pagination <span class="cov4" title="2">{
        return &amp;usecaseModel.Pagination{
                Offset: pagination.Offset,
                Limit:  pagination.Limit,
        }
}</span>

func ArtistFiltersFromProtoToUsecase(filters *protoModel.Filters) *usecaseModel.Filters <span class="cov1" title="1">{
        return &amp;usecaseModel.Filters{
                Pagination: PaginationFromProtoToUsecase(filters.Pagination),
        }
}</span>

func ArtistStreamCreateDataFromProtoToUsecase(data *protoModel.ArtistStreamCreateDataList) *usecaseModel.ArtistStreamCreateDataList <span class="cov1" title="1">{
        artistIDs := make([]int64, len(data.ArtistIds.Ids))
        for i, id := range data.ArtistIds.Ids </span><span class="cov4" title="2">{
                artistIDs[i] = id.Id
        }</span>
        <span class="cov1" title="1">return &amp;usecaseModel.ArtistStreamCreateDataList{
                ArtistIDs: artistIDs,
                UserID:    data.UserId.Id,
        }</span>
}

func ArtistStreamCreateDataFromUsecaseToRepository(data *usecaseModel.ArtistStreamCreateDataList) *repoModel.ArtistStreamCreateDataList <span class="cov1" title="1">{
        return &amp;repoModel.ArtistStreamCreateDataList{
                ArtistIDs: data.ArtistIDs,
                UserID:    data.UserID,
        }
}</span>

func LikeRequestFromProtoToUsecase(request *protoModel.LikeRequest) *usecaseModel.LikeRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.LikeRequest{
                ArtistID: request.ArtistId.Id,
                UserID:   request.UserId.Id,
                IsLike:   request.IsLike,
        }
}</span>

func LikeRequestFromUsecaseToRepository(request *usecaseModel.LikeRequest) *repoModel.LikeRequest <span class="cov1" title="1">{
        return &amp;repoModel.LikeRequest{
                ArtistID: request.ArtistID,
                UserID:   request.UserID,
        }
}</span>

func ArtistLoadFromUsecaseToRepository(artist *usecaseModel.ArtistLoad) *repoModel.Artist <span class="cov0" title="0">{
        return &amp;repoModel.Artist{
                Title:   artist.Title,
                LabelID: artist.LabelID,
        }
}</span>

func ArtistLoadFromProtoToUsecase(artist *protoModel.ArtistLoad) *usecaseModel.ArtistLoad <span class="cov0" title="0">{
        return &amp;usecaseModel.ArtistLoad{
                Title:   artist.Title,
                Image:   artist.Image,
                LabelID: artist.LabelId,
        }
}</span>

func ArtistEditFromProtoToUsecase(artist *protoModel.ArtistEdit) *usecaseModel.ArtistEdit <span class="cov0" title="0">{
        return &amp;usecaseModel.ArtistEdit{
                ArtistID: artist.ArtistId,
                NewTitle: artist.NewTitle,
                Image:    artist.Image,
                LabelID:  artist.LabelId,
        }
}</span>
func ArtistEditFromUsecaseToRepository(artist *usecaseModel.ArtistEdit) *repoModel.ArtistEdit <span class="cov0" title="0">{
        return &amp;repoModel.ArtistEdit{
                ArtistID: artist.ArtistID,
                NewTitle: artist.NewTitle,
                Image:    artist.Image,
                LabelID:  artist.LabelID,
        }
}</span>

func ArtistDeleteFromProtoToUsecase(artist *protoModel.ArtistDelete) *usecaseModel.ArtistDelete <span class="cov0" title="0">{
        return &amp;usecaseModel.ArtistDelete{
                ArtistID: artist.ArtistId,
                LabelID:  artist.LabelId,
        }
}</span>

func ArtistsIDWithAlbumIDFromProtoToUsecase(artists *protoModel.ArtistsIDWithAlbumID) ([]int64, int64, []int64) <span class="cov0" title="0">{
        var artistIDs []int64
        for _, id := range artists.ArtistIds.Ids </span><span class="cov0" title="0">{
                artistIDs = append(artistIDs, id.Id)
        }</span>
        <span class="cov0" title="0">var tracksIDs []int64
        for _, id := range artists.TrackIds.Ids </span><span class="cov0" title="0">{
                tracksIDs = append(tracksIDs, id.Id)
        }</span>
        <span class="cov0" title="0">return artistIDs, artists.AlbumId.Id, tracksIDs</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package errors

import (
        "fmt"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type ArtistError struct {
        Code    codes.Code
        Message string
}

func (e *ArtistError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func (e *ArtistError) GRPCStatus() *status.Status <span class="cov0" title="0">{
        return status.New(e.Code, e.Message)
}</span>

func NewNotFoundError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;ArtistError{
                Code:    codes.NotFound,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewInternalError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;ArtistError{
                Code:    codes.Internal,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewBadRequestError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;ArtistError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewEmptyS3KeyError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;ArtistError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewUnsupportedImageFormatError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;ArtistError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewFailedToUploadAvatarError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;ArtistError{
                Code:    codes.Internal,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewConflictError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;ArtistError{
                Code:    codes.AlreadyExists,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewForbiddenError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;ArtistError{
                Code:    codes.PermissionDenied,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

var (
        ErrArtistNotFound = NewNotFoundError("artist not found")
)
</pre>
		
		<pre class="file" id="file55" style="display: none">package main

import (
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/redis"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/internal/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/internal/repository"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/internal/usecase"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/interceptors"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.uber.org/zap"
        "google.golang.org/grpc"

        authProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/auth"
)

func main() <span class="cov0" title="0">{
        logger, err := loggerPkg.NewZapLogger()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creating logger:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error syncing logger:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error loading config:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">port := fmt.Sprintf(":%d", cfg.Services.AuthService.Port)
        conn, err := net.Listen("tcp", port)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Can't start auth service:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">reg := prometheus.NewRegistry()
        metrics := metrics.NewMetrics(reg, "auth_service")

        accessInterceptor := interceptors.NewAccessInterceptor(logger, metrics)

        server := grpc.NewServer(
                grpc.UnaryInterceptor(accessInterceptor.UnaryServerInterceptor()),
        )

        redisPool := redis.NewRedisPool(cfg.Redis)
        defer func() </span><span class="cov0" title="0">{
                if err := redisPool.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing Redis:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
                address := fmt.Sprintf(":%d", cfg.Prometheus.AuthPort)
                logger.Info(fmt.Sprintf("Serving metrics responds on port %d", cfg.Prometheus.AuthPort))
                if err := http.ListenAndServe(address, nil); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Error starting metrics server", zap.String("error", err.Error()))
                }</span>
        }()

        <span class="cov0" title="0">authRepository := repository.NewAuthRedisRepository(redisPool, metrics)
        authUsecase := usecase.NewAuthUsecase(authRepository)
        authService := delivery.NewAuthService(authUsecase)
        authProto.RegisterAuthServiceServer(server, authService)

        logger.Info("Auth service started on port %s...", zap.String("port", port))

        err = server.Serve(conn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error starting auth service:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)
        &lt;-c

        server.GracefulStop()
        logger.Info("Auth service stopped")</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package delivery

import (
        "context"

        authProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/auth"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/model"
)

type AuthService struct {
        authProto.UnimplementedAuthServiceServer
        authUsecase domain.Usecase
}

func NewAuthService(authUsecase domain.Usecase) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                authUsecase: authUsecase,
        }
}</span>

func (s *AuthService) CreateSession(ctx context.Context, req *authProto.UserID) (*authProto.SessionID, error) <span class="cov0" title="0">{
        sessionID, err := s.authUsecase.CreateSession(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.SessionIDFromUsecaseToProto(sessionID), nil</span>
}

func (s *AuthService) DeleteSession(ctx context.Context, req *authProto.SessionID) (*authProto.Nothing, error) <span class="cov0" title="0">{
        err := s.authUsecase.DeleteSession(ctx, req.SessionId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.NothingFromUsecaseToProto(), nil</span>
}

func (s *AuthService) GetSession(ctx context.Context, req *authProto.SessionID) (*authProto.UserID, error) <span class="cov0" title="0">{
        userID, err := s.authUsecase.GetSession(ctx, req.SessionId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.UserIDFromUsecaseToProto(userID), nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package repository

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "time"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/internal/domain"
        authErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/model/errors"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/gomodule/redigo/redis"
        "go.uber.org/zap"
)

const (
        SessionTTL = 24 * time.Hour
)

type authRedisRepository struct {
        redisPool *redis.Pool
        metrics   *metrics.Metrics
}

func NewAuthRedisRepository(redisPool *redis.Pool, metrics *metrics.Metrics) domain.Repository <span class="cov10" title="5">{
        return &amp;authRedisRepository{redisPool: redisPool, metrics: metrics}
}</span>

func generateSessionID() (string, error) <span class="cov1" title="1">{
        b := make([]byte, 32)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return base64.StdEncoding.EncodeToString(b), nil</span>
}

func (r *authRedisRepository) CreateSession(ctx context.Context, userID int64) (string, error) <span class="cov1" title="1">{
        start := time.Now()
        conn := r.redisPool.Get()

        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Creating session")
        expiration := int(SessionTTL.Seconds())

        defer func() </span><span class="cov1" title="1">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">SID, err := generateSessionID()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to generate session ID", zap.Error(err))
                return "", authErrors.NewCreateSessionError("failed to generate session ID: %v", err)
        }</span>

        <span class="cov1" title="1">_, err = redis.DoContext(conn, ctx, "SETEX", SID, expiration, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateSession").Inc()
                logger.Error("failed to create session", zap.Error(err))
                return "", authErrors.NewCreateSessionError("failed to create session: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CreateSession").Observe(duration)
        return SID, nil</span>
}

func (r *authRedisRepository) DeleteSession(ctx context.Context, sessionID string) error <span class="cov4" title="2">{
        start := time.Now()
        conn := r.redisPool.Get()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Deleting session")

        defer func() </span><span class="cov4" title="2">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov4" title="2">_, err := redis.DoContext(conn, ctx, "DEL", sessionID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteSession").Inc()
                logger.Error("failed to delete session", zap.Error(err))
                return authErrors.NewDeleteSessionError("failed to delete session: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("DeleteSession").Observe(duration)
        return nil</span>
}

func (r *authRedisRepository) GetSession(ctx context.Context, sessionID string) (int64, error) <span class="cov4" title="2">{
        start := time.Now()
        conn := r.redisPool.Get()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting session")

        defer func() </span><span class="cov4" title="2">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov4" title="2">id, err := redis.Int64(redis.DoContext(conn, ctx, "GET", sessionID))
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetSession").Inc()
                logger.Error("failed to get session", zap.Error(err))
                return -1, authErrors.NewGetSessionError("failed to get session: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetSession").Observe(duration)
        return id, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package usecase

import (
        "context"

        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/auth/internal/domain"
)

func NewAuthUsecase(authRepository domain.Repository) domain.Usecase <span class="cov10" title="6">{
        return &amp;authUsecase{
                authRepo: authRepository,
        }
}</span>

type authUsecase struct {
        authRepo domain.Repository
}

func (u *authUsecase) CreateSession(ctx context.Context, userID int64) (string, error) <span class="cov4" title="2">{
        sessionID, err := u.authRepo.CreateSession(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov1" title="1">return sessionID, nil</span>
}

func (u *authUsecase) DeleteSession(ctx context.Context, sessionID string) error <span class="cov4" title="2">{
        err := u.authRepo.DeleteSession(ctx, sessionID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *authUsecase) GetSession(ctx context.Context, sessionID string) (int64, error) <span class="cov4" title="2">{
        userID, err := u.authRepo.GetSession(ctx, sessionID)
        if err != nil </span><span class="cov1" title="1">{
                return -1, err
        }</span>
        <span class="cov1" title="1">return userID, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package model

import (
        protoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/auth"
)

func SessionIDFromUsecaseToProto(sessionID string) *protoModel.SessionID <span class="cov8" title="1">{
        return &amp;protoModel.SessionID{
                SessionId: sessionID,
        }
}</span>

func NothingFromUsecaseToProto() *protoModel.Nothing <span class="cov8" title="1">{
        return &amp;protoModel.Nothing{Dummy: true}
}</span>

func UserIDFromUsecaseToProto(userID int64) *protoModel.UserID <span class="cov8" title="1">{
        return &amp;protoModel.UserID{
                Id: userID,
        }
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package errors

import (
        "fmt"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type AuthError struct {
        Code    codes.Code
        Message string
}

func (e *AuthError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func (e *AuthError) GRPCStatus() *status.Status <span class="cov0" title="0">{
        return status.New(e.Code, e.Message)
}</span>

func NewCreateSessionError(format string, args ...interface{}) *AuthError <span class="cov0" title="0">{
        return &amp;AuthError{
                Code:    codes.Unavailable,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewDeleteSessionError(format string, args ...interface{}) *AuthError <span class="cov0" title="0">{
        return &amp;AuthError{
                Code:    codes.Unavailable,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewGetSessionError(format string, args ...interface{}) *AuthError <span class="cov0" title="0">{
        return &amp;AuthError{
                Code:    codes.Unavailable,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

var (
        ErrCreateSession = NewCreateSessionError("failed to create session")
        ErrDeleteSession = NewDeleteSessionError("failed to delete session")
        ErrGetSession    = NewGetSessionError("failed to get session")
)
</pre>
		
		<pre class="file" id="file61" style="display: none">package interceptors

import (
        "context"
        "strconv"
        "time"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

type AccessInterceptor struct {
        logger  *zap.SugaredLogger
        metrics *metrics.Metrics
}

func NewAccessInterceptor(logger *zap.SugaredLogger, metrics *metrics.Metrics) *AccessInterceptor <span class="cov0" title="0">{
        return &amp;AccessInterceptor{logger: logger, metrics: metrics}
}</span>

func (i *AccessInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                ctxLogger := i.logger.With(zap.String("method", info.FullMethod))
                md, ok := metadata.FromIncomingContext(ctx)
                if ok </span><span class="cov0" title="0">{
                        requestId := md.Get("request_id")
                        if len(requestId) &gt; 0 </span><span class="cov0" title="0">{
                                ctxLogger = ctxLogger.With(zap.String("request_id", requestId[0]))
                        }</span>
                }
                <span class="cov0" title="0">newCtx := logger.LoggerToContext(ctx, ctxLogger)

                startTime := time.Now()

                ctxLogger.Infow("gRPC request received",
                        "method", info.FullMethod,
                        "request", req,
                )

                resp, err := handler(newCtx, req)

                duration := time.Since(startTime)
                if err != nil </span><span class="cov0" title="0">{
                        st, _ := status.FromError(err)
                        ctxLogger.Errorw("gRPC request failed",
                                "method", info.FullMethod,
                                "code", st.Code(),
                                "error", err,
                                "duration", duration,
                        )
                        i.metrics.GRPCTotalNumberOfRequests.WithLabelValues(info.FullMethod, strconv.Itoa(int(st.Code()))).Inc()
                        i.metrics.GRPCRequestDuration.WithLabelValues(info.FullMethod).Observe(duration.Seconds())
                }</span> else<span class="cov0" title="0"> {
                        ctxLogger.Infow("gRPC request completed",
                                "method", info.FullMethod,
                                "duration", duration,
                        )
                        i.metrics.GRPCTotalNumberOfRequests.WithLabelValues(info.FullMethod, strconv.Itoa(200)).Inc()
                        i.metrics.GRPCRequestDuration.WithLabelValues(info.FullMethod).Observe(duration.Seconds())
                }</span>

                <span class="cov0" title="0">return resp, err</span>
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/collectors"
)

type Metrics struct {
        GRPCTotalNumberOfRequests *prometheus.CounterVec
        GRPCRequestDuration       *prometheus.HistogramVec
        DatabaseDuration          *prometheus.HistogramVec
        DatabaseErrors            *prometheus.CounterVec
}

/*
request_duration_seconds_bucket{le="0.0003"} 1153
request_duration_seconds_bucket{le="0.00039999999999999996"} 1373
request_duration_seconds_bucket{le="0.0005"} 1747
request_duration_seconds_bucket{le="0.00075"} 4031
request_duration_seconds_bucket{le="0.001"} 7585
request_duration_seconds_bucket{le="0.003"} 38531
request_duration_seconds_bucket{le="0.005"} 47689
request_duration_seconds_bucket{le="0.0075"} 50412
request_duration_seconds_bucket{le="0.01"} 51028
request_duration_seconds_bucket{le="0.030000000000000002"} 51701
request_duration_seconds_bucket{le="0.05"} 51743
request_duration_seconds_bucket{le="0.07500000000000001"} 51753
request_duration_seconds_bucket{le="0.1"} 51763
request_duration_seconds_bucket{le="0.3"} 51835
request_duration_seconds_bucket{le="0.5"} 51850
request_duration_seconds_bucket{le="0.75"} 51852
request_duration_seconds_bucket{le="1.0"} 51854
request_duration_seconds_bucket{le="+Inf"} 51862
request_duration_seconds_count 51862
request_duration_seconds_sum 162.932875708
*/

func NewMetrics(reg prometheus.Registerer, namespace string) *Metrics <span class="cov0" title="0">{
        metrics := &amp;Metrics{
                GRPCTotalNumberOfRequests: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name:      "grpc_number_of_requests_total",
                                Help:      "Total number of requests received",
                                Namespace: namespace,
                        },
                        []string{"method", "status"},
                ),
                GRPCRequestDuration: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:      "grpc_request_duration_seconds",
                                Help:      "Duration of gRPC requests in seconds",
                                Namespace: namespace,
                                Buckets:   []float64{0.0003, 0.0005, 0.00075, 0.001, 0.002, 0.003, 0.004, 0.005, 0.0075, 0.01, 0.3, 1},
                        },
                        []string{"method"},
                ),
                DatabaseDuration: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:      "database_duration_seconds",
                                Help:      "Duration of database operations in seconds",
                                Namespace: namespace,
                                Buckets:   []float64{0.0003, 0.0005, 0.00075, 0.001, 0.002, 0.003, 0.004, 0.005, 0.0075, 0.01, 0.3, 1},
                        },
                        []string{"operation"},
                ),
                DatabaseErrors: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name:      "database_errors_total",
                                Help:      "Total number of database errors",
                                Namespace: namespace,
                        },
                        []string{"operation"},
                ),
        }
        reg.MustRegister(collectors.NewGoCollector())
        reg.MustRegister(metrics.GRPCTotalNumberOfRequests)
        reg.MustRegister(metrics.GRPCRequestDuration)
        reg.MustRegister(metrics.DatabaseDuration)
        reg.MustRegister(metrics.DatabaseErrors)

        return metrics
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
)

func NewMockMetrics() *Metrics <span class="cov0" title="0">{
        return &amp;Metrics{
                GRPCTotalNumberOfRequests: prometheus.NewCounterVec(
                        prometheus.CounterOpts{Name: "mock_requests"},
                        []string{"method", "status"},
                ),
                GRPCRequestDuration: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{Name: "mock_duration"},
                        []string{"method"},
                ),
                DatabaseDuration: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{Name: "mock_db_duration"},
                        []string{"operation"},
                ),
                DatabaseErrors: prometheus.NewCounterVec(
                        prometheus.CounterOpts{Name: "mock_db_errors"},
                        []string{"operation"},
                ),
        }
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package main

import (
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/postgres"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/s3"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/interceptors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/repository"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/usecase"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.uber.org/zap"
        "google.golang.org/grpc"

        playlistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/playlist"
)

func main() <span class="cov0" title="0">{
        logger, err := loggerPkg.NewZapLogger()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creating logger:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error syncing logger:", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error loading config:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">port := fmt.Sprintf(":%d", cfg.Services.PlaylistService.Port)
        conn, err := net.Listen("tcp", port)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Can't start album service:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">reg := prometheus.NewRegistry()
        metrics := metrics.NewMetrics(reg, "playlist_service")

        accessInterceptor := interceptors.NewAccessInterceptor(logger, metrics)

        server := grpc.NewServer(
                grpc.UnaryInterceptor(accessInterceptor.UnaryServerInterceptor()),
        )

        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
                address := fmt.Sprintf(":%d", cfg.Prometheus.PlaylistPort)
                logger.Info(fmt.Sprintf("Serving metrics responds on port %d", cfg.Prometheus.PlaylistPort))
                if err := http.ListenAndServe(address, nil); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Error starting metrics server", zap.String("error", err.Error()))
                }</span>
        }()

        <span class="cov0" title="0">postgresPool, err := postgres.ConnectPostgres(cfg.Postgres)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error connecting to postgres:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := postgresPool.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing Postgres:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">s3, err := s3.InitS3(cfg.S3)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initializing S3:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">playlistRepository := repository.NewPlaylistPostgresRepository(postgresPool, metrics)
        playlistS3Repository := repository.NewPlaylistS3Repository(s3, cfg.S3.S3ImagesBucket)
        playlistUsecase := usecase.NewPlaylistUsecase(playlistRepository, playlistS3Repository)
        playlistService := delivery.NewPlaylistService(playlistUsecase, playlistS3Repository)
        playlistProto.RegisterPlaylistServiceServer(server, playlistService)

        logger.Info("Playlist service started", zap.String("port", port))

        err = server.Serve(conn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error starting playlist service:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)
        &lt;-c

        server.GracefulStop()
        logger.Info("Playlist service stopped")</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package delivery

import (
        "context"

        "google.golang.org/protobuf/types/known/emptypb"

        playlistProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/playlist"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model"
)

type PlaylistService struct {
        playlistProto.UnimplementedPlaylistServiceServer
        playlistUsecase domain.Usecase
        s3Repository    domain.S3Repository
}

func NewPlaylistService(playlistUsecase domain.Usecase, s3Repository domain.S3Repository) playlistProto.PlaylistServiceServer <span class="cov0" title="0">{
        return &amp;PlaylistService{
                playlistUsecase: playlistUsecase,
                s3Repository:    s3Repository,
        }
}</span>

func (s *PlaylistService) CreatePlaylist(ctx context.Context, req *playlistProto.CreatePlaylistRequest) (*playlistProto.Playlist, error) <span class="cov0" title="0">{
        playlist, err := s.playlistUsecase.CreatePlaylist(ctx, model.CreatePlaylistRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.PlaylistFromUsecaseToProto(playlist), nil</span>
}

func (s *PlaylistService) UploadPlaylistThumbnail(ctx context.Context, req *playlistProto.UploadPlaylistThumbnailRequest) (*playlistProto.UploadPlaylistThumbnailResponse, error) <span class="cov0" title="0">{
        thumbnail, err := s.playlistUsecase.UploadPlaylistThumbnail(ctx, model.UploadPlaylistThumbnailRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;playlistProto.UploadPlaylistThumbnailResponse{
                Thumbnail: thumbnail,
        }, nil</span>
}

func (s *PlaylistService) GetCombinedPlaylistsByUserID(ctx context.Context, req *playlistProto.GetCombinedPlaylistsByUserIDRequest) (*playlistProto.PlaylistList, error) <span class="cov0" title="0">{
        playlists, err := s.playlistUsecase.GetCombinedPlaylistsByUserID(ctx, model.GetCombinedPlaylistsByUserIDRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.PlaylistListFromUsecaseToProto(playlists), nil</span>
}

func (s *PlaylistService) AddTrackToPlaylist(ctx context.Context, req *playlistProto.AddTrackToPlaylistRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.playlistUsecase.AddTrackToPlaylist(ctx, model.AddTrackToPlaylistRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *PlaylistService) RemoveTrackFromPlaylist(ctx context.Context, req *playlistProto.RemoveTrackFromPlaylistRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.playlistUsecase.RemoveTrackFromPlaylist(ctx, model.RemoveTrackFromPlaylistRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *PlaylistService) GetPlaylistTrackIds(ctx context.Context, req *playlistProto.GetPlaylistTrackIdsRequest) (*playlistProto.GetPlaylistTrackIdsResponse, error) <span class="cov0" title="0">{
        trackIds, err := s.playlistUsecase.GetPlaylistTrackIds(ctx, model.GetPlaylistTrackIdsRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;playlistProto.GetPlaylistTrackIdsResponse{
                TrackIds: trackIds,
        }, nil</span>
}

func (s *PlaylistService) UpdatePlaylist(ctx context.Context, req *playlistProto.UpdatePlaylistRequest) (*playlistProto.Playlist, error) <span class="cov0" title="0">{
        playlist, err := s.playlistUsecase.UpdatePlaylist(ctx, model.UpdatePlaylistRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.PlaylistFromUsecaseToProto(playlist), nil</span>
}

func (s *PlaylistService) GetPlaylistByID(ctx context.Context, req *playlistProto.GetPlaylistByIDRequest) (*playlistProto.PlaylistWithIsLiked, error) <span class="cov0" title="0">{
        playlist, err := s.playlistUsecase.GetPlaylistByID(ctx, model.GetPlaylistByIDRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.PlaylistWithIsLikedFromUsecaseToProto(playlist), nil</span>
}

func (s *PlaylistService) RemovePlaylist(ctx context.Context, req *playlistProto.RemovePlaylistRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.playlistUsecase.RemovePlaylist(ctx, model.RemovePlaylistRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *PlaylistService) GetPlaylistsToAdd(ctx context.Context, req *playlistProto.GetPlaylistsToAddRequest) (*playlistProto.GetPlaylistsToAddResponse, error) <span class="cov0" title="0">{
        playlists, err := s.playlistUsecase.GetPlaylistsToAdd(ctx, model.GetPlaylistsToAddRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.GetPlaylistsToAddResponseFromUsecaseToProto(playlists), nil</span>
}

func (s *PlaylistService) UpdatePlaylistsPublisityByUserID(ctx context.Context, req *playlistProto.UpdatePlaylistsPublisityByUserIDRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.playlistUsecase.UpdatePlaylistsPublisityByUserID(ctx, model.UpdatePlaylistsPublisityByUserIDRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *PlaylistService) LikePlaylist(ctx context.Context, req *playlistProto.LikePlaylistRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.playlistUsecase.LikePlaylist(ctx, model.LikePlaylistRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *PlaylistService) GetProfilePlaylists(ctx context.Context, req *playlistProto.GetProfilePlaylistsRequest) (*playlistProto.GetProfilePlaylistsResponse, error) <span class="cov0" title="0">{
        playlists, err := s.playlistUsecase.GetProfilePlaylists(ctx, model.GetProfilePlaylistsRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.GetProfilePlaylistsResponseFromUsecaseToProto(playlists), nil</span>
}

func (s *PlaylistService) SearchPlaylists(ctx context.Context, req *playlistProto.SearchPlaylistsRequest) (*playlistProto.PlaylistList, error) <span class="cov0" title="0">{
        playlists, err := s.playlistUsecase.SearchPlaylists(ctx, model.SearchPlaylistsRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.PlaylistListFromUsecaseToProto(playlists), nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package repository

import (
        "context"
        "database/sql"
        "strings"
        "time"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/domain"
        playlistErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model/errors"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model/repository"
        "go.uber.org/zap"
)

const (
        CreatePlaylistQuery = `
                INSERT INTO playlist (title, user_id, thumbnail_url, is_public)
                VALUES ($1, $2, $3, $4)
                RETURNING id
        `

        GetPlaylistByIDQuery = `
                SELECT id, title, user_id, thumbnail_url, is_public
                FROM playlist
                WHERE id = $1
        `

        // Owned and favorite playlists
        GetPlaylistsByUserIDQuery = `
                SELECT p.id, p.title, p.user_id, p.thumbnail_url
                FROM playlist p
                LEFT JOIN favorite_playlist fp ON p.id = fp.playlist_id
                WHERE p.user_id = $1 OR (fp.user_id = $1 AND p.is_public = true)
                ORDER BY 
                        CASE WHEN p.user_id = $1 THEN p.created_at ELSE fp.created_at END DESC
        `

        AddTrackToPlaylistQuery = `
                INSERT INTO playlist_track (playlist_id, track_id)
                VALUES ($1, $2)
        `

        RemoveTrackFromPlaylistQuery = `
                DELETE FROM playlist_track
                WHERE playlist_id = $1 AND track_id = $2
        `

        TrackExistsInPlaylistQuery = `
                SELECT EXISTS (
                        SELECT 1
                        FROM playlist_track
                        WHERE playlist_id = $1 AND track_id = $2
                )
        `

        GetPlaylistTrackIdsQuery = `
                SELECT track_id
                FROM playlist_track
                WHERE playlist_id = $1
                ORDER BY created_at ASC, id ASC
        `

        UpdatePlaylistWithThumbnailQuery = `
                UPDATE playlist
                SET title = $2, thumbnail_url = $3
                WHERE id = $1 AND user_id = $4
                RETURNING id
        `

        UpdatePlaylistWithoutThumbnailQuery = `
                UPDATE playlist
                SET title = $2
                WHERE id = $1 AND user_id = $3
                RETURNING id
        `

        RemovePlaylistQuery = `
                DELETE FROM playlist
                WHERE id = $1 AND user_id = $2
        `

        GetPlaylistsToAddQuery = `
                SELECT p.id, p.title, p.user_id, p.thumbnail_url, 
                       EXISTS (
                           SELECT 1 
                           FROM playlist_track pt 
                           WHERE pt.playlist_id = p.id AND pt.track_id = $1
                       ) as is_included
                FROM playlist p
                WHERE p.user_id = $2
                ORDER BY p.created_at DESC
        `

        UpdatePlaylistsPublisityByUserIDQuery = `
                UPDATE playlist
                SET is_public = $2
                WHERE user_id = $1
        `

        CheckExistsPlaylistAndNotDifferentUserQuery = `
                SELECT EXISTS (
                        SELECT 1
                        FROM playlist
                        WHERE id = $1 AND user_id != $2
                )
        `

        LikePlaylistQuery = `
                INSERT INTO favorite_playlist (user_id, playlist_id)
                VALUES ($1, $2) ON CONFLICT DO NOTHING
        `

        UnlikePlaylistQuery = `
                DELETE FROM favorite_playlist
                WHERE user_id = $1 AND playlist_id = $2
        `

        GetPlaylistWithIsLikedByIDQuery = `
                SELECT p.id, p.title, p.user_id, p.thumbnail_url, (fp.user_id IS NOT NULL) as is_liked
                FROM playlist p
                LEFT JOIN favorite_playlist fp ON p.id = fp.playlist_id AND fp.user_id = $2
                WHERE p.id = $1
        `

        GetProfilePlaylistsQuery = `
                SELECT p.id, p.title, p.user_id, p.thumbnail_url
                FROM playlist p
                WHERE p.user_id = $1
                ORDER BY p.created_at DESC
        `

        SearchPlaylistsQuery = `
                SELECT id, title, user_id, thumbnail_url
                FROM playlist
                WHERE (is_public = true OR user_id = $2) AND (search_vector @@ to_tsquery('multilingual', $1)
                   OR similarity(title_trgm, $3) &gt; 0.3)
                ORDER BY 
                    CASE WHEN search_vector @@ to_tsquery('multilingual', $1) THEN 0 ELSE 1 END,
                    ts_rank(search_vector, to_tsquery('multilingual', $1)) DESC,
                    similarity(title_trgm, $3) DESC
        `
)

type PlaylistPostgresRepository struct {
        db      *sql.DB
        metrics *metrics.Metrics
}

func NewPlaylistPostgresRepository(db *sql.DB, metrics *metrics.Metrics) domain.Repository <span class="cov10" title="50">{
        return &amp;PlaylistPostgresRepository{db: db, metrics: metrics}
}</span>

func (r *PlaylistPostgresRepository) GetPlaylistByID(ctx context.Context, id int64) (*repoModel.Playlist, error) <span class="cov7" title="19">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting playlist by id", zap.Int64("id", id))

        start := time.Now()

        stmt, err := r.db.PrepareContext(ctx, GetPlaylistByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistByID").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov7" title="19">defer func() </span><span class="cov7" title="19">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov7" title="19">var playlist repoModel.Playlist
        err = stmt.QueryRowContext(ctx, id).Scan(&amp;playlist.ID, &amp;playlist.Title, &amp;playlist.UserID, &amp;playlist.Thumbnail, &amp;playlist.IsPublic)
        if err != nil </span><span class="cov4" title="5">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistByID").Inc()
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        logger.Warn("Playlist not found", zap.Int64("id", id))
                        return nil, playlistErrors.ErrPlaylistNotFound
                }</span>
                <span class="cov4" title="4">logger.Error("Failed to get playlist by id", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to get playlist by id: %v", err)</span>
        }

        <span class="cov7" title="14">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetPlaylistByID").Observe(duration)

        return &amp;playlist, nil</span>
}

func (r *PlaylistPostgresRepository) CreatePlaylist(ctx context.Context, playlistCreateRequest *repoModel.CreatePlaylistRequest) (*repoModel.Playlist, error) <span class="cov3" title="3">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Creating playlist", zap.Any("playlist", playlistCreateRequest))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, CreatePlaylistQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreatePlaylist").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">var id int64
        err = stmt.QueryRowContext(ctx, playlistCreateRequest.Title, playlistCreateRequest.UserID, playlistCreateRequest.Thumbnail, playlistCreateRequest.IsPublic).Scan(&amp;id)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("CreatePlaylist").Inc()
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov1" title="1">{
                        logger.Warn("Failed to create playlist: duplicate title for user", zap.Error(err))
                        return nil, playlistErrors.ErrPlaylistDuplicate
                }</span>
                <span class="cov0" title="0">logger.Error("Failed to create playlist", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to create playlist: %v", err)</span>
        }

        <span class="cov2" title="2">playlist, err := r.GetPlaylistByID(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to get playlist by id", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to get playlist by id: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CreatePlaylist").Observe(duration)

        return playlist, nil</span>
}

func (r *PlaylistPostgresRepository) GetCombinedPlaylistsByUserID(ctx context.Context, userID int64) (*repoModel.PlaylistList, error) <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting playlists by user id", zap.Int64("user_id", userID))
        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, GetPlaylistsByUserIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetCombinedPlaylistsByUserID").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var playlists repoModel.PlaylistList
        rows, err := stmt.QueryContext(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetCombinedPlaylistsByUserID").Inc()
                logger.Error("Failed to get playlists by user id", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to get playlists by user id: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">for rows.Next() </span><span class="cov2" title="2">{
                var playlist repoModel.Playlist
                err := rows.Scan(&amp;playlist.ID, &amp;playlist.Title, &amp;playlist.UserID, &amp;playlist.Thumbnail)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan playlist", zap.Error(err))
                        return nil, playlistErrors.NewInternalError("failed to scan playlist: %v", err)
                }</span>
                <span class="cov2" title="2">playlists.Playlists = append(playlists.Playlists, &amp;playlist)</span>
        }

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetCombinedPlaylistsByUserID").Observe(duration)

        return &amp;playlists, nil</span>
}

func (r *PlaylistPostgresRepository) TrackExistsInPlaylist(ctx context.Context, playlistID int64, trackID int64) (bool, error) <span class="cov6" title="10">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking if track exists in playlist", "playlist_id", playlistID, "track_id", trackID)

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, TrackExistsInPlaylistQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("TrackExistsInPlaylist").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return false, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov6" title="10">defer func() </span><span class="cov6" title="10">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov6" title="10">var exists bool
        err = stmt.QueryRowContext(ctx, playlistID, trackID).Scan(&amp;exists)
        if err != nil </span><span class="cov3" title="3">{
                r.metrics.DatabaseErrors.WithLabelValues("TrackExistsInPlaylist").Inc()
                logger.Error("Failed to check if track exists in playlist", zap.Error(err))
                return false, playlistErrors.NewInternalError("failed to check if track exists in playlist: %v", err)
        }</span>

        <span class="cov5" title="7">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("TrackExistsInPlaylist").Observe(duration)

        return exists, nil</span>
}

func (r *PlaylistPostgresRepository) AddTrackToPlaylist(ctx context.Context, request *repoModel.AddTrackToPlaylistRequest) error <span class="cov5" title="6">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Adding track to playlist", zap.Int64("playlist_id", request.PlaylistID), zap.Int64("track_id", request.TrackID))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, AddTrackToPlaylistQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("AddTrackToPlaylist").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov5" title="6">defer func() </span><span class="cov5" title="6">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov5" title="6">playlist, err := r.GetPlaylistByID(ctx, request.PlaylistID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("AddTrackToPlaylist").Inc()
                logger.Error("Failed to get playlist by id", zap.Error(err))
                return err
        }</span>

        <span class="cov4" title="5">if playlist.UserID != request.UserID </span><span class="cov1" title="1">{
                logger.Warn("User tryed to add track to another user's playlist", zap.Int64("playlist_id", request.PlaylistID), zap.Int64("user_id", request.UserID))
                return playlistErrors.ErrPlaylistPermissionDenied
        }</span>

        <span class="cov4" title="4">trackExists, err := r.TrackExistsInPlaylist(ctx, request.PlaylistID, request.TrackID)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to check if track exists in playlist", zap.Error(err))
                return playlistErrors.NewInternalError("failed to check if track exists in playlist: %v", err)
        }</span>

        <span class="cov3" title="3">if trackExists </span><span class="cov1" title="1">{
                logger.Warn("Track already in playlist", zap.Int64("playlist_id", request.PlaylistID), zap.Int64("track_id", request.TrackID))
                return playlistErrors.ErrPlaylistTrackDuplicate
        }</span>

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, request.PlaylistID, request.TrackID)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to add track to playlist", zap.Error(err))
                return playlistErrors.NewInternalError("failed to add track to playlist: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("AddTrackToPlaylist").Observe(duration)

        return nil</span>
}

func (r *PlaylistPostgresRepository) RemoveTrackFromPlaylist(ctx context.Context, request *repoModel.RemoveTrackFromPlaylistRequest) error <span class="cov5" title="6">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Removing track from playlist", zap.Int64("playlist_id", request.PlaylistID), zap.Int64("track_id", request.TrackID))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, RemoveTrackFromPlaylistQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("RemoveTrackFromPlaylist").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov5" title="6">defer func() </span><span class="cov5" title="6">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov5" title="6">playlist, err := r.GetPlaylistByID(ctx, request.PlaylistID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("RemoveTrackFromPlaylist").Inc()
                logger.Error("Failed to get playlist by id", zap.Error(err))
                return err
        }</span>

        <span class="cov4" title="5">if playlist.UserID != request.UserID </span><span class="cov1" title="1">{
                logger.Warn("User tryed to remove track from another user's playlist", zap.Int64("playlist_id", request.PlaylistID), zap.Int64("user_id", request.UserID))
                return playlistErrors.ErrPlaylistPermissionDenied
        }</span>

        <span class="cov4" title="4">trackExists, err := r.TrackExistsInPlaylist(ctx, request.PlaylistID, request.TrackID)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to check if track exists in playlist", zap.Error(err))
                return playlistErrors.NewInternalError("failed to check if track exists in playlist: %v", err)
        }</span>

        <span class="cov3" title="3">if !trackExists </span><span class="cov1" title="1">{
                logger.Warn("Track does not exist in playlist", zap.Int64("playlist_id", request.PlaylistID), zap.Int64("track_id", request.TrackID))
                return playlistErrors.ErrPlaylistTrackNotFound
        }</span>

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, request.PlaylistID, request.TrackID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("RemoveTrackFromPlaylist").Inc()
                logger.Error("Failed to remove track from playlist", zap.Error(err))
                return playlistErrors.NewInternalError("failed to remove track from playlist: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("RemoveTrackFromPlaylist").Observe(duration)

        return nil</span>
}

func (r *PlaylistPostgresRepository) GetPlaylistTrackIds(ctx context.Context, request *repoModel.GetPlaylistTrackIdsRequest) ([]int64, error) <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting playlist track ids", "playlist_id", request.PlaylistID)

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, GetPlaylistTrackIdsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistTrackIds").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var trackIds []int64
        rows, err := stmt.QueryContext(ctx, request.PlaylistID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistTrackIds").Inc()
                logger.Error("Failed to get playlist track ids", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to get playlist track ids: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">for rows.Next() </span><span class="cov3" title="3">{
                var trackId int64
                err := rows.Scan(&amp;trackId)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistTrackIds").Inc()
                        logger.Error("Failed to scan playlist track id", zap.Error(err))
                        return nil, playlistErrors.NewInternalError("failed to scan playlist track id: %v", err)
                }</span>
                <span class="cov3" title="3">trackIds = append(trackIds, trackId)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistTrackIds").Inc()
                logger.Error("Failed to iterate over playlist track ids", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to iterate over playlist track ids: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetPlaylistTrackIds").Observe(duration)

        logger.Info("Playlist track ids", zap.Any("track_ids", trackIds))

        return trackIds, nil</span>
}

func (r *PlaylistPostgresRepository) UpdatePlaylist(ctx context.Context, request *repoModel.UpdatePlaylistRequest) (*repoModel.Playlist, error) <span class="cov4" title="5">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Updating playlist", zap.Any("playlist", request))

        start := time.Now()

        stmt, err := r.db.PrepareContext(ctx, UpdatePlaylistWithThumbnailQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdatePlaylist").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov4" title="5">defer func() </span><span class="cov4" title="5">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov4" title="5">var id int64
        if request.Thumbnail != "" </span><span class="cov3" title="3">{
                err := stmt.QueryRowContext(ctx, request.PlaylistID, request.Title, request.Thumbnail, request.UserID).Scan(&amp;id)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("UpdatePlaylist").Inc()
                        logger.Error("Failed to update playlist", zap.Error(err))
                        return nil, playlistErrors.NewInternalError("failed to update playlist: %v", err)
                }</span>
        } else<span class="cov2" title="2"> {
                err := stmt.QueryRowContext(ctx, request.PlaylistID, request.Title, request.UserID).Scan(&amp;id)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("UpdatePlaylist").Inc()
                        logger.Error("Failed to update playlist", zap.Error(err))
                        return nil, playlistErrors.NewInternalError("failed to update playlist: %v", err)
                }</span>
        }

        <span class="cov3" title="3">playlist, err := r.GetPlaylistByID(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdatePlaylist").Inc()
                logger.Error("Failed to get playlist by id", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to get playlist by id: %v", err)
        }</span>

        <span class="cov2" title="2">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UpdatePlaylist").Observe(duration)

        return playlist, nil</span>
}

func (r *PlaylistPostgresRepository) RemovePlaylist(ctx context.Context, request *repoModel.RemovePlaylistRequest) error <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Removing playlist", zap.Int64("playlist_id", request.PlaylistID))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, RemovePlaylistQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("RemovePlaylist").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, request.PlaylistID, request.UserID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("RemovePlaylist").Inc()
                logger.Error("Failed to remove playlist", zap.Error(err))
                return playlistErrors.NewInternalError("failed to remove playlist: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("RemovePlaylist").Observe(duration)

        return nil</span>
}

func (r *PlaylistPostgresRepository) GetPlaylistsToAdd(ctx context.Context, request *repoModel.GetPlaylistsToAddRequest) (*repoModel.GetPlaylistsToAddResponse, error) <span class="cov3" title="3">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting playlists to add track to", zap.Int64("track_id", request.TrackID), zap.Int64("user_id", request.UserID))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, GetPlaylistsToAddQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistsToAdd").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">var response repoModel.GetPlaylistsToAddResponse
        rows, err := stmt.QueryContext(ctx, request.TrackID, request.UserID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistsToAdd").Inc()
                logger.Error("Failed to get playlists to add track to", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to get playlists to add track to: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">for rows.Next() </span><span class="cov3" title="3">{
                var playlist repoModel.Playlist
                var isIncluded sql.NullBool
                err := rows.Scan(&amp;playlist.ID, &amp;playlist.Title, &amp;playlist.UserID, &amp;playlist.Thumbnail, &amp;isIncluded)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistsToAdd").Inc()
                        logger.Error("Failed to scan playlist", zap.Error(err))
                        return nil, playlistErrors.NewInternalError("failed to scan playlist: %v", err)
                }</span>

                <span class="cov2" title="2">playlistWithFlag := &amp;repoModel.PlaylistWithIsIncludedTrack{
                        Playlist:   &amp;playlist,
                        IsIncluded: isIncluded.Valid &amp;&amp; isIncluded.Bool,
                }

                response.Playlists = append(response.Playlists, playlistWithFlag)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistsToAdd").Inc()
                logger.Error("Failed to iterate over playlists", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to iterate over playlists: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetPlaylistsToAdd").Observe(duration)

        return &amp;response, nil</span>
}

func (r *PlaylistPostgresRepository) UpdatePlaylistsPublisityByUserID(ctx context.Context, request *repoModel.UpdatePlaylistsPublisityByUserIDRequest) error <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Updating playlists publisity by user id", zap.Int64("user_id", request.UserID), zap.Bool("is_public", request.IsPublic))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, UpdatePlaylistsPublisityByUserIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdatePlaylistsPublisityByUserID").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, request.UserID, request.IsPublic)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdatePlaylistsPublisityByUserID").Inc()
                logger.Error("Failed to update playlists publisity by user id", zap.Error(err))
                return playlistErrors.NewInternalError("failed to update playlists publisity by user id: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UpdatePlaylistsPublisityByUserID").Observe(duration)

        return nil</span>
}

func (r *PlaylistPostgresRepository) CheckExistsPlaylistAndNotDifferentUser(ctx context.Context, playlistID int64, userID int64) (bool, error) <span class="cov4" title="5">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking if playlist exists and is not different user", zap.Int64("playlist_id", playlistID), zap.Int64("user_id", userID))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, CheckExistsPlaylistAndNotDifferentUserQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckExistsPlaylistAndNotDifferentUser").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return false, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov4" title="5">defer func() </span><span class="cov4" title="5">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov4" title="5">var exists bool
        err = stmt.QueryRowContext(ctx, playlistID, userID).Scan(&amp;exists)
        if err != nil </span><span class="cov2" title="2">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckExistsPlaylistAndNotDifferentUser").Inc()
                logger.Error("Failed to check if playlist exists and is not different user", zap.Error(err))
                return false, playlistErrors.NewInternalError("failed to check if playlist exists and is not different user: %v", err)
        }</span>

        <span class="cov3" title="3">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CheckExistsPlaylistAndNotDifferentUser").Observe(duration)

        return exists, nil</span>
}

func (r *PlaylistPostgresRepository) LikePlaylist(ctx context.Context, request *repoModel.LikePlaylistRequest) error <span class="cov3" title="3">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Liking playlist", zap.Int64("playlist_id", request.PlaylistID), zap.Int64("user_id", request.UserID))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, LikePlaylistQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("LikePlaylist").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">exists, err := r.CheckExistsPlaylistAndNotDifferentUser(ctx, request.PlaylistID, request.UserID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("LikePlaylist").Inc()
                logger.Error("Failed to check if playlist exists and is not different user", zap.Error(err))
                return playlistErrors.NewInternalError("failed to check if playlist exists and is not different user: %v", err)
        }</span>

        <span class="cov2" title="2">if !exists </span><span class="cov0" title="0">{
                logger.Warn("Playlist does not exist or is different user", zap.Int64("playlist_id", request.PlaylistID), zap.Int64("user_id", request.UserID))
                return playlistErrors.ErrPlaylistNotFound
        }</span>

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, request.UserID, request.PlaylistID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("LikePlaylist").Inc()
                logger.Error("Failed to like playlist", zap.Error(err))
                return playlistErrors.NewInternalError("failed to like playlist: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("LikePlaylist").Observe(duration)

        return nil</span>
}

func (r *PlaylistPostgresRepository) UnlikePlaylist(ctx context.Context, request *repoModel.LikePlaylistRequest) error <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Unliking playlist", zap.Int64("playlist_id", request.PlaylistID), zap.Int64("user_id", request.UserID))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, UnlikePlaylistQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UnlikePlaylist").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, request.UserID, request.PlaylistID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("UnlikePlaylist").Inc()
                logger.Error("Failed to unlike playlist", zap.Error(err))
                return playlistErrors.NewInternalError("failed to unlike playlist: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UnlikePlaylist").Observe(duration)

        return nil</span>
}

func (r *PlaylistPostgresRepository) GetPlaylistWithIsLikedByID(ctx context.Context, id int64, userID int64) (*repoModel.PlaylistWithIsLiked, error) <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting playlist with is liked by id", zap.Int64("playlist_id", id), zap.Int64("user_id", userID))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, GetPlaylistWithIsLikedByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistWithIsLikedByID").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var playlist repoModel.Playlist
        var isLiked sql.NullBool
        err = stmt.QueryRowContext(ctx, id, userID).Scan(&amp;playlist.ID, &amp;playlist.Title, &amp;playlist.UserID, &amp;playlist.Thumbnail, &amp;isLiked)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPlaylistWithIsLikedByID").Inc()
                logger.Error("Failed to get playlist with is liked by id", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to get playlist with is liked by id: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetPlaylistWithIsLikedByID").Observe(duration)

        return &amp;repoModel.PlaylistWithIsLiked{
                Playlist: &amp;playlist,
                IsLiked:  isLiked.Valid &amp;&amp; isLiked.Bool,
        }, nil</span>
}

func (r *PlaylistPostgresRepository) GetProfilePlaylists(ctx context.Context, request *repoModel.GetProfilePlaylistsRequest) (*repoModel.GetProfilePlaylistsResponse, error) <span class="cov3" title="3">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting profile playlists", zap.Int64("user_id", request.UserID))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, GetProfilePlaylistsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetProfilePlaylists").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">var playlists repoModel.GetProfilePlaylistsResponse
        rows, err := stmt.QueryContext(ctx, request.UserID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetProfilePlaylists").Inc()
                logger.Error("Failed to get profile playlists", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to get profile playlists: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">for rows.Next() </span><span class="cov3" title="3">{
                var playlist repoModel.Playlist
                err := rows.Scan(&amp;playlist.ID, &amp;playlist.Title, &amp;playlist.UserID, &amp;playlist.Thumbnail)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetProfilePlaylists").Inc()
                        logger.Error("Failed to scan playlist", zap.Error(err))
                        return nil, playlistErrors.NewInternalError("failed to scan playlist: %v", err)
                }</span>

                <span class="cov2" title="2">playlists.Playlists = append(playlists.Playlists, &amp;playlist)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetProfilePlaylists").Inc()
                logger.Error("Failed to iterate over playlists", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to iterate over playlists: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetProfilePlaylists").Observe(duration)

        return &amp;playlists, nil</span>
}

func (r *PlaylistPostgresRepository) SearchPlaylists(ctx context.Context, request *repoModel.SearchPlaylistsRequest) (*repoModel.PlaylistList, error) <span class="cov3" title="3">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Searching playlists", zap.String("query", request.Query))

        start := time.Now()
        stmt, err := r.db.PrepareContext(ctx, SearchPlaylistsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("SearchPlaylists").Inc()
                logger.Error("Failed to prepare statement", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">words := strings.Fields(request.Query)
        for i, word := range words </span><span class="cov5" title="6">{
                words[i] = word + ":*"
        }</span>
        <span class="cov3" title="3">tsQueryString := strings.Join(words, " &amp; ")

        var playlists repoModel.PlaylistList
        rows, err := stmt.QueryContext(ctx, tsQueryString, request.UserID, request.Query)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("SearchPlaylists").Inc()
                logger.Error("Failed to search playlists", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to search playlists: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">for rows.Next() </span><span class="cov3" title="3">{
                var playlist repoModel.Playlist
                err := rows.Scan(&amp;playlist.ID, &amp;playlist.Title, &amp;playlist.UserID, &amp;playlist.Thumbnail)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("SearchPlaylists").Inc()
                        logger.Error("Failed to scan playlist", zap.Error(err))
                        return nil, playlistErrors.NewInternalError("failed to scan playlist: %v", err)
                }</span>

                <span class="cov2" title="2">playlists.Playlists = append(playlists.Playlists, &amp;playlist)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("SearchPlaylists").Inc()
                logger.Error("Failed to iterate over playlists", zap.Error(err))
                return nil, playlistErrors.NewInternalError("failed to iterate over playlists: %v", err)
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("SearchPlaylists").Observe(duration)

        return &amp;playlists, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package repository

import (
        "bytes"
        "context"
        "fmt"
        "image"
        "io"
        "time"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        playlistErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model/errors"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/domain"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"

        "go.uber.org/zap"

        _ "image/jpeg"
        _ "image/png"
)

const (
        MaxImageSize = 5 * 1024 * 1024
)

type playlistS3Repository struct {
        s3         *s3.S3
        uploader   *s3manager.Uploader
        bucketName string
}

func NewPlaylistS3Repository(s3 *s3.S3, bucketName string) domain.S3Repository <span class="cov0" title="0">{
        uploader := s3manager.NewUploaderWithClient(s3)
        return &amp;playlistS3Repository{
                s3:         s3,
                bucketName: bucketName,
                uploader:   uploader,
        }
}</span>

func (r *playlistS3Repository) UploadThumbnail(ctx context.Context, file io.Reader, key string) (string, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Uploading thumbnail", zap.String("key", key))
        buf := new(bytes.Buffer)
        _, err := io.Copy(buf, file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to parse image", "error", err)
                return "", playlistErrors.ErrFailedToParseImage
        }</span>

        <span class="cov0" title="0">if buf.Len() &gt; MaxImageSize </span><span class="cov0" title="0">{
                logger.Error("image size exceeds 5MB limit", "error", playlistErrors.ErrImageTooBig)
                return "", playlistErrors.ErrImageTooBig
        }</span>

        <span class="cov0" title="0">_, format, err := image.Decode(bytes.NewReader(buf.Bytes()))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to parse image", "error", err)
                return "", playlistErrors.ErrFailedToParseImage
        }</span>

        <span class="cov0" title="0">if format != "png" &amp;&amp; format != "jpeg" </span><span class="cov0" title="0">{
                logger.Error("unsupported image format", "error", playlistErrors.ErrUnsupportedImageFormat)
                return "", playlistErrors.ErrUnsupportedImageFormat
        }</span>

        <span class="cov0" title="0">timestampedKey := fmt.Sprintf("%s-%s.%s", key, time.Now().Format("20060102150405"), format)

        s3Key := fmt.Sprintf("playlists/%s", timestampedKey)

        output, err := r.uploader.UploadWithContext(ctx, &amp;s3manager.UploadInput{
                Bucket:      aws.String(r.bucketName),
                Key:         aws.String(s3Key),
                Body:        bytes.NewReader(buf.Bytes()),
                ContentType: aws.String("image/" + format),
                ACL:         aws.String("public-read"),
                Metadata: map[string]*string{
                        "Cache-Control": aws.String("max-age=86400, public"),
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to upload image", "error", err)
                return "", playlistErrors.NewInternalError("failed to upload image: %v", err)
        }</span>

        <span class="cov0" title="0">outloadedUrl := output.Location

        return outloadedUrl, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package usecase

import (
        "context"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model"
        playlistErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model/errors"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model/usecase"
)

type PlaylistUsecase struct {
        playlistRepo domain.Repository
        s3Repo       domain.S3Repository
}

func NewPlaylistUsecase(playlistRepo domain.Repository, s3Repo domain.S3Repository) domain.Usecase <span class="cov10" title="24">{
        return &amp;PlaylistUsecase{playlistRepo: playlistRepo, s3Repo: s3Repo}
}</span>

func (u *PlaylistUsecase) CreatePlaylist(ctx context.Context, playlist *usecaseModel.CreatePlaylistRequest) (*usecaseModel.Playlist, error) <span class="cov1" title="1">{
        repoCreatePlaylistRequest := model.CreatePlaylistRequestFromUsecaseToRepository(playlist)
        repoPlaylist, err := u.playlistRepo.CreatePlaylist(ctx, repoCreatePlaylistRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.PlaylistFromRepositoryToUsecase(repoPlaylist), nil</span>
}

func (u *PlaylistUsecase) UploadPlaylistThumbnail(ctx context.Context, playlist *usecaseModel.UploadPlaylistThumbnailRequest) (string, error) <span class="cov1" title="1">{
        thumbnail, err := u.s3Repo.UploadThumbnail(ctx, playlist.Thumbnail, playlist.Title)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return thumbnail, nil</span>
}

func (u *PlaylistUsecase) GetCombinedPlaylistsByUserID(ctx context.Context, request *usecaseModel.GetCombinedPlaylistsByUserIDRequest) (*usecaseModel.PlaylistList, error) <span class="cov1" title="1">{
        repoPlaylistList, err := u.playlistRepo.GetCombinedPlaylistsByUserID(ctx, request.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.PlaylistListFromRepositoryToUsecase(repoPlaylistList), nil</span>
}

func (u *PlaylistUsecase) AddTrackToPlaylist(ctx context.Context, request *usecaseModel.AddTrackToPlaylistRequest) error <span class="cov1" title="1">{
        repoRequest := model.AddTrackToPlaylistRequestFromUsecaseToRepository(request)
        err := u.playlistRepo.AddTrackToPlaylist(ctx, repoRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *PlaylistUsecase) RemoveTrackFromPlaylist(ctx context.Context, request *usecaseModel.RemoveTrackFromPlaylistRequest) error <span class="cov1" title="1">{
        repoRequest := model.RemoveTrackFromPlaylistRequestFromUsecaseToRepository(request)
        err := u.playlistRepo.RemoveTrackFromPlaylist(ctx, repoRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *PlaylistUsecase) GetPlaylistTrackIds(ctx context.Context, request *usecaseModel.GetPlaylistTrackIdsRequest) ([]int64, error) <span class="cov2" title="2">{
        repoPlaylist, err := u.playlistRepo.GetPlaylistByID(ctx, request.PlaylistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">if repoPlaylist.UserID != request.UserID &amp;&amp; !repoPlaylist.IsPublic </span><span class="cov1" title="1">{
                return nil, playlistErrors.ErrPlaylistPermissionDenied
        }</span>

        <span class="cov1" title="1">repoRequest := model.GetPlaylistTrackIdsRequestFromUsecaseToRepository(request)
        trackIds, err := u.playlistRepo.GetPlaylistTrackIds(ctx, repoRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return trackIds, nil</span>
}

func (u *PlaylistUsecase) UpdatePlaylist(ctx context.Context, request *usecaseModel.UpdatePlaylistRequest) (*usecaseModel.Playlist, error) <span class="cov4" title="3">{
        logger := loggerPkg.LoggerFromContext(ctx)
        repoRequest := model.UpdatePlaylistRequestFromUsecaseToRepository(request)

        playlist, err := u.playlistRepo.GetPlaylistByID(ctx, request.PlaylistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="3">if playlist.UserID != request.UserID </span><span class="cov1" title="1">{
                logger.Warn("playlist permission denied", "playlist_id", request.PlaylistID, "user_id", request.UserID)
                return nil, playlistErrors.ErrPlaylistPermissionDenied
        }</span>

        <span class="cov2" title="2">repoPlaylist, err := u.playlistRepo.UpdatePlaylist(ctx, repoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.PlaylistFromRepositoryToUsecase(repoPlaylist), nil</span>
}

func (u *PlaylistUsecase) GetPlaylistByID(ctx context.Context, request *usecaseModel.GetPlaylistByIDRequest) (*usecaseModel.PlaylistWithIsLiked, error) <span class="cov1" title="1">{
        playlist, err := u.playlistRepo.GetPlaylistByID(ctx, request.PlaylistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if playlist.UserID != request.UserID &amp;&amp; !playlist.IsPublic </span><span class="cov0" title="0">{
                return nil, playlistErrors.ErrPlaylistPermissionDenied
        }</span>

        <span class="cov1" title="1">repoPlaylistWithIsLiked, err := u.playlistRepo.GetPlaylistWithIsLikedByID(ctx, request.PlaylistID, request.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.PlaylistWithIsLikedFromRepositoryToUsecase(repoPlaylistWithIsLiked), nil</span>
}

func (u *PlaylistUsecase) RemovePlaylist(ctx context.Context, request *usecaseModel.RemovePlaylistRequest) error <span class="cov4" title="3">{
        playlist, err := u.playlistRepo.GetPlaylistByID(ctx, request.PlaylistID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov2" title="2">if playlist.UserID != request.UserID </span><span class="cov1" title="1">{
                return playlistErrors.ErrPlaylistPermissionDenied
        }</span>

        <span class="cov1" title="1">repoRequest := model.RemovePlaylistRequestFromUsecaseToRepository(request)
        err = u.playlistRepo.RemovePlaylist(ctx, repoRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *PlaylistUsecase) GetPlaylistsToAdd(ctx context.Context, request *usecaseModel.GetPlaylistsToAddRequest) (*usecaseModel.GetPlaylistsToAddResponse, error) <span class="cov2" title="2">{
        repoRequest := model.GetPlaylistsToAddRequestFromUsecaseToRepository(request)
        repoResponse, err := u.playlistRepo.GetPlaylistsToAdd(ctx, repoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.GetPlaylistsToAddResponseFromRepositoryToUsecase(repoResponse), nil</span>
}

func (u *PlaylistUsecase) UpdatePlaylistsPublisityByUserID(ctx context.Context, request *usecaseModel.UpdatePlaylistsPublisityByUserIDRequest) error <span class="cov2" title="2">{
        repoRequest := model.UpdatePlaylistsPublisityByUserIDRequestFromUsecaseToRepository(request)
        err := u.playlistRepo.UpdatePlaylistsPublisityByUserID(ctx, repoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *PlaylistUsecase) LikePlaylist(ctx context.Context, request *usecaseModel.LikePlaylistRequest) error <span class="cov4" title="4">{
        repoRequest := model.LikePlaylistRequestFromUsecaseToRepository(request)
        if request.IsLike </span><span class="cov2" title="2">{
                err := u.playlistRepo.LikePlaylist(ctx, repoRequest)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov2" title="2">err := u.playlistRepo.UnlikePlaylist(ctx, repoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *PlaylistUsecase) GetProfilePlaylists(ctx context.Context, request *usecaseModel.GetProfilePlaylistsRequest) (*usecaseModel.GetProfilePlaylistsResponse, error) <span class="cov2" title="2">{
        repoRequest := model.GetProfilePlaylistsRequestFromUsecaseToRepository(request)
        repoResponse, err := u.playlistRepo.GetProfilePlaylists(ctx, repoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.GetProfilePlaylistsResponseFromRepositoryToUsecase(repoResponse), nil</span>
}

func (u *PlaylistUsecase) SearchPlaylists(ctx context.Context, request *usecaseModel.SearchPlaylistsRequest) (*usecaseModel.PlaylistList, error) <span class="cov2" title="2">{
        repoRequest := model.SearchPlaylistsRequestFromUsecaseToRepository(request)
        repoResponse, err := u.playlistRepo.SearchPlaylists(ctx, repoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.PlaylistListFromRepositoryToUsecase(repoResponse), nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package model

import (
        "bytes"

        protoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/playlist"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model/repository"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/playlist/model/usecase"
)

func CreatePlaylistRequestFromProtoToUsecase(proto *protoModel.CreatePlaylistRequest) *usecaseModel.CreatePlaylistRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.CreatePlaylistRequest{
                Title:     proto.GetTitle(),
                UserID:    proto.GetUserId(),
                Thumbnail: proto.GetThumbnail(),
                IsPublic:  proto.GetIsPublic(),
        }
}</span>

func CreatePlaylistRequestFromUsecaseToRepository(usecase *usecaseModel.CreatePlaylistRequest) *repoModel.CreatePlaylistRequest <span class="cov1" title="1">{
        return &amp;repoModel.CreatePlaylistRequest{
                Title:     usecase.Title,
                UserID:    usecase.UserID,
                Thumbnail: usecase.Thumbnail,
                IsPublic:  usecase.IsPublic,
        }
}</span>

func PlaylistFromRepositoryToProto(repo *repoModel.Playlist) *protoModel.Playlist <span class="cov1" title="1">{
        return &amp;protoModel.Playlist{
                Id:        repo.ID,
                Title:     repo.Title,
                Thumbnail: repo.Thumbnail,
        }
}</span>

func PlaylistFromUsecaseToProto(usecase *usecaseModel.Playlist) *protoModel.Playlist <span class="cov10" title="8">{
        return &amp;protoModel.Playlist{
                Id:        usecase.ID,
                Title:     usecase.Title,
                Thumbnail: usecase.Thumbnail,
                UserId:    usecase.UserID,
        }
}</span>

func PlaylistFromRepositoryToUsecase(repo *repoModel.Playlist) *usecaseModel.Playlist <span class="cov10" title="8">{
        return &amp;usecaseModel.Playlist{
                ID:        repo.ID,
                Title:     repo.Title,
                Thumbnail: repo.Thumbnail,
                UserID:    repo.UserID,
        }
}</span>

func UploadPlaylistThumbnailRequestFromProtoToUsecase(proto *protoModel.UploadPlaylistThumbnailRequest) *usecaseModel.UploadPlaylistThumbnailRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.UploadPlaylistThumbnailRequest{
                Title:     proto.GetTitle(),
                Thumbnail: bytes.NewBuffer(proto.GetThumbnail()),
        }
}</span>

func GetCombinedPlaylistsByUserIDRequestFromProtoToUsecase(proto *protoModel.GetCombinedPlaylistsByUserIDRequest) *usecaseModel.GetCombinedPlaylistsByUserIDRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.GetCombinedPlaylistsByUserIDRequest{
                UserID: proto.GetUserId(),
        }
}</span>

func PlaylistsFromRepositoryToUsecase(repo []*repoModel.Playlist) []*usecaseModel.Playlist <span class="cov4" title="2">{
        usecase := make([]*usecaseModel.Playlist, len(repo))
        for i, playlist := range repo </span><span class="cov7" title="4">{
                usecase[i] = PlaylistFromRepositoryToUsecase(playlist)
        }</span>
        <span class="cov4" title="2">return usecase</span>
}

func PlaylistListFromRepositoryToUsecase(repo *repoModel.PlaylistList) *usecaseModel.PlaylistList <span class="cov1" title="1">{
        return &amp;usecaseModel.PlaylistList{
                Playlists: PlaylistsFromRepositoryToUsecase(repo.Playlists),
        }
}</span>

func PlaylistsFromUsecaseToProto(usecase []*usecaseModel.Playlist) []*protoModel.Playlist <span class="cov4" title="2">{
        proto := make([]*protoModel.Playlist, len(usecase))
        for i, playlist := range usecase </span><span class="cov7" title="4">{
                proto[i] = PlaylistFromUsecaseToProto(playlist)
        }</span>
        <span class="cov4" title="2">return proto</span>
}

func PlaylistListFromUsecaseToProto(usecase *usecaseModel.PlaylistList) *protoModel.PlaylistList <span class="cov1" title="1">{
        return &amp;protoModel.PlaylistList{
                Playlists: PlaylistsFromUsecaseToProto(usecase.Playlists),
        }
}</span>

func AddTrackToPlaylistRequestFromUsecaseToRepository(usecase *usecaseModel.AddTrackToPlaylistRequest) *repoModel.AddTrackToPlaylistRequest <span class="cov1" title="1">{
        return &amp;repoModel.AddTrackToPlaylistRequest{
                UserID:     usecase.UserID,
                PlaylistID: usecase.PlaylistID,
                TrackID:    usecase.TrackID,
        }
}</span>

func RemoveTrackFromPlaylistRequestFromUsecaseToRepository(usecase *usecaseModel.RemoveTrackFromPlaylistRequest) *repoModel.RemoveTrackFromPlaylistRequest <span class="cov1" title="1">{
        return &amp;repoModel.RemoveTrackFromPlaylistRequest{
                UserID:     usecase.UserID,
                PlaylistID: usecase.PlaylistID,
                TrackID:    usecase.TrackID,
        }
}</span>

func AddTrackToPlaylistRequestFromProtoToUsecase(proto *protoModel.AddTrackToPlaylistRequest) *usecaseModel.AddTrackToPlaylistRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.AddTrackToPlaylistRequest{
                UserID:     proto.GetUserId(),
                PlaylistID: proto.GetPlaylistId(),
                TrackID:    proto.GetTrackId(),
        }
}</span>

func RemoveTrackFromPlaylistRequestFromProtoToUsecase(proto *protoModel.RemoveTrackFromPlaylistRequest) *usecaseModel.RemoveTrackFromPlaylistRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.RemoveTrackFromPlaylistRequest{
                UserID:     proto.GetUserId(),
                PlaylistID: proto.GetPlaylistId(),
                TrackID:    proto.GetTrackId(),
        }
}</span>

func GetPlaylistTrackIdsRequestFromProtoToUsecase(proto *protoModel.GetPlaylistTrackIdsRequest) *usecaseModel.GetPlaylistTrackIdsRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.GetPlaylistTrackIdsRequest{
                UserID:     proto.GetUserId(),
                PlaylistID: proto.GetPlaylistId(),
        }
}</span>

func GetPlaylistTrackIdsRequestFromUsecaseToRepository(usecase *usecaseModel.GetPlaylistTrackIdsRequest) *repoModel.GetPlaylistTrackIdsRequest <span class="cov1" title="1">{
        return &amp;repoModel.GetPlaylistTrackIdsRequest{
                UserID:     usecase.UserID,
                PlaylistID: usecase.PlaylistID,
        }
}</span>

func UpdatePlaylistRequestFromProtoToUsecase(proto *protoModel.UpdatePlaylistRequest) *usecaseModel.UpdatePlaylistRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.UpdatePlaylistRequest{
                UserID:     proto.GetUserId(),
                PlaylistID: proto.GetId(),
                Title:      proto.GetTitle(),
                Thumbnail:  proto.GetThumbnail(),
        }
}</span>

func UpdatePlaylistRequestFromUsecaseToRepository(usecase *usecaseModel.UpdatePlaylistRequest) *repoModel.UpdatePlaylistRequest <span class="cov1" title="1">{
        return &amp;repoModel.UpdatePlaylistRequest{
                UserID:     usecase.UserID,
                PlaylistID: usecase.PlaylistID,
                Title:      usecase.Title,
                Thumbnail:  usecase.Thumbnail,
        }
}</span>

func GetPlaylistByIDRequestFromProtoToUsecase(proto *protoModel.GetPlaylistByIDRequest) *usecaseModel.GetPlaylistByIDRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.GetPlaylistByIDRequest{
                UserID:     proto.GetUserId(),
                PlaylistID: proto.GetId(),
        }
}</span>

func RemovePlaylistRequestFromProtoToUsecase(proto *protoModel.RemovePlaylistRequest) *usecaseModel.RemovePlaylistRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.RemovePlaylistRequest{
                UserID:     proto.GetUserId(),
                PlaylistID: proto.GetPlaylistId(),
        }
}</span>

func RemovePlaylistRequestFromUsecaseToRepository(usecase *usecaseModel.RemovePlaylistRequest) *repoModel.RemovePlaylistRequest <span class="cov1" title="1">{
        return &amp;repoModel.RemovePlaylistRequest{
                UserID:     usecase.UserID,
                PlaylistID: usecase.PlaylistID,
        }
}</span>

func GetPlaylistsToAddRequestFromUsecaseToRepository(usecase *usecaseModel.GetPlaylistsToAddRequest) *repoModel.GetPlaylistsToAddRequest <span class="cov1" title="1">{
        return &amp;repoModel.GetPlaylistsToAddRequest{
                UserID:  usecase.UserID,
                TrackID: usecase.TrackID,
        }
}</span>

func PlaylistWithIsIncludedTrackFromRepositoryToUsecase(repo *repoModel.PlaylistWithIsIncludedTrack) *usecaseModel.PlaylistWithIsIncludedTrack <span class="cov4" title="2">{
        return &amp;usecaseModel.PlaylistWithIsIncludedTrack{
                Playlist:   PlaylistFromRepositoryToUsecase(repo.Playlist),
                IsIncluded: repo.IsIncluded,
        }
}</span>

func PlaylistsFromRepositoryToUsecaseWithIsIncludedTrack(repo []*repoModel.PlaylistWithIsIncludedTrack) []*usecaseModel.PlaylistWithIsIncludedTrack <span class="cov1" title="1">{
        usecase := make([]*usecaseModel.PlaylistWithIsIncludedTrack, len(repo))
        for i, playlist := range repo </span><span class="cov1" title="1">{
                usecase[i] = PlaylistWithIsIncludedTrackFromRepositoryToUsecase(playlist)
        }</span>
        <span class="cov1" title="1">return usecase</span>
}

func GetPlaylistsToAddResponseFromRepositoryToUsecase(repo *repoModel.GetPlaylistsToAddResponse) *usecaseModel.GetPlaylistsToAddResponse <span class="cov1" title="1">{
        return &amp;usecaseModel.GetPlaylistsToAddResponse{
                Playlists: PlaylistsFromRepositoryToUsecaseWithIsIncludedTrack(repo.Playlists),
        }
}</span>

func GetPlaylistsToAddResponseFromUsecaseToProto(usecase *usecaseModel.GetPlaylistsToAddResponse) *protoModel.GetPlaylistsToAddResponse <span class="cov1" title="1">{
        return &amp;protoModel.GetPlaylistsToAddResponse{
                Playlists: PlaylistsFromUsecaseToProtoWithIsIncludedTrack(usecase.Playlists),
        }
}</span>

func GetPlaylistsToAddRequestFromProtoToUsecase(proto *protoModel.GetPlaylistsToAddRequest) *usecaseModel.GetPlaylistsToAddRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.GetPlaylistsToAddRequest{
                UserID:  proto.GetUserId(),
                TrackID: proto.GetTrackId(),
        }
}</span>

func PlaylistWithIsIncludedTrackFromUsecaseToProto(usecase *usecaseModel.PlaylistWithIsIncludedTrack) *protoModel.PlaylistWithIsIncludedTrack <span class="cov4" title="2">{
        return &amp;protoModel.PlaylistWithIsIncludedTrack{
                Playlist:        PlaylistFromUsecaseToProto(usecase.Playlist),
                IsIncludedTrack: usecase.IsIncluded,
        }
}</span>

func PlaylistsFromUsecaseToProtoWithIsIncludedTrack(usecase []*usecaseModel.PlaylistWithIsIncludedTrack) []*protoModel.PlaylistWithIsIncludedTrack <span class="cov1" title="1">{
        proto := make([]*protoModel.PlaylistWithIsIncludedTrack, len(usecase))
        for i, playlist := range usecase </span><span class="cov1" title="1">{
                proto[i] = PlaylistWithIsIncludedTrackFromUsecaseToProto(playlist)
        }</span>
        <span class="cov1" title="1">return proto</span>
}

func UpdatePlaylistsPublisityByUserIDRequestFromProtoToUsecase(proto *protoModel.UpdatePlaylistsPublisityByUserIDRequest) *usecaseModel.UpdatePlaylistsPublisityByUserIDRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.UpdatePlaylistsPublisityByUserIDRequest{
                UserID:   proto.GetUserId(),
                IsPublic: proto.GetIsPublic(),
        }
}</span>

func UpdatePlaylistsPublisityByUserIDRequestFromUsecaseToRepository(usecase *usecaseModel.UpdatePlaylistsPublisityByUserIDRequest) *repoModel.UpdatePlaylistsPublisityByUserIDRequest <span class="cov1" title="1">{
        return &amp;repoModel.UpdatePlaylistsPublisityByUserIDRequest{
                UserID:   usecase.UserID,
                IsPublic: usecase.IsPublic,
        }
}</span>

func LikePlaylistRequestFromProtoToUsecase(proto *protoModel.LikePlaylistRequest) *usecaseModel.LikePlaylistRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.LikePlaylistRequest{
                UserID:     proto.GetUserId(),
                PlaylistID: proto.GetPlaylistId(),
                IsLike:     proto.GetIsLike(),
        }
}</span>

func LikePlaylistRequestFromUsecaseToRepository(usecase *usecaseModel.LikePlaylistRequest) *repoModel.LikePlaylistRequest <span class="cov1" title="1">{
        return &amp;repoModel.LikePlaylistRequest{
                UserID:     usecase.UserID,
                PlaylistID: usecase.PlaylistID,
        }
}</span>

func PlaylistWithIsLikedFromRepositoryToUsecase(repo *repoModel.PlaylistWithIsLiked) *usecaseModel.PlaylistWithIsLiked <span class="cov1" title="1">{
        return &amp;usecaseModel.PlaylistWithIsLiked{
                Playlist: PlaylistFromRepositoryToUsecase(repo.Playlist),
                IsLiked:  repo.IsLiked,
        }
}</span>

func PlaylistWithIsLikedFromUsecaseToProto(usecase *usecaseModel.PlaylistWithIsLiked) *protoModel.PlaylistWithIsLiked <span class="cov1" title="1">{
        return &amp;protoModel.PlaylistWithIsLiked{
                Playlist: PlaylistFromUsecaseToProto(usecase.Playlist),
                IsLiked:  usecase.IsLiked,
        }
}</span>

func GetProfilePlaylistsRequestFromUsecaseToRepository(usecase *usecaseModel.GetProfilePlaylistsRequest) *repoModel.GetProfilePlaylistsRequest <span class="cov1" title="1">{
        return &amp;repoModel.GetProfilePlaylistsRequest{
                UserID: usecase.UserID,
        }
}</span>

func GetProfilePlaylistsResponseFromRepositoryToUsecase(repo *repoModel.GetProfilePlaylistsResponse) *usecaseModel.GetProfilePlaylistsResponse <span class="cov1" title="1">{
        return &amp;usecaseModel.GetProfilePlaylistsResponse{
                Playlists: PlaylistsFromRepositoryToUsecase(repo.Playlists),
        }
}</span>

func GetProfilePlaylistsRequestFromProtoToUsecase(proto *protoModel.GetProfilePlaylistsRequest) *usecaseModel.GetProfilePlaylistsRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.GetProfilePlaylistsRequest{
                UserID: proto.GetUserId(),
        }
}</span>

func GetProfilePlaylistsResponseFromUsecaseToProto(usecase *usecaseModel.GetProfilePlaylistsResponse) *protoModel.GetProfilePlaylistsResponse <span class="cov1" title="1">{
        return &amp;protoModel.GetProfilePlaylistsResponse{
                Playlists: PlaylistsFromUsecaseToProto(usecase.Playlists),
        }
}</span>

func SearchPlaylistsRequestFromProtoToUsecase(proto *protoModel.SearchPlaylistsRequest) *usecaseModel.SearchPlaylistsRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.SearchPlaylistsRequest{
                UserID: proto.GetUserId(),
                Query:  proto.GetQuery(),
        }
}</span>

func SearchPlaylistsRequestFromUsecaseToRepository(usecase *usecaseModel.SearchPlaylistsRequest) *repoModel.SearchPlaylistsRequest <span class="cov1" title="1">{
        return &amp;repoModel.SearchPlaylistsRequest{
                UserID: usecase.UserID,
                Query:  usecase.Query,
        }
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package errors

import (
        "fmt"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type PlaylistError struct {
        Code    codes.Code
        Message string
}

func (e *PlaylistError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func (e *PlaylistError) GRPCStatus() *status.Status <span class="cov0" title="0">{
        return status.New(e.Code, e.Message)
}</span>

func NewNotFoundError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;PlaylistError{
                Code:    codes.NotFound,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewInternalError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;PlaylistError{
                Code:    codes.Internal,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewBadRequestError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;PlaylistError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewAlreadyExistsError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;PlaylistError{
                Code:    codes.AlreadyExists,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewPermissionDeniedError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;PlaylistError{
                Code:    codes.PermissionDenied,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

var (
        ErrPlaylistNotFound         = NewNotFoundError("playlist not found")
        ErrPlaylistPermissionDenied = NewPermissionDeniedError("user does not have permission to update this playlist")
        ErrUnsupportedImageFormat   = NewBadRequestError("unsupported image format: only JPEG and PNG are allowed")
        ErrImageTooBig              = NewBadRequestError("image size exceeds 5MB limit")
        ErrFailedToParseImage       = NewInternalError("failed to parse image")
        ErrFailedToUploadImage      = NewInternalError("failed to upload image")
        ErrPlaylistDuplicate        = NewAlreadyExistsError("playlist with this title by you already exists")
        ErrPlaylistTrackNotFound    = NewNotFoundError("track not found in playlist")
        ErrPlaylistTrackDuplicate   = NewAlreadyExistsError("track already in playlist")
)
</pre>
		
		<pre class="file" id="file71" style="display: none">package main

import (
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/postgres"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/s3"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/interceptors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/repository"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/usecase"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.uber.org/zap"
        "google.golang.org/grpc"

        trackProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/track"
)

func main() <span class="cov0" title="0">{
        logger, err := loggerPkg.NewZapLogger()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creating logger:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error syncing logger:", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error loading config:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">port := fmt.Sprintf(":%d", cfg.Services.TrackService.Port)
        conn, err := net.Listen("tcp", port)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Can't start album service:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">reg := prometheus.NewRegistry()
        metrics := metrics.NewMetrics(reg, "track_service")

        accessInterceptor := interceptors.NewAccessInterceptor(logger, metrics)

        server := grpc.NewServer(
                grpc.UnaryInterceptor(accessInterceptor.UnaryServerInterceptor()),
                grpc.MaxRecvMsgSize(50*1024*1024), // 50 MB
                grpc.MaxSendMsgSize(50*1024*1024), // 50 MB
        )

        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
                address := fmt.Sprintf(":%d", cfg.Prometheus.TrackPort)
                logger.Info(fmt.Sprintf("Serving metrics responds on port %d", cfg.Prometheus.TrackPort))
                if err := http.ListenAndServe(address, nil); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Error starting metrics server", zap.String("error", err.Error()))
                }</span>
        }()

        <span class="cov0" title="0">postgresPool, err := postgres.ConnectPostgres(cfg.Postgres)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error connecting to postgres:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := postgresPool.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing Postgres:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">s3, err := s3.InitS3(cfg.S3)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initializing S3:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">trackRepository := repository.NewTrackPostgresRepository(postgresPool, metrics)
        trackS3Repository := repository.NewTrackS3Repository(s3, cfg.S3.S3TracksBucket, cfg.S3.S3Duration, metrics)
        trackUsecase := usecase.NewTrackUsecase(trackRepository, trackS3Repository)
        trackService := delivery.NewTrackService(trackUsecase)
        trackProto.RegisterTrackServiceServer(server, trackService)

        logger.Info("Track service started", zap.String("port", port))

        err = server.Serve(conn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error starting track service:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)
        &lt;-c

        server.GracefulStop()
        logger.Info("Track service stopped")</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package delivery

import (
        "context"
        "fmt"

        trackProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/track"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model"
        "google.golang.org/protobuf/types/known/emptypb"
)

type TrackService struct {
        trackProto.UnimplementedTrackServiceServer
        trackUsecase domain.Usecase
}

func NewTrackService(trackUsecase domain.Usecase) trackProto.TrackServiceServer <span class="cov0" title="0">{
        return &amp;TrackService{
                trackUsecase: trackUsecase,
        }
}</span>

func (s *TrackService) GetAllTracks(ctx context.Context, req *trackProto.UserIDWithFilters) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.GetAllTracks(ctx, model.FiltersFromProtoToUsecase(req.Filters), req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for i := range tracks </span><span class="cov0" title="0">{
                fmt.Println(tracks[i].Title)
                fmt.Println(tracks[i].Thumbnail)
                fmt.Println(tracks[i].Duration)
                fmt.Println(tracks[i].AlbumID)
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) GetTrackByID(ctx context.Context, req *trackProto.TrackIDWithUserID) (*trackProto.TrackDetailed, error) <span class="cov0" title="0">{
        track, err := s.trackUsecase.GetTrackByID(ctx, req.TrackId.Id, req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackDetailedFromUsecaseToProto(track), nil</span>
}

func (s *TrackService) CreateStream(ctx context.Context, req *trackProto.TrackStreamCreateData) (*trackProto.StreamID, error) <span class="cov0" title="0">{
        streamID, err := s.trackUsecase.CreateStream(ctx, model.TrackStreamCreateDataFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.StreamIDFromUsecaseToProto(streamID), nil</span>
}

func (s *TrackService) UpdateStreamDuration(ctx context.Context, req *trackProto.TrackStreamUpdateData) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.trackUsecase.UpdateStreamDuration(ctx, model.TrackStreamUpdateDataFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *TrackService) GetLastListenedTracks(ctx context.Context, req *trackProto.UserIDWithFilters) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.GetLastListenedTracks(ctx, req.UserId.Id, model.FiltersFromProtoToUsecase(req.Filters))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) GetTracksByIDs(ctx context.Context, req *trackProto.TrackIDList) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        ids, userID := model.TrackIDListFromProtoToUsecase(req)
        tracks, err := s.trackUsecase.GetTracksByIDs(ctx, ids, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) GetTracksByIDsFiltered(ctx context.Context, req *trackProto.TrackIDListWithFilters) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        ids, filters, userID := model.TrackIDListWithFiltersFromProtoToUsecase(req)
        tracks, err := s.trackUsecase.GetTracksByIDsFiltered(ctx, ids, filters, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) GetAlbumIDByTrackID(ctx context.Context, req *trackProto.TrackID) (*trackProto.AlbumID, error) <span class="cov0" title="0">{
        albumID, err := s.trackUsecase.GetAlbumIDByTrackID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;trackProto.AlbumID{Id: albumID}, nil</span>
}

func (s *TrackService) GetTracksByAlbumID(ctx context.Context, req *trackProto.AlbumIDWithUserID) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.GetTracksByAlbumID(ctx, req.AlbumId.Id, req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) GetMinutesListenedByUserID(ctx context.Context, req *trackProto.UserID) (*trackProto.MinutesListened, error) <span class="cov0" title="0">{
        minutesListened, err := s.trackUsecase.GetMinutesListenedByUserID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;trackProto.MinutesListened{Minutes: minutesListened}, nil</span>
}

func (s *TrackService) GetTracksListenedByUserID(ctx context.Context, req *trackProto.UserID) (*trackProto.TracksListened, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.GetTracksListenedByUserID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;trackProto.TracksListened{Tracks: tracks}, nil</span>
}

func (s *TrackService) LikeTrack(ctx context.Context, req *trackProto.LikeRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.trackUsecase.LikeTrack(ctx, model.LikeRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *TrackService) GetFavoriteTracks(ctx context.Context, req *trackProto.FavoriteRequest) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.GetFavoriteTracks(ctx, model.FavoriteRequestFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) SearchTracks(ctx context.Context, req *trackProto.Query) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.SearchTracks(ctx, req.Query, req.UserId.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) AddTracksToAlbum(ctx context.Context, req *trackProto.TracksListWithAlbumID) (*trackProto.TrackIdsList, error) <span class="cov0" title="0">{
        tracksList := model.TracksListWithAlbumIDFromProtoToUsecase(req)
        trackIDs, err := s.trackUsecase.AddTracksToAlbum(ctx, tracksList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackIdsListFromUsecaseToProto(trackIDs), nil</span>
}

func (s *TrackService) DeleteTracksByAlbumID(ctx context.Context, req *trackProto.AlbumID) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := s.trackUsecase.DeleteTracksByAlbumID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *TrackService) GetMostLikedTracks(ctx context.Context, req *trackProto.UserID) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.GetMostLikedTracks(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) GetMostRecentTracks(ctx context.Context, req *trackProto.UserID) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.GetMostRecentTracks(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) GetMostListenedLastMonthTracks(ctx context.Context, req *trackProto.UserID) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.GetMostListenedLastMonthTracks(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}

func (s *TrackService) GetMostLikedLastWeekTracks(ctx context.Context, req *trackProto.UserID) (*trackProto.TrackList, error) <span class="cov0" title="0">{
        tracks, err := s.trackUsecase.GetMostLikedLastWeekTracks(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromUsecaseToProto(tracks), nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/domain"
        trackErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model/errors"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model/repository"
        "github.com/lib/pq"
        "go.uber.org/zap"
)

const (
        GetAllTracksQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                LEFT JOIN track_stats ts ON t.id = ts.track_id
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $3
                ORDER BY ts.listeners_count DESC, t.id DESC
                LIMIT $1 OFFSET $2
        `
        GetTrackByIDQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, t.file_url, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $2
                WHERE t.id = $1
        `

        CreateStreamQuery = `
                INSERT INTO track_stream (track_id, user_id) 
                VALUES ($1, $2)
                RETURNING id
        `

        GetStreamByIDQuery = `
                 SELECT id, user_id, track_id, duration
                FROM track_stream
                 WHERE id = $1
        `

        UpdateStreamDurationQuery = `
                UPDATE track_stream
                SET duration = $1
                WHERE id = $2
        `

        GetStreamsByUserIDQuery = `
                WITH latest_streams AS (
                        SELECT DISTINCT ON (track_id) id, user_id, track_id, duration, created_at
                        FROM track_stream
                        WHERE user_id = $1
                        ORDER BY track_id, created_at DESC, id DESC
                )
                SELECT id, user_id, track_id, duration
                FROM latest_streams
                ORDER BY created_at DESC, id DESC
                LIMIT $2 OFFSET $3
        `

        GetTracksByIDsQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $2
                WHERE t.id = ANY($1)
        `

        GetTracksByIDsFilteredQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                JOIN track_stats ts ON t.id = ts.track_id
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $4
                WHERE t.id = ANY($1)
                ORDER BY ts.listeners_count DESC, t.id DESC
                LIMIT $2 OFFSET $3
        `

        GetAlbumIDByTrackIDQuery = `
                SELECT album_id
                FROM track
                WHERE id = $1
        `

        GetTracksByAlbumIDQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $2
                WHERE t.album_id = $1
                ORDER BY position ASC
        `

        GetMinutesListenedByUserIDQuery = `
                SELECT COALESCE(SUM(duration) / 60, 0)
                FROM track_stream
                WHERE user_id = $1
        `

        GetTracksListenedByUserIDQuery = `
                SELECT COUNT(DISTINCT track_id)
                FROM track_stream
                WHERE user_id = $1
        `

        CheckTrackExistsQuery = `
                SELECT EXISTS(SELECT 1 FROM track WHERE id = $1)
        `

        LikeTrackQuery = `
                INSERT INTO favorite_track (track_id, user_id) VALUES ($1, $2) ON CONFLICT DO NOTHING
        `

        UnlikeTrackQuery = `
                DELETE FROM favorite_track WHERE track_id = $1 AND user_id = $2
        `

        GetFavoriteTracksQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft_req.user_id IS NOT NULL) AS is_favorite
                FROM track t
                JOIN favorite_track ft_prof ON t.id = ft_prof.track_id
                LEFT JOIN favorite_track ft_req ON t.id = ft_req.track_id AND ft_req.user_id = $1
                WHERE ft_prof.user_id = $2
                ORDER BY ft_prof.created_at DESC, t.id DESC
                LIMIT $3 OFFSET $4
        `

        SearchTracksQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $2
                WHERE t.search_vector @@ to_tsquery('multilingual', $1)
                   OR similarity(t.title_trgm, $3) &gt; 0.3
                ORDER BY 
                    CASE WHEN t.search_vector @@ to_tsquery('multilingual', $1) THEN 0 ELSE 1 END,
                    ts_rank(t.search_vector, to_tsquery('multilingual', $1)) DESC,
                    similarity(t.title_trgm, $3) DESC
        `

        AddTracksToAlbumQuery = `
                INSERT INTO track (title, thumbnail_url, duration, album_id, file_url)
                VALUES ($1, $2, $3, $4, $5)
        `
        DeleteTracksByAlbumIDQuery = `
                DELETE FROM track
                WHERE album_id = $1
`
        GetMostLikedTracksQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                LEFT JOIN track_stats ts ON t.id = ts.track_id
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $1
                ORDER BY ts.favorites_count DESC, t.id DESC
                LIMIT 20
        `

        GetMostRecentTracksQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $1
                ORDER BY t.created_at DESC, t.id DESC
                LIMIT 20
        `

        GetMostListenedLastMonthTracksQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                LEFT JOIN track_stats ts ON t.id = ts.track_id
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $1
                ORDER BY ts.listeners_count_last_month DESC, t.id DESC
                LIMIT 20
        `

        GetMostLikedLastWeekTracksQuery = `
                SELECT t.id, t.title, t.thumbnail_url, t.duration, t.album_id, (ft.user_id IS NOT NULL) AS is_favorite
                FROM track t
                LEFT JOIN track_stats ts ON t.id = ts.track_id
                LEFT JOIN favorite_track ft ON t.id = ft.track_id AND ft.user_id = $1
                ORDER BY ts.favorites_count_last_week DESC, t.id DESC
                LIMIT 20
        `
)

type TrackPostgresRepository struct {
        db      *sql.DB
        metrics *metrics.Metrics
}

func NewTrackPostgresRepository(db *sql.DB, metrics *metrics.Metrics) domain.Repository <span class="cov10" title="38">{
        return &amp;TrackPostgresRepository{db: db, metrics: metrics}
}</span>

func (r *TrackPostgresRepository) GetAllTracks(ctx context.Context, filters *repoModel.TrackFilters, userID int64) ([]*repoModel.Track, error) <span class="cov3" title="3">{
        start := time.Now()

        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting all tracks from db", zap.Any("filters", filters), zap.String("query", GetAllTracksQuery))

        stmt, err := r.db.PrepareContext(ctx, GetAllTracksQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAllTracks").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">rows, err := stmt.QueryContext(ctx, filters.Pagination.Limit, filters.Pagination.Offset, userID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAllTracks").Inc()
                logger.Error("failed to get all tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get all tracks: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">tracks := make([]*repoModel.Track, 0)
        for rows.Next() </span><span class="cov3" title="3">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetAllTracks").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov2" title="2">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAllTracks").Inc()
                logger.Error("failed to get all tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get all tracks: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAllTracks").Observe(duration)
        return tracks, nil</span>
}

func (r *TrackPostgresRepository) GetTrackByID(ctx context.Context, id int64, userID int64) (*repoModel.TrackWithFileKey, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting track by id from db", zap.Int64("id", id), zap.String("query", GetTrackByIDQuery))

        stmt, err := r.db.PrepareContext(ctx, GetTrackByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTrackByID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>

        <span class="cov2" title="2">var trackObject repoModel.TrackWithFileKey
        err = stmt.QueryRowContext(ctx, id, userID).Scan(&amp;trackObject.ID, &amp;trackObject.Title, &amp;trackObject.Thumbnail, &amp;trackObject.Duration, &amp;trackObject.AlbumID, &amp;trackObject.FileKey, &amp;trackObject.IsFavorite)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTrackByID").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        logger.Error("track not found", zap.Error(err))
                        return nil, trackErrors.ErrTrackNotFound
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get track by id", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get track by id: %v", err)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetTrackByID").Observe(duration)
        return &amp;trackObject, nil</span>
}

func (r *TrackPostgresRepository) CreateStream(ctx context.Context, createData *repoModel.TrackStreamCreateData) (int64, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting to create stream in db", zap.Any("createData", createData), zap.String("query", CreateStreamQuery))

        stmt, err := r.db.PrepareContext(ctx, CreateStreamQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStream").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return 0, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var streamID int64
        err = stmt.QueryRowContext(ctx, createData.TrackID, createData.UserID).Scan(&amp;streamID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateStream").Inc()
                logger.Error("failed to create stream", zap.Error(err))
                return 0, trackErrors.NewInternalError("failed to create stream: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CreateStream").Observe(duration)
        return streamID, nil</span>
}

func (r *TrackPostgresRepository) GetStreamByID(ctx context.Context, id int64) (*repoModel.TrackStream, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting stream by id from db", zap.Int64("id", id), zap.String("query", GetStreamByIDQuery))

        stmt, err := r.db.PrepareContext(ctx, GetStreamByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetStreamByID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var stream repoModel.TrackStream
        err = stmt.QueryRowContext(ctx, id).Scan(&amp;stream.ID, &amp;stream.UserID, &amp;stream.TrackID, &amp;stream.Duration)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetStreamByID").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        logger.Error("stream not found", zap.Error(err))
                        return nil, trackErrors.ErrStreamNotFound
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get stream by id", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get stream by id: %v", err)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetStreamByID").Observe(duration)
        return &amp;stream, nil</span>
}

func (r *TrackPostgresRepository) UpdateStreamDuration(ctx context.Context, endedStream *repoModel.TrackStreamUpdateData) error <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting to update stream duration in db", zap.Any("endedStream", endedStream), zap.String("query", UpdateStreamDurationQuery))

        stmt, err := r.db.PrepareContext(ctx, UpdateStreamDurationQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateStreamDuration").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">result, err := stmt.ExecContext(ctx, endedStream.Duration, endedStream.StreamID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateStreamDuration").Inc()
                logger.Error("failed to update stream duration", zap.Error(err))
                return trackErrors.NewInternalError("failed to update stream duration: %v", err)
        }</span>

        <span class="cov2" title="2">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateStreamDuration").Inc()
                logger.Error("failed to get rows affected", zap.Error(err))
                return trackErrors.NewInternalError("failed to get rows affected: %v", err)
        }</span>

        <span class="cov2" title="2">if rows == 0 </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateStreamDuration").Inc()
                logger.Error("stream not found", zap.Error(trackErrors.ErrFailedToUpdateStreamDuration))
                return trackErrors.ErrFailedToUpdateStreamDuration
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UpdateStreamDuration").Observe(duration)
        return nil</span>
}

func (r *TrackPostgresRepository) GetStreamsByUserID(ctx context.Context, userID int64, filters *repoModel.TrackFilters) ([]*repoModel.TrackStream, error) <span class="cov3" title="3">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting streams by user id from db", zap.Int64("userID", userID), zap.String("query", GetStreamsByUserIDQuery))

        stmt, err := r.db.PrepareContext(ctx, GetStreamsByUserIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetStreamsByUserID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">rows, err := stmt.QueryContext(ctx, userID, filters.Pagination.Limit, filters.Pagination.Offset)

        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetStreamsByUserID").Inc()
                logger.Error("failed to get streams by user id", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get streams by user id: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">streams := make([]*repoModel.TrackStream, 0)
        for rows.Next() </span><span class="cov3" title="3">{
                var stream repoModel.TrackStream
                err := rows.Scan(&amp;stream.ID, &amp;stream.UserID, &amp;stream.TrackID, &amp;stream.Duration)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetStreamsByUserID").Inc()
                        logger.Error("failed to scan stream", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan stream: %v", err)
                }</span>
                <span class="cov2" title="2">streams = append(streams, &amp;stream)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetStreamsByUserID").Inc()
                logger.Error("failed to get streams by user id", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get streams by user id: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetStreamsByUserID").Observe(duration)
        return streams, nil</span>
}

func (r *TrackPostgresRepository) GetTracksByIDs(ctx context.Context, ids []int64, userID int64) (map[int64]*repoModel.Track, error) <span class="cov3" title="3">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting tracks by ids from db", zap.Any("ids", ids), zap.String("query", GetTracksByIDsQuery))

        stmt, err := r.db.PrepareContext(ctx, GetTracksByIDsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksByIDs").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">rows, err := stmt.QueryContext(ctx, pq.Array(ids), userID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksByIDs").Inc()
                logger.Error("failed to get tracks by ids", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get tracks by ids: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">tracks := make(map[int64]*repoModel.Track)
        for rows.Next() </span><span class="cov3" title="3">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetTracksByIDs").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov2" title="2">tracks[track.ID] = &amp;track</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksByIDs").Inc()
                logger.Error("failed to get tracks by ids", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get tracks by ids: %v", err)
        }</span>

        <span class="cov1" title="1">if len(tracks) &gt; 0 &amp;&amp; len(tracks) &lt; len(ids) </span><span class="cov0" title="0">{
                missingIDs := make([]int64, 0)
                for _, id := range ids </span><span class="cov0" title="0">{
                        if _, ok := tracks[id]; !ok </span><span class="cov0" title="0">{
                                r.metrics.DatabaseErrors.WithLabelValues("GetTracksByIDs").Inc()
                                missingIDs = append(missingIDs, id)
                                logger.Error("failed to get tracks by ids", zap.Int64("id", id))
                        }</span>

                }
                <span class="cov0" title="0">if len(missingIDs) &gt; 0 </span><span class="cov0" title="0">{
                        logger.Warn("some tracks were not found", zap.Int64s("missing_ids", missingIDs))
                }</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetTracksByIDs").Observe(duration)
        return tracks, nil</span>
}

func (r *TrackPostgresRepository) GetTracksByIDsFiltered(ctx context.Context, ids []int64, filters *repoModel.TrackFilters, userID int64) ([]*repoModel.Track, error) <span class="cov3" title="3">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting tracks by ids from db", zap.Any("ids", ids), zap.String("query", GetTracksByIDsFilteredQuery))

        stmt, err := r.db.PrepareContext(ctx, GetTracksByIDsFilteredQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksByIDsFiltered").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">rows, err := stmt.QueryContext(ctx, pq.Array(ids), filters.Pagination.Limit, filters.Pagination.Offset, userID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksByIDsFiltered").Inc()
                logger.Error("failed to get tracks by ids", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get tracks by ids: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">tracks := make([]*repoModel.Track, 0)
        for rows.Next() </span><span class="cov3" title="3">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetTracksByIDsFiltered").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov2" title="2">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksByIDsFiltered").Inc()
                logger.Error("failed to get tracks by ids", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get tracks by ids: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetTracksByIDsFiltered").Observe(duration)
        return tracks, nil</span>
}

func (r *TrackPostgresRepository) GetAlbumIDByTrackID(ctx context.Context, id int64) (int64, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting album id by track id from db", zap.Int64("id", id), zap.String("query", GetAlbumIDByTrackIDQuery))

        stmt, err := r.db.PrepareContext(ctx, GetAlbumIDByTrackIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumIDByTrackID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return 0, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var albumID int64
        err = stmt.QueryRowContext(ctx, id).Scan(&amp;albumID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAlbumIDByTrackID").Inc()
                logger.Error("failed to get album id by track id", zap.Error(err))
                return 0, trackErrors.NewInternalError("failed to get album id by track id: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAlbumIDByTrackID").Observe(duration)
        return albumID, nil</span>
}

func (r *TrackPostgresRepository) GetTracksByAlbumID(ctx context.Context, id int64, userID int64) ([]*repoModel.Track, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting tracks by album id from db", zap.Int64("id", id), zap.String("query", GetTracksByAlbumIDQuery))

        stmt, err := r.db.PrepareContext(ctx, GetTracksByAlbumIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksByAlbumID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">rows, err := stmt.QueryContext(ctx, id, userID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksByAlbumID").Inc()
                logger.Error("failed to get tracks by album id", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get tracks by album id: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">tracks := make([]*repoModel.Track, 0)
        for rows.Next() </span><span class="cov2" title="2">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetTracksByAlbumID").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov2" title="2">tracks = append(tracks, &amp;track)</span>
        }
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetTracksByAlbumID").Observe(duration)
        return tracks, nil</span>
}

func (r *TrackPostgresRepository) GetMinutesListenedByUserID(ctx context.Context, userID int64) (int64, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting minutes listened by user id from db", zap.Int64("userID", userID), zap.String("query", GetMinutesListenedByUserIDQuery))

        stmt, err := r.db.PrepareContext(ctx, GetMinutesListenedByUserIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMinutesListenedByUserID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return 0, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var minutesListened int64
        err = stmt.QueryRowContext(ctx, userID).Scan(&amp;minutesListened)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMinutesListenedByUserID").Inc()
                logger.Error("failed to get minutes listened by user id", zap.Error(err))
                return 0, trackErrors.NewInternalError("failed to get minutes listened by user id: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetMinutesListenedByUserID").Observe(duration)
        return minutesListened, nil</span>
}

func (r *TrackPostgresRepository) GetTracksListenedByUserID(ctx context.Context, userID int64) (int64, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting tracks listened by user id from db", zap.Int64("userID", userID), zap.String("query", GetTracksListenedByUserIDQuery))

        stmt, err := r.db.PrepareContext(ctx, GetTracksListenedByUserIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksListenedByUserID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return 0, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var tracksListened int64
        err = stmt.QueryRowContext(ctx, userID).Scan(&amp;tracksListened)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetTracksListenedByUserID").Inc()
                logger.Error("failed to get tracks listened by user id", zap.Error(err))
                return 0, trackErrors.NewInternalError("failed to get tracks listened by user id: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetTracksListenedByUserID").Observe(duration)
        return tracksListened, nil</span>
}

func (r *TrackPostgresRepository) CheckTrackExists(ctx context.Context, trackID int64) (bool, error) <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting to check if track exists in db", zap.Int64("trackID", trackID), zap.String("query", CheckTrackExistsQuery))

        start := time.Now()

        stmt, err := r.db.PrepareContext(ctx, CheckTrackExistsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckTrackExists").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return false, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var exists bool
        err = stmt.QueryRowContext(ctx, trackID).Scan(&amp;exists)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckTrackExists").Inc()
                logger.Error("failed to check if track exists", zap.Error(err))
                return false, trackErrors.NewInternalError("failed to check if track exists: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CheckTrackExists").Observe(duration)
        return exists, nil</span>
}

func (r *TrackPostgresRepository) LikeTrack(ctx context.Context, likeRequest *repoModel.LikeRequest) error <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting to like track in db", zap.Any("likeRequest", likeRequest), zap.String("query", LikeTrackQuery))

        start := time.Now()

        stmt, err := r.db.PrepareContext(ctx, LikeTrackQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("LikeTrack").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, likeRequest.TrackID, likeRequest.UserID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("LikeTrack").Inc()
                logger.Error("failed to like track", zap.Error(err))
                return trackErrors.NewInternalError("failed to like track: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("LikeTrack").Observe(duration)
        return nil</span>
}

func (r *TrackPostgresRepository) UnlikeTrack(ctx context.Context, likeRequest *repoModel.LikeRequest) error <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting to unlike track in db", zap.Any("likeRequest", likeRequest), zap.String("query", UnlikeTrackQuery))

        start := time.Now()

        stmt, err := r.db.PrepareContext(ctx, UnlikeTrackQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UnlikeTrack").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, likeRequest.TrackID, likeRequest.UserID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("UnlikeTrack").Inc()
                logger.Error("failed to unlike track", zap.Error(err))
                return trackErrors.NewInternalError("failed to unlike track: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UnlikeTrack").Observe(duration)
        return nil</span>
}

func (r *TrackPostgresRepository) GetFavoriteTracks(ctx context.Context, favoriteRequest *repoModel.FavoriteRequest) ([]*repoModel.Track, error) <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting favorite tracks from db", zap.Any("favoriteRequest", favoriteRequest), zap.String("query", GetFavoriteTracksQuery))

        start := time.Now()

        stmt, err := r.db.PrepareContext(ctx, GetFavoriteTracksQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetFavoriteTracks").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">rows, err := stmt.QueryContext(ctx, favoriteRequest.RequestUserID, favoriteRequest.ProfileUserID, favoriteRequest.Filters.Pagination.Limit, favoriteRequest.Filters.Pagination.Offset)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetFavoriteTracks").Inc()
                logger.Error("failed to get favorite tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get favorite tracks: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">tracks := make([]*repoModel.Track, 0)
        for rows.Next() </span><span class="cov2" title="2">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetFavoriteTracks").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov2" title="2">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetFavoriteTracks").Inc()
                logger.Error("failed to get favorite tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get favorite tracks: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetFavoriteTracks").Observe(duration)
        return tracks, nil</span>
}

func (r *TrackPostgresRepository) SearchTracks(ctx context.Context, query string, userID int64) ([]*repoModel.Track, error) <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Searching tracks in db", zap.String("search query", query), zap.String("query", SearchTracksQuery))

        start := time.Now()

        stmt, err := r.db.PrepareContext(ctx, SearchTracksQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("SearchTracks").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">words := strings.Fields(query)
        for i, word := range words </span><span class="cov4" title="4">{
                words[i] = word + ":*"
        }</span>
        <span class="cov2" title="2">tsQueryString := strings.Join(words, " &amp; ")

        rows, err := stmt.QueryContext(ctx, tsQueryString, userID, query)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("SearchTracks").Inc()
                logger.Error("failed to search tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to search tracks: %v", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">var tracks []*repoModel.Track
        for rows.Next() </span><span class="cov2" title="2">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("SearchTracks").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov2" title="2">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("SearchTracks").Inc()
                logger.Error("failed to search tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to search tracks: %v", err)
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("SearchTracks").Observe(duration)

        return tracks, nil</span>
}

func (r *TrackPostgresRepository) AddTracksToAlbum(ctx context.Context, tracksList []*repoModel.Track) ([]int64, error) <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Adding tracks to album in db", zap.Any("tracksList", tracksList))

        start := time.Now()

        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("AddTracksToAlbum").Inc()
                logger.Error("failed to begin transaction", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to begin transaction: %v", err)
        }</span>

        <span class="cov0" title="0">valueStrings := make([]string, 0, len(tracksList))
        valueArgs := make([]interface{}, 0, len(tracksList)*6)

        for i, track := range tracksList </span><span class="cov0" title="0">{
                baseIndex := i * 6
                valueStrings = append(valueStrings, fmt.Sprintf("($%d, $%d, $%d, $%d, $%d, $%d)",
                        baseIndex+1, baseIndex+2, baseIndex+3, baseIndex+4, baseIndex+5, baseIndex+6))

                valueArgs = append(valueArgs,
                        track.Title,
                        track.Thumbnail,
                        track.Duration,
                        track.AlbumID,
                        fmt.Sprintf("%s.mp3", track.Title),
                        i+1)
        }</span>

        <span class="cov0" title="0">stmt := fmt.Sprintf("INSERT INTO track (title, thumbnail_url, duration, album_id, file_url, position) VALUES %s RETURNING id",
                strings.Join(valueStrings, ","))

        rows, err := tx.QueryContext(ctx, stmt, valueArgs...)
        if err != nil </span><span class="cov0" title="0">{
                err = tx.Rollback()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to rollback transaction", zap.Error(err))
                }</span>
                <span class="cov0" title="0">r.metrics.DatabaseErrors.WithLabelValues("AddTracksToAlbum").Inc()
                logger.Error("failed to insert tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to insert tracks: %v", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">var trackIDs []int64
        for rows.Next() </span><span class="cov0" title="0">{
                var id int64
                if err := rows.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                        err = tx.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to rollback transaction", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">r.metrics.DatabaseErrors.WithLabelValues("AddTracksToAlbum").Inc()
                        logger.Error("failed to scan track id", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track id: %v", err)</span>
                }
                <span class="cov0" title="0">trackIDs = append(trackIDs, id)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                err = tx.Rollback()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to rollback transaction", zap.Error(err))
                }</span>
                <span class="cov0" title="0">r.metrics.DatabaseErrors.WithLabelValues("AddTracksToAlbum").Inc()
                logger.Error("failed to iterate over result rows", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to iterate over result rows: %v", err)</span>
        }

        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("AddTracksToAlbum").Inc()
                logger.Error("failed to commit transaction", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to commit transaction: %v", err)
        }</span>

        <span class="cov0" title="0">_, err = r.db.ExecContext(ctx, "REFRESH MATERIALIZED VIEW CONCURRENTLY track_stats")
        if err != nil </span><span class="cov0" title="0">{
            logger.Warn("failed to refresh track_stats view, new tracks may not be visible in statistics for up to 1 hour", zap.Error(err))
        }</span>

        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("AddTracksToAlbum").Observe(duration)

        return trackIDs, nil</span>
}

func (r *TrackPostgresRepository) DeleteTracksByAlbumID(ctx context.Context, albumID int64) error <span class="cov0" title="0">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Deleting tracks by album id from db", zap.Int64("albumID", albumID))

        start := time.Now()

        stmt, err := r.db.PrepareContext(ctx, DeleteTracksByAlbumIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteTracksByAlbumID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return trackErrors.NewInternalError("failed to prepare statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">_, err = stmt.ExecContext(ctx, albumID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteTracksByAlbumID").Inc()
                logger.Error("failed to delete tracks by album id", zap.Error(err))
                return trackErrors.NewInternalError("failed to delete tracks by album id: %v", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("DeleteTracksByAlbumID").Observe(duration)

        return nil</span>
}
func (r *TrackPostgresRepository) GetMostLikedTracks(ctx context.Context, userID int64) ([]*repoModel.Track, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting most liked tracks from db", zap.Int64("userID", userID), zap.String("query", GetMostLikedTracksQuery))
        rows, err := r.db.Query(GetMostLikedTracksQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMostLikedTracks").Inc()
                logger.Error("failed to get most liked tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get most liked tracks: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">tracks := make([]*repoModel.Track, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetMostLikedTracks").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov0" title="0">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMostLikedTracks").Inc()
                logger.Error("failed to get most liked tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get most liked tracks: %v", err)
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetMostLikedTracks").Observe(duration)
        return tracks, nil</span>
}

func (r *TrackPostgresRepository) GetMostRecentTracks(ctx context.Context, userID int64) ([]*repoModel.Track, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting most recent tracks from db", zap.Int64("userID", userID), zap.String("query", GetMostRecentTracksQuery))
        rows, err := r.db.Query(GetMostRecentTracksQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMostRecentTracks").Inc()
                logger.Error("failed to get most recent tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get most recent tracks: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">tracks := make([]*repoModel.Track, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetMostRecentTracks").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov0" title="0">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMostRecentTracks").Inc()
                logger.Error("failed to get most recent tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get most recent tracks: %v", err)
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetMostRecentTracks").Observe(duration)
        return tracks, nil</span>
}

func (r *TrackPostgresRepository) GetMostListenedLastMonthTracks(ctx context.Context, userID int64) ([]*repoModel.Track, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting most listened last month tracks from db", zap.Int64("userID", userID), zap.String("query", GetMostListenedLastMonthTracksQuery))
        rows, err := r.db.Query(GetMostListenedLastMonthTracksQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMostListenedLastMonthTracks").Inc()
                logger.Error("failed to get most listened last month tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get most listened last month tracks: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">tracks := make([]*repoModel.Track, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetMostListenedLastMonthTracks").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov0" title="0">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMostListenedLastMonthTracks").Inc()
                logger.Error("failed to get most listened last month tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get most listened last month tracks: %v", err)
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetMostListenedLastMonthTracks").Observe(duration)
        return tracks, nil</span>
}

func (r *TrackPostgresRepository) GetMostLikedLastWeekTracks(ctx context.Context, userID int64) ([]*repoModel.Track, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Requesting most liked last week tracks from db", zap.Int64("userID", userID), zap.String("query", GetMostLikedLastWeekTracksQuery))
        rows, err := r.db.Query(GetMostLikedLastWeekTracksQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMostLikedLastWeekTracks").Inc()
                logger.Error("failed to get most liked last week tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get most liked last week tracks: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">tracks := make([]*repoModel.Track, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var track repoModel.Track
                err := rows.Scan(&amp;track.ID, &amp;track.Title, &amp;track.Thumbnail, &amp;track.Duration, &amp;track.AlbumID, &amp;track.IsFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetMostLikedLastWeekTracks").Inc()
                        logger.Error("failed to scan track", zap.Error(err))
                        return nil, trackErrors.NewInternalError("failed to scan track: %v", err)
                }</span>
                <span class="cov0" title="0">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetMostLikedLastWeekTracks").Inc()
                logger.Error("failed to get most liked last week tracks", zap.Error(err))
                return nil, trackErrors.NewInternalError("failed to get most liked last week tracks: %v", err)
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetMostLikedLastWeekTracks").Observe(duration)
        return tracks, nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package repository

import (
        "bytes"
        "context"
        "fmt"
        "image"

        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"
        "time"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/domain"
        "go.uber.org/zap"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
        trackErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model/errors"
)

type trackS3Repository struct {
        s3         *s3.S3
        bucketName string
        uploader   *s3manager.Uploader
        expiration time.Duration
        metrics    *metrics.Metrics
}

func NewTrackS3Repository(s3 *s3.S3, bucketName string, expiration time.Duration, metrics *metrics.Metrics) domain.S3Repository <span class="cov0" title="0">{
        uploader := s3manager.NewUploaderWithClient(s3)
        return &amp;trackS3Repository{s3: s3, bucketName: bucketName, expiration: expiration, uploader: uploader, metrics: metrics}
}</span>

func (r *trackS3Repository) GetPresignedURL(trackKey string) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        // Вот тут сомнительно, возможно стоит кидать ошибку, если ключа нет
        // В бд ключ не может быть пустым, но на всякий случай
        if trackKey == "" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPresignedURL").Inc()
                return "", nil
        }</span>

        <span class="cov0" title="0">input := &amp;s3.GetObjectInput{
                Bucket: aws.String(r.bucketName),
                Key:    aws.String(trackKey),
        }

        req, _ := r.s3.GetObjectRequest(input)
        url, err := req.Presign(r.expiration)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPresignedURL").Inc()
                return "", err
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetPresignedURL").Observe(duration)
        return url, nil</span>
}

func (r *trackS3Repository) UploadTrack(ctx context.Context, fileKey string, file []byte) error <span class="cov0" title="0">{
        start := time.Now()

        if fileKey == "" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadTrack").Inc()
                return fmt.Errorf("empty file key provided")
        }</span>

        <span class="cov0" title="0">input := &amp;s3manager.UploadInput{
                Bucket: aws.String(r.bucketName),
                Key:    aws.String(fmt.Sprintf("%s.mp3", fileKey)),
                Body:   bytes.NewReader(file),
        }

        _, err := r.uploader.UploadWithContext(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadTrack").Inc()
                return fmt.Errorf("failed to upload file: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UploadTrack").Observe(duration)

        return nil</span>
}

func (r *trackS3Repository) UploadTrackAvatar(ctx context.Context, trackTitle string, file []byte) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        date := time.Now()
        dateString := date.Format("20060102150405")

        _, format, err := image.Decode(bytes.NewReader(file))
        fmt.Println("FORMAT TRACK", format)
        logger.Info("format", zap.String("format", format))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadTrackAvatar").Inc()
                logger.Error("unsupported or invalid image format", zap.Error(err))
                return "", trackErrors.NewUnsupportedImageFormatError("unsupported or invalid image format")
        }</span>

        <span class="cov0" title="0">if format != "jpeg" &amp;&amp; format != "png" &amp;&amp; format != "gif" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadTrackAvatar").Inc()
                logger.Error("unsupported image format", zap.String("format", format))
                return "", trackErrors.NewUnsupportedImageFormatError("unsupported or invalid image format")
        }</span>

        // webpBuf := new(bytes.Buffer)
        // if err := webp.Encode(webpBuf, img, &amp;webp.Options{Lossless: true}); err != nil {
        //         logger.Error("failed to encode webp", zap.Error(err))
        //         return "", userAvatarFile.ErrFailedToEncodeWebp
        // }

        <span class="cov0" title="0">fileKey := fmt.Sprintf("/%s-%s.%s", trackTitle, dateString, format)
        s3Key := fmt.Sprintf("tracks%s", fileKey)

        _, err = r.uploader.UploadWithContext(ctx, &amp;s3manager.UploadInput{
                Bucket:      aws.String(r.bucketName),
                Key:         aws.String(s3Key),
                Body:        bytes.NewReader(file),
                ContentType: aws.String("image/" + format),
                ACL:         aws.String("public-read"),
        })

        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadTrackAvatar").Inc()
                logger.Error("upload failed", zap.Error(err))
                return "", trackErrors.NewFailedToUploadAvatarError("failed to upload avatar")
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UploadTrackAvatar").Observe(duration)

        return fmt.Sprintf("https://%s.fra1.digitaloceanspaces.com/tracks%s", r.bucketName, fileKey), nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package usecase

import (
        "bytes"
        "context"
        "time"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/internal/domain"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model"
        trackErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model/errors"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model/usecase"
        "github.com/hajimehoshi/go-mp3"
        "go.uber.org/zap"
)

type TrackUsecase struct {
        trackRepo domain.Repository
        s3Repo    domain.S3Repository
}

func NewTrackUsecase(trackRepo domain.Repository, s3Repo domain.S3Repository) domain.Usecase <span class="cov10" title="37">{
        return &amp;TrackUsecase{trackRepo: trackRepo, s3Repo: s3Repo}
}</span>

func (u *TrackUsecase) GetAllTracks(ctx context.Context, filters *usecaseModel.TrackFilters, userID int64) ([]*usecaseModel.Track, error) <span class="cov2" title="2">{
        repoFilters := model.FiltersFromUsecaseToRepository(filters)
        repoTracks, err := u.trackRepo.GetAllTracks(ctx, repoFilters, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.TrackListFromRepositoryToUsecase(repoTracks), nil</span>
}

func (u *TrackUsecase) GetTrackByID(ctx context.Context, id int64, userID int64) (*usecaseModel.TrackDetailed, error) <span class="cov3" title="3">{
        repoTrack, err := u.trackRepo.GetTrackByID(ctx, id, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="2">trackFileUrl, err := u.s3Repo.GetPresignedURL(repoTrack.FileKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return model.TrackDetailedFromRepositoryToUsecase(repoTrack, trackFileUrl), nil</span>
}

func (u *TrackUsecase) CreateStream(ctx context.Context, stream *usecaseModel.TrackStreamCreateData) (int64, error) <span class="cov2" title="2">{
        repoStream := model.TrackStreamCreateDataFromUsecaseToRepository(stream)
        repoStreamID, err := u.trackRepo.CreateStream(ctx, repoStream)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>
        <span class="cov1" title="1">return repoStreamID, nil</span>
}

func (u *TrackUsecase) UpdateStreamDuration(ctx context.Context, stream *usecaseModel.TrackStreamUpdateData) error <span class="cov4" title="4">{
        logger := loggerPkg.LoggerFromContext(ctx)
        existingStream, err := u.trackRepo.GetStreamByID(ctx, stream.StreamID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov3" title="3">if existingStream.UserID != stream.UserID </span><span class="cov1" title="1">{
                logger.Warn("updating stream doesn't belong to user", zap.Error(trackErrors.ErrStreamPermissionDenied))
                return trackErrors.ErrStreamPermissionDenied
        }</span>

        <span class="cov2" title="2">repoStream := model.TrackStreamUpdateDataFromUsecaseToRepository(stream)
        err = u.trackRepo.UpdateStreamDuration(ctx, repoStream)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *TrackUsecase) GetLastListenedTracks(ctx context.Context, userID int64, filters *usecaseModel.TrackFilters) ([]*usecaseModel.Track, error) <span class="cov4" title="4">{
        repoFilters := model.FiltersFromUsecaseToRepository(filters)
        repoStreams, err := u.trackRepo.GetStreamsByUserID(ctx, userID, repoFilters)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="3">if len(repoStreams) == 0 </span><span class="cov1" title="1">{
                return []*usecaseModel.Track{}, nil
        }</span>

        <span class="cov2" title="2">streamIDs := make([]int64, len(repoStreams))
        for i, stream := range repoStreams </span><span class="cov4" title="4">{
                streamIDs[i] = stream.ID
        }</span>
        <span class="cov2" title="2">repoTrackIDs := make([]int64, len(repoStreams))
        for i, stream := range repoStreams </span><span class="cov4" title="4">{
                repoTrackIDs[i] = stream.TrackID
        }</span>

        <span class="cov2" title="2">repoTracks, err := u.trackRepo.GetTracksByIDs(ctx, repoTrackIDs, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">usecaseTracks := make([]*usecaseModel.Track, 0, len(repoStreams))
        for _, stream := range repoStreams </span><span class="cov2" title="2">{
                track, exists := repoTracks[stream.TrackID]
                if exists </span><span class="cov2" title="2">{
                        usecaseTracks = append(usecaseTracks, model.TrackFromRepositoryToUsecase(track))
                }</span>
        }

        <span class="cov1" title="1">return usecaseTracks, nil</span>
}

func (u *TrackUsecase) GetTracksByIDs(ctx context.Context, ids []int64, userID int64) ([]*usecaseModel.Track, error) <span class="cov2" title="2">{
        repoTracks, err := u.trackRepo.GetTracksByIDs(ctx, ids, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">usecaseTracks := make([]*usecaseModel.Track, 0, len(ids))
        for _, id := range ids </span><span class="cov2" title="2">{
                track, exists := repoTracks[id]
                if exists </span><span class="cov2" title="2">{
                        usecaseTracks = append(usecaseTracks, model.TrackFromRepositoryToUsecase(track))
                }</span>
        }

        <span class="cov1" title="1">return usecaseTracks, nil</span>
}

func (u *TrackUsecase) GetTracksByIDsFiltered(ctx context.Context, ids []int64, filters *usecaseModel.TrackFilters, userID int64) ([]*usecaseModel.Track, error) <span class="cov2" title="2">{
        repoFilters := model.FiltersFromUsecaseToRepository(filters)
        repoTracks, err := u.trackRepo.GetTracksByIDsFiltered(ctx, ids, repoFilters, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return model.TrackListFromRepositoryToUsecase(repoTracks), nil</span>
}

func (u *TrackUsecase) GetAlbumIDByTrackID(ctx context.Context, id int64) (int64, error) <span class="cov2" title="2">{
        repoAlbumID, err := u.trackRepo.GetAlbumIDByTrackID(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>
        <span class="cov1" title="1">return repoAlbumID, nil</span>
}

func (u *TrackUsecase) GetTracksByAlbumID(ctx context.Context, id int64, userID int64) ([]*usecaseModel.Track, error) <span class="cov2" title="2">{
        repoTracks, err := u.trackRepo.GetTracksByAlbumID(ctx, id, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">usecaseTracks := make([]*usecaseModel.Track, len(repoTracks))
        for i, repoTrack := range repoTracks </span><span class="cov2" title="2">{
                usecaseTracks[i] = model.TrackFromRepositoryToUsecase(repoTrack)
        }</span>
        <span class="cov1" title="1">return usecaseTracks, nil</span>
}

func (u *TrackUsecase) GetMinutesListenedByUserID(ctx context.Context, userID int64) (int64, error) <span class="cov2" title="2">{
        repoMinutesListened, err := u.trackRepo.GetMinutesListenedByUserID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>
        <span class="cov1" title="1">return repoMinutesListened, nil</span>
}

func (u *TrackUsecase) GetTracksListenedByUserID(ctx context.Context, userID int64) (int64, error) <span class="cov2" title="2">{
        repoTracksListened, err := u.trackRepo.GetTracksListenedByUserID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>
        <span class="cov1" title="1">return repoTracksListened, nil</span>
}

func (u *TrackUsecase) LikeTrack(ctx context.Context, request *usecaseModel.LikeRequest) error <span class="cov5" title="6">{
        repoRequest := model.LikeRequestFromUsecaseToRepository(request)

        exists, err := u.trackRepo.CheckTrackExists(ctx, request.TrackID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="5">if !exists </span><span class="cov1" title="1">{
                return trackErrors.NewNotFoundError("track not found")
        }</span>
        <span class="cov4" title="4">if request.IsLike </span><span class="cov2" title="2">{
                err := u.trackRepo.LikeTrack(ctx, repoRequest)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov2" title="2">err = u.trackRepo.UnlikeTrack(ctx, repoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (u *TrackUsecase) GetFavoriteTracks(ctx context.Context, favoriteRequest *usecaseModel.FavoriteRequest) ([]*usecaseModel.Track, error) <span class="cov2" title="2">{
        repoRequest := model.FavoriteRequestFromUsecaseToRepository(favoriteRequest)
        repoTracks, err := u.trackRepo.GetFavoriteTracks(ctx, repoRequest)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return model.TrackListFromRepositoryToUsecase(repoTracks), nil</span>
}

func (u *TrackUsecase) SearchTracks(ctx context.Context, query string, userID int64) ([]*usecaseModel.Track, error) <span class="cov2" title="2">{
        repoTracks, err := u.trackRepo.SearchTracks(ctx, query, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.TrackListFromRepositoryToUsecase(repoTracks), nil</span>
}

func getMp3Duration(fileData []byte) (int64, error) <span class="cov0" title="0">{
        reader := bytes.NewReader(fileData)

        decoder, err := mp3.NewDecoder(reader)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">samples := decoder.Length() / 4
        sampleRate := decoder.SampleRate()
        duration := time.Duration(float64(samples) / float64(sampleRate) * float64(time.Second))

        return int64(duration.Seconds()), nil</span>
}

func (u *TrackUsecase) AddTracksToAlbum(ctx context.Context, tracksList *usecaseModel.TracksListWithAlbumID) ([]int64, error) <span class="cov0" title="0">{
        var tracksToUpload []*usecaseModel.Track
        if len(tracksList.Cover) == 0 </span><span class="cov0" title="0">{
                return nil, trackErrors.NewUnsupportedImageFormatError("пустое изображение обложки")
        }</span>
        <span class="cov0" title="0">trackCover, err := u.s3Repo.UploadTrackAvatar(ctx, tracksList.Tracks[0].Title, tracksList.Cover)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, track := range tracksList.Tracks </span><span class="cov0" title="0">{
                err := u.s3Repo.UploadTrack(ctx, track.Title, track.File)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">duration, err := getMp3Duration(track.File)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tracksToUpload = append(tracksToUpload, &amp;usecaseModel.Track{
                        Title:     track.Title,
                        Thumbnail: trackCover,
                        AlbumID:   tracksList.AlbumID,
                        Duration:  duration,
                })</span>
        }
        <span class="cov0" title="0">trackListRepo := model.TrackListFromUsecaseToRepository(tracksToUpload)

        trackIDs, err := u.trackRepo.AddTracksToAlbum(ctx, trackListRepo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return trackIDs, nil</span>
}

func (u *TrackUsecase) DeleteTracksByAlbumID(ctx context.Context, albumID int64) error <span class="cov0" title="0">{
        return u.trackRepo.DeleteTracksByAlbumID(ctx, albumID)
}</span>

func (u *TrackUsecase) GetMostLikedTracks(ctx context.Context, userID int64) ([]*usecaseModel.Track, error) <span class="cov0" title="0">{
        repoTracks, err := u.trackRepo.GetMostLikedTracks(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromRepositoryToUsecase(repoTracks), nil</span>
}

func (u *TrackUsecase) GetMostRecentTracks(ctx context.Context, userID int64) ([]*usecaseModel.Track, error) <span class="cov0" title="0">{
        repoTracks, err := u.trackRepo.GetMostRecentTracks(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromRepositoryToUsecase(repoTracks), nil</span>
}

func (u *TrackUsecase) GetMostListenedLastMonthTracks(ctx context.Context, userID int64) ([]*usecaseModel.Track, error) <span class="cov0" title="0">{
        repoTracks, err := u.trackRepo.GetMostListenedLastMonthTracks(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromRepositoryToUsecase(repoTracks), nil</span>
}

func (u *TrackUsecase) GetMostLikedLastWeekTracks(ctx context.Context, userID int64) ([]*usecaseModel.Track, error) <span class="cov0" title="0">{
        repoTracks, err := u.trackRepo.GetMostLikedLastWeekTracks(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.TrackListFromRepositoryToUsecase(repoTracks), nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package model

import (
        trackProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/track"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model/repository"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/track/model/usecase"
)

func PaginationFromUsecaseToRepository(pagination *usecaseModel.Pagination) *repoModel.Pagination <span class="cov6" title="3">{
        return &amp;repoModel.Pagination{
                Limit:  pagination.Limit,
                Offset: pagination.Offset,
        }
}</span>

func FiltersFromUsecaseToRepository(filters *usecaseModel.TrackFilters) *repoModel.TrackFilters <span class="cov4" title="2">{
        return &amp;repoModel.TrackFilters{
                Pagination: PaginationFromUsecaseToRepository(filters.Pagination),
        }
}</span>

func TrackFromRepositoryToUsecase(track *repoModel.Track) *usecaseModel.Track <span class="cov7" title="4">{
        return &amp;usecaseModel.Track{
                ID:         track.ID,
                Title:      track.Title,
                Thumbnail:  track.Thumbnail,
                Duration:   track.Duration,
                AlbumID:    track.AlbumID,
                IsFavorite: track.IsFavorite,
        }
}</span>

func TrackDetailedFromRepositoryToUsecase(track *repoModel.TrackWithFileKey, trackFileUrl string) *usecaseModel.TrackDetailed <span class="cov1" title="1">{
        return &amp;usecaseModel.TrackDetailed{
                Track:   *TrackFromRepositoryToUsecase(&amp;track.Track),
                FileUrl: trackFileUrl,
        }
}</span>

func TrackListFromRepositoryToUsecase(tracks []*repoModel.Track) []*usecaseModel.Track <span class="cov1" title="1">{
        usecaseTracks := make([]*usecaseModel.Track, len(tracks))
        for i, track := range tracks </span><span class="cov4" title="2">{
                usecaseTracks[i] = TrackFromRepositoryToUsecase(track)
        }</span>
        <span class="cov1" title="1">return usecaseTracks</span>
}

func TrackStreamCreateDataFromUsecaseToRepository(stream *usecaseModel.TrackStreamCreateData) *repoModel.TrackStreamCreateData <span class="cov1" title="1">{
        return &amp;repoModel.TrackStreamCreateData{
                TrackID: stream.TrackID,
                UserID:  stream.UserID,
        }
}</span>

func TrackStreamUpdateDataFromUsecaseToRepository(stream *usecaseModel.TrackStreamUpdateData) *repoModel.TrackStreamUpdateData <span class="cov1" title="1">{
        return &amp;repoModel.TrackStreamUpdateData{
                StreamID: stream.StreamID,
                Duration: stream.Duration,
        }
}</span>

func TrackFromUsecaseToProto(track *usecaseModel.Track) *trackProto.Track <span class="cov7" title="4">{
        return &amp;trackProto.Track{
                Id:         track.ID,
                Title:      track.Title,
                Thumbnail:  track.Thumbnail,
                Duration:   track.Duration,
                AlbumId:    track.AlbumID,
                IsFavorite: track.IsFavorite,
        }
}</span>

func TrackDetailedFromUsecaseToProto(track *usecaseModel.TrackDetailed) *trackProto.TrackDetailed <span class="cov1" title="1">{
        return &amp;trackProto.TrackDetailed{
                Track:   TrackFromUsecaseToProto(&amp;track.Track),
                FileUrl: track.FileUrl,
        }
}</span>

func TrackListFromUsecaseToProto(tracks []*usecaseModel.Track) *trackProto.TrackList <span class="cov1" title="1">{
        protoTracks := make([]*trackProto.Track, len(tracks))
        for i, track := range tracks </span><span class="cov4" title="2">{
                protoTracks[i] = TrackFromUsecaseToProto(track)
        }</span>
        <span class="cov1" title="1">return &amp;trackProto.TrackList{
                Tracks: protoTracks,
        }</span>
}

func FiltersFromProtoToUsecase(filters *trackProto.Filters) *usecaseModel.TrackFilters <span class="cov6" title="3">{
        return &amp;usecaseModel.TrackFilters{
                Pagination: &amp;usecaseModel.Pagination{
                        Limit:  filters.Pagination.Limit,
                        Offset: filters.Pagination.Offset,
                },
        }
}</span>

func StreamIDFromUsecaseToProto(streamID int64) *trackProto.StreamID <span class="cov1" title="1">{
        return &amp;trackProto.StreamID{
                Id: streamID,
        }
}</span>

func TrackStreamCreateDataFromProtoToUsecase(stream *trackProto.TrackStreamCreateData) *usecaseModel.TrackStreamCreateData <span class="cov1" title="1">{
        return &amp;usecaseModel.TrackStreamCreateData{
                TrackID: stream.TrackId.Id,
                UserID:  stream.UserId.Id,
        }
}</span>

func TrackStreamUpdateDataFromProtoToUsecase(stream *trackProto.TrackStreamUpdateData) *usecaseModel.TrackStreamUpdateData <span class="cov1" title="1">{
        return &amp;usecaseModel.TrackStreamUpdateData{
                StreamID: stream.StreamId.Id,
                Duration: stream.Duration,
                UserID:   stream.UserId.Id,
        }
}</span>

func TrackIDListFromProtoToUsecase(ids *trackProto.TrackIDList) ([]int64, int64) <span class="cov4" title="2">{
        usecaseIDs := make([]int64, len(ids.Ids))
        for i, id := range ids.Ids </span><span class="cov10" title="6">{
                usecaseIDs[i] = id.Id
        }</span>
        <span class="cov4" title="2">return usecaseIDs, ids.UserId.Id</span>
}

func TrackIDListWithFiltersFromProtoToUsecase(trackIdsWithFilters *trackProto.TrackIDListWithFilters) ([]int64, *usecaseModel.TrackFilters, int64) <span class="cov1" title="1">{
        usecaseIDs, userID := TrackIDListFromProtoToUsecase(trackIdsWithFilters.Ids)
        return usecaseIDs, FiltersFromProtoToUsecase(trackIdsWithFilters.Filters), userID
}</span>

func LikeRequestFromProtoToUsecase(likeRequest *trackProto.LikeRequest) *usecaseModel.LikeRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.LikeRequest{
                TrackID: likeRequest.TrackId.Id,
                UserID:  likeRequest.UserId.Id,
                IsLike:  likeRequest.IsLike,
        }
}</span>

func LikeRequestFromUsecaseToRepository(likeRequest *usecaseModel.LikeRequest) *repoModel.LikeRequest <span class="cov1" title="1">{
        return &amp;repoModel.LikeRequest{
                TrackID: likeRequest.TrackID,
                UserID:  likeRequest.UserID,
        }
}</span>

func FavoriteRequestFromProtoToUsecase(favoriteRequest *trackProto.FavoriteRequest) *usecaseModel.FavoriteRequest <span class="cov1" title="1">{
        return &amp;usecaseModel.FavoriteRequest{
                RequestUserID: favoriteRequest.RequestUserId.Id,
                ProfileUserID: favoriteRequest.ProfileUserId.Id,
                Filters:       FiltersFromProtoToUsecase(favoriteRequest.Filters),
        }
}</span>

func FavoriteRequestFromUsecaseToRepository(favoriteRequest *usecaseModel.FavoriteRequest) *repoModel.FavoriteRequest <span class="cov1" title="1">{
        return &amp;repoModel.FavoriteRequest{
                RequestUserID: favoriteRequest.RequestUserID,
                ProfileUserID: favoriteRequest.ProfileUserID,
                Filters:       FiltersFromUsecaseToRepository(favoriteRequest.Filters),
        }
}</span>

func TracksIDWithAlbumIDFromProtoToUsecase(tracksIDWithAlbumID []*trackProto.TrackLoad) []*usecaseModel.TrackLoad <span class="cov0" title="0">{
        var tracks []*usecaseModel.TrackLoad
        for _, track := range tracksIDWithAlbumID </span><span class="cov0" title="0">{
                tracks = append(tracks, &amp;usecaseModel.TrackLoad{
                        Title: track.Title,
                        File:  track.File,
                })
        }</span>
        <span class="cov0" title="0">return tracks</span>
}

func TrackLoadFromUsecaseToRepository(track *usecaseModel.TrackLoad) *repoModel.TrackLoad <span class="cov0" title="0">{
        return &amp;repoModel.TrackLoad{
                Title:    track.Title,
                File:     track.File,
                Position: track.Position,
        }
}</span>

func TrackLoadListFromUsecaseToRepository(tracks []*usecaseModel.TrackLoad) []*repoModel.TrackLoad <span class="cov0" title="0">{
        var repoTracks []*repoModel.TrackLoad
        for _, track := range tracks </span><span class="cov0" title="0">{
                repoTracks = append(repoTracks, TrackLoadFromUsecaseToRepository(track))
        }</span>
        <span class="cov0" title="0">return repoTracks</span>
}

func TrackListFromUsecaseToRepository(tracks []*usecaseModel.Track) []*repoModel.Track <span class="cov0" title="0">{
        repoTracks := make([]*repoModel.Track, len(tracks))
        for i, track := range tracks </span><span class="cov0" title="0">{
                repoTracks[i] = &amp;repoModel.Track{
                        ID:         track.ID,
                        Title:      track.Title,
                        Thumbnail:  track.Thumbnail,
                        Duration:   track.Duration,
                        AlbumID:    track.AlbumID,
                        IsFavorite: track.IsFavorite,
                }
        }</span>
        <span class="cov0" title="0">return repoTracks</span>
}

func TracksListWithAlbumIDFromProtoToUsecase(tracksIDWithAlbumID *trackProto.TracksListWithAlbumID) *usecaseModel.TracksListWithAlbumID <span class="cov0" title="0">{
        tracks := TracksIDWithAlbumIDFromProtoToUsecase(tracksIDWithAlbumID.Tracks)
        return &amp;usecaseModel.TracksListWithAlbumID{
                Tracks:  tracks,
                AlbumID: tracksIDWithAlbumID.AlbumId.Id,
                Cover:   tracksIDWithAlbumID.Cover,
        }
}</span>

func TrackIdsListFromUsecaseToProto(trackIDs []int64) *trackProto.TrackIdsList <span class="cov0" title="0">{
        protoTrackIDs := make([]*trackProto.TrackID, len(trackIDs))
        for i, id := range trackIDs </span><span class="cov0" title="0">{
                protoTrackIDs[i] = &amp;trackProto.TrackID{Id: id}
        }</span>
        <span class="cov0" title="0">return &amp;trackProto.TrackIdsList{Ids: protoTrackIDs}</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package errors

import (
        "fmt"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type TrackError struct {
        Code    codes.Code
        Message string
}

func (e *TrackError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func (e *TrackError) GRPCStatus() *status.Status <span class="cov0" title="0">{
        return status.New(e.Code, e.Message)
}</span>

func NewNotFoundError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;TrackError{
                Code:    codes.NotFound,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewInternalError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;TrackError{
                Code:    codes.Internal,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewPermissionDeniedError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;TrackError{
                Code:    codes.PermissionDenied,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewUnsupportedImageFormatError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;TrackError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewFailedToUploadAvatarError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;TrackError{
                Code:    codes.Internal,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

var (
        ErrTrackNotFound                = NewNotFoundError("track not found")
        ErrStreamPermissionDenied       = NewPermissionDeniedError("user does not have permission to update this stream")
        ErrStreamNotFound               = NewNotFoundError("stream not found")
        ErrFailedToUpdateStreamDuration = NewInternalError("failed to update stream duration")
)
</pre>
		
		<pre class="file" id="file78" style="display: none">package main

import (
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"

        "github.com/go-park-mail-ru/2025_1_Return_Zero/config"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/postgres"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/init/s3"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/interceptors"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/delivery"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/repository"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/usecase"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.uber.org/zap"
        "google.golang.org/grpc"

        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
)

func main() <span class="cov0" title="0">{
        logger, err := loggerPkg.NewZapLogger()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creating logger:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error syncing logger:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error loading config:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">port := fmt.Sprintf(":%d", cfg.Services.UserService.Port)
        conn, err := net.Listen("tcp", port)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Can't start user service:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing connection:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">reg := prometheus.NewRegistry()
        metrics := metrics.NewMetrics(reg, "user_service")

        accessInterceptor := interceptors.NewAccessInterceptor(logger, metrics)

        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
                address := fmt.Sprintf(":%d", cfg.Prometheus.UserPort)
                logger.Info(fmt.Sprintf("Serving metrics responds on port %d", cfg.Prometheus.UserPort))
                if err := http.ListenAndServe(address, nil); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Error starting metrics server", zap.String("error", err.Error()))
                }</span>
        }()

        <span class="cov0" title="0">server := grpc.NewServer(
                grpc.UnaryInterceptor(accessInterceptor.UnaryServerInterceptor()),
        )

        postgresPool, err := postgres.ConnectPostgres(cfg.Postgres)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error connecting to postgres:", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := postgresPool.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing postgres pool:", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">fmt.Println("config ", cfg.S3.S3ImagesBucket)
        s3, err := s3.InitS3(cfg.S3)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initializing S3:", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">userRepository := repository.NewUserPostgresRepository(postgresPool, metrics)
        userS3Repository := repository.NewS3Repository(s3, cfg.S3.S3ImagesBucket, metrics)
        userUsecase := usecase.NewUserUsecase(userRepository, userS3Repository)
        userService := delivery.NewUserService(userUsecase)
        userProto.RegisterUserServiceServer(server, userService)

        logger.Info("User service started on port %s...", zap.String("port", port))

        err = server.Serve(conn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error starting user service:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)
        &lt;-c

        server.GracefulStop()
        logger.Info("User service stopped")</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package delivery

import (
        "context"

        userProto "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model"
)

type UserService struct {
        userProto.UnimplementedUserServiceServer
        userUsecase domain.Usecase
}

func NewUserService(userUsecase domain.Usecase) *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                userUsecase: userUsecase,
        }
}</span>

func (s *UserService) CreateUser(ctx context.Context, req *userProto.RegisterData) (*userProto.UserFront, error) <span class="cov0" title="0">{
        data := model.RegisterDataFromProtoToUsecase(req)
        user, err := s.userUsecase.CreateUser(ctx, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.UserFrontFromUsecaseToProto(user), nil</span>
}

func (s *UserService) LoginUser(ctx context.Context, req *userProto.LoginData) (*userProto.UserFront, error) <span class="cov0" title="0">{
        data := model.LoginDataFromProtoToUsecase(req)
        user, err := s.userUsecase.LoginUser(ctx, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.UserFrontFromUsecaseToProto(user), nil</span>
}

func (s *UserService) GetUserByID(ctx context.Context, req *userProto.UserID) (*userProto.UserFront, error) <span class="cov0" title="0">{
        user, err := s.userUsecase.GetUserByID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.UserFrontFromUsecaseToProto(user), nil</span>
}

func (s *UserService) UploadAvatar(ctx context.Context, req *userProto.AvatarData) (*userProto.Nothing, error) <span class="cov0" title="0">{
        err := s.userUsecase.UploadAvatar(ctx, req.AvatarPath, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userProto.Nothing{Dummy: true}, nil</span>
}

func (s *UserService) DeleteUser(ctx context.Context, req *userProto.UserDelete) (*userProto.Nothing, error) <span class="cov0" title="0">{
        err := s.userUsecase.DeleteUser(ctx, model.UserDeleteFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userProto.Nothing{Dummy: true}, nil</span>
}

func (s *UserService) ChangeUserData(ctx context.Context, req *userProto.ChangeUserDataMessage) (*userProto.Nothing, error) <span class="cov0" title="0">{
        err := s.userUsecase.ChangeUserData(ctx, req.Username, model.ChangeUserDataFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userProto.Nothing{Dummy: true}, nil</span>
}

func (s *UserService) ChangeUserPrivacySettings(ctx context.Context, req *userProto.PrivacySettings) (*userProto.Nothing, error) <span class="cov0" title="0">{
        err := s.userUsecase.ChangeUserPrivacySettings(ctx, req.Username, model.PrivacySettingsFromProtoToUsecase(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userProto.Nothing{Dummy: true}, nil</span>
}

func (s *UserService) GetUserFullData(ctx context.Context, req *userProto.Username) (*userProto.UserFullData, error) <span class="cov0" title="0">{
        user, err := s.userUsecase.GetFullUserData(ctx, req.Username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.UserFullDataFromUsecaseToProto(user), nil</span>
}

func (s *UserService) GetIDByUsername(ctx context.Context, req *userProto.Username) (*userProto.UserID, error) <span class="cov0" title="0">{
        id, err := s.userUsecase.GetIDByUsername(ctx, req.Username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.UserIDFromUsecaseToProto(id), nil</span>
}

func (s *UserService) GetUserPrivacyByID(ctx context.Context, req *userProto.UserID) (*userProto.PrivacySettings, error) <span class="cov0" title="0">{
        settings, err := s.userUsecase.GetUserPrivacySettings(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.PrivacySettingsFromUsecaseToProto(settings), nil</span>
}

func (s *UserService) GetUserAvatarURL(ctx context.Context, req *userProto.FileKey) (*userProto.AvatarUrl, error) <span class="cov0" title="0">{
        avatarURL, err := s.userUsecase.GetAvatarURL(ctx, req.FileKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.AvatarUrlFromUsecaseToProto(avatarURL), nil</span>
}

func (s *UserService) UploadUserAvatar(ctx context.Context, req *userProto.AvatarImage) (*userProto.FileKey, error) <span class="cov0" title="0">{
        fileKey, err := s.userUsecase.UploadUserAvatar(ctx, req.Username, req.Image)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.FileKeyFromUsecaseToProto(fileKey), nil</span>
}

func (s *UserService) GetLabelIDByUserID(ctx context.Context, req *userProto.UserID) (*userProto.LabelID, error) <span class="cov0" title="0">{
        labelID, err := s.userUsecase.GetLabelIDByUserID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return model.LabelIDFromUsecaseToProto(labelID), nil</span>
}

func (s *UserService) UpdateUsersLabelID(ctx context.Context, req *userProto.RequestUpdateUserLabelID) (*userProto.Nothing, error) <span class="cov0" title="0">{
        err := s.userUsecase.UpdateUsersLabelID(ctx, req.LabelId, req.Usernames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userProto.Nothing{Dummy: true}, nil</span>
}

func (s *UserService) ChecksUsersByUsernames(ctx context.Context, req *userProto.Usernames) (*userProto.Nothing, error) <span class="cov0" title="0">{
        err := s.userUsecase.CheckUsersByUsernames(ctx, req.Usernames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userProto.Nothing{Dummy: true}, nil</span>
}

func (s *UserService) GetUsersByLabelID(ctx context.Context, req *userProto.LabelID) (*userProto.Usernames, error) <span class="cov0" title="0">{
        users, err := s.userUsecase.GetUsersByLabelID(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userProto.Usernames{Usernames: users}, nil</span>
}

func (s *UserService) RemoveUsersFromLabel(ctx context.Context, req *userProto.RequestRemoveUserLabelID) (*userProto.Nothing, error) <span class="cov0" title="0">{
        err := s.userUsecase.RemoveUsersFromLabel(ctx, req.LabelId, req.Usernames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userProto.Nothing{Dummy: true}, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package repository

import (
        "bytes"
        "context"
        "crypto/rand"
        "database/sql"
        "encoding/base64"
        "errors"
        "strings"
        "time"

        "golang.org/x/crypto/argon2"

        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/domain"
        userErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model/errors"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model/repository"
        "github.com/lib/pq"
        "go.uber.org/zap"
)

const (
        getPasswordQuery = `
                        SELECT password_hash
                        FROM "user"
                        WHERE id = $1
        `
        checkUserExist = `
                        SELECT 1 
                        FROM "user"
                        WHERE username = $1 OR email = $2
        `
        createUserQuery = `
                        INSERT INTO "user" (username, password_hash, email) 
                        VALUES ($1, $2, $3) 
                        RETURNING id
        `
        createUserSettingsQuery = `
            INSERT INTO "user_settings" (
                user_id, 
                is_public_playlists, 
                is_public_minutes_listened, 
                is_public_favorite_artists, 
                is_public_tracks_listened, 
                is_public_favorite_tracks, 
                is_public_artists_listened
            ) VALUES ($1, false, false, false, false, false, false)
    `
        loginUserQuery = `
                        SELECT id, username, email, password_hash, thumbnail_url, label_id
                        FROM "user"
                        WHERE username = $1 OR email = $2
        `
        getUserByIDQuery = `
                        SELECT id, username, email, thumbnail_url
                        FROM "user"
                        WHERE id = $1
        `
        uploadAvatarQuery = `
                        UPDATE "user"
                        SET thumbnail_url = $1
                        WHERE id = $2        
        `
        getIdByUsernameQuery = `
                        SELECT id
                        FROM "user"
                        WHERE username = $1
        `
        deleteUserQuery = `
                        DELETE FROM "user"
                        WHERE username = $1 AND email = $2
        `
        changeUsernameQuery = `
                        UPDATE "user"
                        SET username = $1
                        WHERE id = $2
        `
        changeEmailQuery = `
                        UPDATE "user"
                        SET email = $1
                        WHERE id = $2
        `
        changePasswordQuery = `
                        UPDATE "user"
                        SET password_hash = $1
                        WHERE id = $2
        `
        checkIsUsernameUniqueQuery = `
                        SELECT 1 
                        FROM "user"
                        WHERE username = $1 AND id != $2
        `
        checkIsEmailUniqueQuery = `
                        SELECT 1 
                        FROM "user"
                        WHERE username = $1 AND id != $2
        `
        changePrivacySettingsQuery = `
                        UPDATE "user_settings"
                        SET is_public_playlists = $1,
                                is_public_minutes_listened = $2,
                                is_public_favorite_artists = $3,
                                is_public_tracks_listened = $4,
                                is_public_favorite_tracks = $5,
                                is_public_artists_listened = $6
                        WHERE user_id = $7
        `
        getNumUniqueTracksQuery = `
                        SELECT COUNT(DISTINCT track_id) AS num_unique_tracks
                        FROM stream
                        WHERE user_id = $1
        `
        getMinutesListenedQuery = `
                        SELECT COALESCE(SUM(duration) / 60, 0) AS total_minutes
                        FROM stream
                        WHERE user_id = $1
        `
        getNumUniqueArtistQuery = `
                        SELECT COUNT(DISTINCT ta.artist_id) AS unique_artists_listened
                        FROM stream s
                        JOIN track_artist ta ON s.track_id = ta.track_id
                        WHERE s.user_id = $1;
        `
        getUserPrivacySettingsQuery = `
                        SELECT is_public_playlists, is_public_minutes_listened, is_public_favorite_artists,
                                is_public_tracks_listened, is_public_favorite_tracks, is_public_artists_listened
                        FROM user_settings
                        WHERE user_id = $1
        `
        GetLabelIDByUserIDQuery = `
                        SELECT label_id
                        FROM "user"
                        WHERE id = $1
        `
        UpdateLabelQuery = `
                        UPDATE "user"
                        SET label_id = $1
                        WHERE username = ANY($2)
        `
        RemoveLabelQuery = `
                        UPDATE "user"
                        SET label_id = NULL
                        WHERE label_id = $1 AND username = ANY($2)
        `
        CheckIsLabelNameUniqueQuery = `
                        SELECT 1
                        FROM label
                        WHERE name = $1
        `
        UpdateLabelNameQuery = `
                        UPDATE label
                        SET name = $1
                        WHERE id = $2
        `
        GetLabelByIdQuery = `
                        SELECT name
                        FROM label
                        WHERE id = $1
        `
        GetUsersByLabelIDQuery = `
                        SELECT username
                        FROM "user"
                        WHERE label_id = $1
        `
        GetIdsByUsernamesQuery = `
                        SELECT id
                        FROM "user"
                        WHERE username = ANY($1)
        `
)

type userPostgresRepository struct {
        db      *sql.DB
        metrics *metrics.Metrics
}

func NewUserPostgresRepository(db *sql.DB, metrics *metrics.Metrics) domain.Repository <span class="cov10" title="35">{
        return &amp;userPostgresRepository{db: db, metrics: metrics}
}</span>

func hashPassword(salt []byte, password string) string <span class="cov3" title="3">{
        hashedPass := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)
        combined := append(salt, hashedPass...)
        return base64.StdEncoding.EncodeToString(combined)
}</span>

func checkPasswordHash(encodedHash string, password string) bool <span class="cov5" title="6">{
        decodedHash, err := base64.StdEncoding.DecodeString(encodedHash)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov5" title="5">salt := decodedHash[:8]
        userPassHash := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)
        return bytes.Equal(userPassHash, decodedHash[8:])</span>
}

func (r *userPostgresRepository) getPassword(ctx context.Context, id int64) (string, error) <span class="cov5" title="5">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)

        stmt, err := r.db.PrepareContext(ctx, getPasswordQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPassword").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return "", err
        }</span>
        <span class="cov5" title="5">defer func() </span><span class="cov5" title="5">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov5" title="5">row := stmt.QueryRowContext(ctx, id)
        var storedHash string
        err = row.Scan(&amp;storedHash)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetPassword").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Error("user not found", zap.Error(err))
                        return "", userErrors.NewNotFoundError("user not found")
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get password hash", zap.Error(err))
                return "", err</span>
        }
        <span class="cov5" title="5">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetPassword").Observe(duration)
        return storedHash, nil</span>
}

func createSalt() []byte <span class="cov3" title="3">{
        salt := make([]byte, 8)
        _, err := rand.Read(salt)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="3">return salt</span>
}

func (r *userPostgresRepository) CheckUserExist(ctx context.Context, lowerUsername, email string) (bool, error) <span class="cov3" title="3">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking user existence", zap.String("username", lowerUsername), zap.String("email", email))
        stmt, err := r.db.PrepareContext(ctx, checkUserExist)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckUserExist").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return false, err
        }</span>

        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()
        <span class="cov3" title="3">var exists bool
        err = stmt.QueryRowContext(ctx, lowerUsername, email).Scan(&amp;exists)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov3" title="3">return exists, nil</span>
}

func (r *userPostgresRepository) CreateUserSettings(ctx context.Context, userID int64) error <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Creating user settings", zap.Int64("userID", userID))

        stmt, err := r.db.PrepareContext(ctx, createUserSettingsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateUserSettings").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">_, err = stmt.ExecContext(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateUserSettings").Inc()
                logger.Error("failed to create user settings", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CreateUserSettings").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) CreateUser(ctx context.Context, regData *repoModel.RegisterData) (*repoModel.User, error) <span class="cov3" title="3">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Creating new user", zap.String("username: ", regData.Username))

        stmt, err := r.db.PrepareContext(ctx, createUserQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateUser").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">lowerUsername := strings.ToLower(regData.Username)
        logger.Info("Creating new user", zap.String("username: ", lowerUsername))

        exists, err := r.CheckUserExist(ctx, lowerUsername, regData.Email)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateUser").Inc()
                logger.Error("failed to check user existence", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov3" title="3">if exists </span><span class="cov2" title="2">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateUser").Inc()
                logger.Error("user with this username or email already exists")
                return nil, userErrors.NewUserExistError("user with this username or email already exists %s, %s", lowerUsername, regData.Email)
        }</span>

        <span class="cov1" title="1">salt := createSalt()
        if salt == nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateUser").Inc()
                logger.Error("failed to create salt")
                return nil, userErrors.NewCreateSaltError("failed to create salt")
        }</span>
        <span class="cov1" title="1">hashedPassword := hashPassword(salt, regData.Password)

        var userID int64
        err = stmt.QueryRowContext(ctx, lowerUsername,
                hashedPassword, regData.Email).Scan(&amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateUser").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Error("user not found", zap.Error(err))
                        return nil, userErrors.NewNotFoundError("user not found: %s", lowerUsername)
                }</span>
                <span class="cov0" title="0">logger.Error("failed to create user", zap.Error(err))
                return nil, err</span>
        }

        <span class="cov1" title="1">err = r.CreateUserSettings(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CreateUser").Inc()
                logger.Error("failed to create user settings", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CreateUser").Observe(duration)
        return &amp;repoModel.User{
                ID:        userID,
                Username:  lowerUsername,
                Email:     regData.Email,
                Thumbnail: "/default_avatar.png",
        }, nil</span>
}

func (r *userPostgresRepository) LoginUser(ctx context.Context, logData *repoModel.LoginData) (*repoModel.User, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)

        stmt, err := r.db.PrepareContext(ctx, loginUserQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("LoginUser").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var storedHash string
        lowerUsername := strings.ToLower(logData.Username)
        logger.Info("Loggining user", zap.String("username", lowerUsername))
        row := stmt.QueryRowContext(ctx, lowerUsername, logData.Email)
        var userRepo repoModel.User
        var labelID sql.NullInt64
        err = row.Scan(&amp;userRepo.ID, &amp;userRepo.Username, &amp;userRepo.Email, &amp;storedHash, &amp;userRepo.Thumbnail, &amp;labelID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("LoginUser").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        logger.Error("user not found", zap.Error(err))
                        return nil, userErrors.NewNotFoundError("user not found: %s", lowerUsername)
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get user by username or email", zap.Error(err))
                return nil, err</span>
        }

        <span class="cov1" title="1">if !checkPasswordHash(storedHash, logData.Password) </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("LoginUser").Inc()
                logger.Error("wrong password", zap.Error(err))
                return nil, userErrors.NewWrongPasswordError("wrong password")
        }</span>
        <span class="cov1" title="1">if labelID.Valid </span><span class="cov0" title="0">{
                userRepo.LabelId = labelID.Int64
        }</span> else<span class="cov1" title="1"> {
                userRepo.LabelId = -1
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("LoginUser").Observe(duration)
        return &amp;userRepo, nil</span>
}

func (r *userPostgresRepository) GetUserByID(ctx context.Context, ID int64) (*repoModel.User, error) <span class="cov3" title="3">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting user by id", zap.Int64("ID", ID))

        stmt, err := r.db.PrepareContext(ctx, getUserByIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetUserByID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">row := stmt.QueryRowContext(ctx, ID)
        var userRepo repoModel.User
        err = row.Scan(&amp;userRepo.ID, &amp;userRepo.Username, &amp;userRepo.Email, &amp;userRepo.Thumbnail)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("GetUserByID").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        logger.Error("user not found", zap.Error(err))
                        return nil, userErrors.NewNotFoundError("user not found")
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get user by ID", zap.Error(err))
                return nil, err</span>
        }
        <span class="cov2" title="2">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetUserByID").Observe(duration)
        return &amp;userRepo, nil</span>
}

func (r *userPostgresRepository) UploadAvatar(ctx context.Context, avatarUrl string, ID int64) error <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Loading avatar by ID", zap.Int64("ID", ID))

        stmt, err := r.db.PrepareContext(ctx, uploadAvatarQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadAvatar").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, avatarUrl, ID)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadAvatar").Inc()
                logger.Error("failed to upload avatar", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UploadAvatar").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) GetIDByUsername(ctx context.Context, username string) (int64, error) <span class="cov7" title="15">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting ID by username", zap.String("username", username))

        stmt, err := r.db.PrepareContext(ctx, getIdByUsernameQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetIDByUsername").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return 0, err
        }</span>
        <span class="cov7" title="15">defer func() </span><span class="cov7" title="15">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov7" title="15">lowerUsername := strings.ToLower(username)
        row := stmt.QueryRowContext(ctx, lowerUsername)
        var userID int64
        err = row.Scan(&amp;userID)
        if err != nil </span><span class="cov4" title="4">{
                r.metrics.DatabaseErrors.WithLabelValues("GetIDByUsername").Inc()
                logger.Error("failed to get user ID", zap.Error(err))
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov4" title="4">{
                        return 0, userErrors.NewNotFoundError("user not found: %s", lowerUsername)
                }</span>
                <span class="cov0" title="0">logger.Error("user not found", zap.Error(err))
                return 0, err</span>
        }
        <span class="cov7" title="11">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetIDByUsername").Observe(duration)
        return userID, nil</span>
}

func (r *userPostgresRepository) DeleteUser(ctx context.Context, userRepo *repoModel.UserDelete) error <span class="cov3" title="3">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Deleting user", zap.String("username", userRepo.Username))

        stmt, err := r.db.PrepareContext(ctx, deleteUserQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteUser").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">id, err := r.GetIDByUsername(ctx, userRepo.Username)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteUser").Inc()
                logger.Error("failed to find user", zap.Error(err))
                return err
        }</span>
        <span class="cov2" title="2">storedHash, err := r.getPassword(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteUser").Inc()
                logger.Error("failed to get password hash", zap.Error(err))
                return err
        }</span>
        <span class="cov2" title="2">if !checkPasswordHash(storedHash, userRepo.Password) </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteUser").Inc()
                logger.Error("wrong password", zap.Error(err))
                return userErrors.NewWrongPasswordError("wrong password")
        }</span>
        <span class="cov1" title="1">_, err = stmt.ExecContext(ctx, userRepo.Username, userRepo.Email)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("DeleteUser").Inc()
                logger.Error("failed to delete user", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("DeleteUser").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) CheckIsUsernameUnique(ctx context.Context, username string) (bool, error) <span class="cov3" title="3">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking username uniqueness", zap.String("username", username))

        stmt, err := r.db.PrepareContext(ctx, checkIsUsernameUniqueQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckIsUsernameUnique").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return false, err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">var exists bool
        err = stmt.QueryRowContext(ctx, username).Scan(&amp;exists)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov3" title="3">return exists, nil</span>
}

func (r *userPostgresRepository) changeUsername(ctx context.Context, id int64, newUsername string) error <span class="cov3" title="3">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        newLowerUsername := strings.ToLower(newUsername)
        logger.Info("Changing username", zap.String("username", newLowerUsername))

        stmt, err := r.db.PrepareContext(ctx, changeUsernameQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("СhangeUsername").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">isExist, err := r.CheckIsUsernameUnique(ctx, newLowerUsername)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("СhangeUsername").Inc()
                logger.Error("failed to check username uniqueness", zap.Error(err))
                return err
        }</span>

        <span class="cov3" title="3">if isExist </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("СhangeUsername").Inc()
                logger.Error("username already occupied. username: ", zap.String("username", newLowerUsername))
                return userErrors.NewUserExistError("username already occupied. username: %s", newLowerUsername)
        }</span>

        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, newLowerUsername, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("СhangeUsername").Inc()
                logger.Error("failed to change username", zap.Error(err))
                return err
        }</span>
        <span class="cov2" title="2">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("СhangeUsername").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) CheckIsEmailUnique(ctx context.Context, email string) (bool, error) <span class="cov2" title="2">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking email uniqueness", zap.String("email", email))

        stmt, err := r.db.PrepareContext(ctx, checkIsEmailUniqueQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckIsEmailUnique").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return false, err
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">var exists bool
        err = stmt.QueryRowContext(ctx, email).Scan(&amp;exists)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov2" title="2">return exists, nil</span>
}

func (r *userPostgresRepository) changeEmail(ctx context.Context, id int64, newEmail string) error <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Changing email", zap.String("email", newEmail))

        stmt, err := r.db.PrepareContext(ctx, changeEmailQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changeEmail").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">isExist, err := r.CheckIsEmailUnique(ctx, newEmail)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changeEmail").Inc()
                logger.Error("failed to check email uniqueness", zap.Error(err))
                return err
        }</span>

        <span class="cov2" title="2">if isExist </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changeEmail").Inc()
                logger.Error("email already occupied. email: ", zap.String("email", newEmail))
                return userErrors.NewUserExistError("email already occupied. email: %s", newEmail)
        }</span>
        <span class="cov2" title="2">_, err = stmt.ExecContext(ctx, newEmail, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changeEmail").Inc()
                logger.Error("failed to change email", zap.Error(err))
                return err
        }</span>
        <span class="cov2" title="2">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("changeEmail").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) сhangePassword(ctx context.Context, password string, id int64, newPassword string) error <span class="cov3" title="3">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Changing password")

        stmt, err := r.db.PrepareContext(ctx, changePasswordQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changePassword").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">storedHash, err := r.getPassword(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changePassword").Inc()
                logger.Error("failed to get password hash", zap.Error(err))
                return err
        }</span>
        <span class="cov3" title="3">if !checkPasswordHash(storedHash, password) </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("changePassword").Inc()
                logger.Error("wrong password", zap.Error(err))
                return userErrors.NewWrongPasswordError("wrong password")
        }</span>
        <span class="cov2" title="2">salt := createSalt()
        newHashedPassword := hashPassword(salt, newPassword)
        _, err = stmt.ExecContext(ctx, newHashedPassword, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changePassword").Inc()
                logger.Error("failed to change password", zap.Error(err))
                return err
        }</span>
        <span class="cov2" title="2">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("changePassword").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) ChangeUserData(ctx context.Context, username string, changeData *repoModel.ChangeUserData) error <span class="cov5" title="7">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Changing data by username", zap.String("username", username))
        if changeData.NewPassword != "" &amp;&amp; changeData.Password == "" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changeUserData").Inc()
                logger.Error("password is required to change password")
                return userErrors.NewPasswordRequierdError("password is required to change password")
        }</span>
        <span class="cov5" title="7">id, err := r.GetIDByUsername(ctx, username)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("changeUserData").Inc()
                logger.Error("failed to get user ID", zap.Error(err))
                return err
        }</span>
        <span class="cov5" title="6">if changeData.NewUsername != "" </span><span class="cov3" title="3">{
                err := r.changeUsername(ctx, id, changeData.NewUsername)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("changeUserData").Inc()
                        logger.Error("failed to change username", zap.Error(err))
                        return err
                }</span>
        }
        <span class="cov5" title="5">if changeData.NewEmail != "" </span><span class="cov2" title="2">{
                err := r.changeEmail(ctx, id, changeData.NewEmail)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("changeUserData").Inc()
                        logger.Error("failed to change email", zap.Error(err))
                        return err
                }</span>
        }
        <span class="cov5" title="5">if changeData.NewPassword != "" </span><span class="cov3" title="3">{
                err := r.сhangePassword(ctx, changeData.Password, id, changeData.NewPassword)
                if err != nil </span><span class="cov1" title="1">{
                        r.metrics.DatabaseErrors.WithLabelValues("changeUserData").Inc()
                        logger.Error("failed to change password", zap.Error(err))
                        return err
                }</span>
        }
        <span class="cov4" title="4">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("changeUserData").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) ChangeUserPrivacySettings(ctx context.Context, username string, privacySettings *repoModel.PrivacySettings) error <span class="cov2" title="2">{
        start := time.Now()

        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Changing user privacy", zap.String("username", username))

        stmt, err := r.db.PrepareContext(ctx, changePrivacySettingsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changeUserPrivacySettings").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">id, err := r.GetIDByUsername(ctx, username)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("changeUserPrivacySettings").Inc()
                logger.Error("failed to get user ID", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">_, err = stmt.ExecContext(ctx,
                privacySettings.IsPublicPlaylists,
                privacySettings.IsPublicMinutesListened,
                privacySettings.IsPublicFavoriteArtists,
                privacySettings.IsPublicTracksListened,
                privacySettings.IsPublicFavoriteTracks,
                privacySettings.IsPublicArtistsListened,
                id,
        )
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("changeUserPrivacySettings").Inc()
                logger.Error("failed to change privacy settings", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("changeUserPrivacySettings").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) GetUserPrivacy(ctx context.Context, id int64) (*repoModel.PrivacySettings, error) <span class="cov3" title="3">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting user privacy settings by id", zap.Int64("ID", id))

        stmt, err := r.db.PrepareContext(ctx, getUserPrivacySettingsQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("getUserPrivacy").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov3" title="3">row := stmt.QueryRowContext(ctx, id)
        var privacySettings repoModel.PrivacySettings
        err = row.Scan(&amp;privacySettings.IsPublicPlaylists,
                &amp;privacySettings.IsPublicMinutesListened,
                &amp;privacySettings.IsPublicFavoriteArtists,
                &amp;privacySettings.IsPublicTracksListened,
                &amp;privacySettings.IsPublicFavoriteTracks,
                &amp;privacySettings.IsPublicArtistsListened)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("getUserPrivacy").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        logger.Error("user not found", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">logger.Error("user not found", zap.Error(err))
                return nil, err</span>
        }
        <span class="cov2" title="2">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("getUserPrivacy").Observe(duration)
        return &amp;privacySettings, nil</span>
}

func (r *userPostgresRepository) GetFullUserData(ctx context.Context, username string) (*repoModel.UserFullData, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Get full user data by username", zap.String("username", username))
        id, err := r.GetIDByUsername(ctx, username)
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("getFullUserData").Inc()
                logger.Error("failed to get user ID", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov1" title="1">privacy, err := r.GetUserPrivacy(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("getFullUserData").Inc()
                logger.Error("failed to get user privacy settings", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov1" title="1">user, err := r.GetUserByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("getFullUserData").Inc()
                logger.Error("failed to get user data", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("getFullUserData").Observe(duration)
        return &amp;repoModel.UserFullData{
                Username:  user.Username,
                Email:     user.Email,
                Thumbnail: user.Thumbnail,
                Privacy:   privacy,
        }, nil</span>
}

func (r *userPostgresRepository) GetLabelIDByUserID(ctx context.Context, userID int64) (int64, error) <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting label ID by user ID", zap.Int64("userID", userID))

        stmt, err := r.db.PrepareContext(ctx, GetLabelIDByUserIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("getLabelIDByUserID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return 0, err
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">row := stmt.QueryRowContext(ctx, userID)
        var labelID sql.NullInt64
        err = row.Scan(&amp;labelID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("getLabelIDByUserID").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Error("label not found", zap.Error(err))
                        return 0, err
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get label ID", zap.Error(err))
                return 0, err</span>
        }

        <span class="cov2" title="2">var labelReturnID int64
        if labelID.Valid </span><span class="cov1" title="1">{
                labelReturnID = labelID.Int64
        }</span> else<span class="cov1" title="1"> {
                labelReturnID = -1
        }</span>

        <span class="cov2" title="2">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("getLabelIDByUserID").Observe(duration)
        return labelReturnID, nil</span>
}

func (r *userPostgresRepository) CheckUsersByUsernames(ctx context.Context, usernames []string) error <span class="cov2" title="2">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking users by username", zap.Strings("usernames", usernames))

        stmt, err := r.db.PrepareContext(ctx, GetIdsByUsernamesQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckUsersByUsernames").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov2" title="2">lowerUsernames := make([]string, len(usernames))
        for i, username := range usernames </span><span class="cov4" title="4">{
                lowerUsernames[i] = strings.ToLower(username)
        }</span>
        <span class="cov2" title="2">result, err := stmt.ExecContext(ctx, pq.Array(lowerUsernames))
        if err != nil </span><span class="cov1" title="1">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckUsersByUsernames").Inc()
                logger.Error("failed to query usernames", zap.Error(err))
                return err
        }</span>

        <span class="cov1" title="1">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckUsersByUsernames").Inc()
                logger.Error("failed to get affected rows", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">if rows != int64(len(usernames)) </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckUsersByUsernames").Inc()
                logger.Error("not all users were found", zap.Int64("expected", int64(len(usernames))), zap.Int64("actual", rows))
                return userErrors.NewNotFoundError("not all users were found")
        }</span>
        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("CheckUsersByUsernames").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) UpdateUsersLabel(ctx context.Context, labelID int64, usernames []string) error <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Updating user label", zap.Int64("labelID", labelID), zap.Strings("usernames", usernames))

        stmt, err := r.db.PrepareContext(ctx, UpdateLabelQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateUsersLabel").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">lowerUsernames := make([]string, len(usernames))
        for i, username := range usernames </span><span class="cov2" title="2">{
                lowerUsernames[i] = strings.ToLower(username)
        }</span>

        <span class="cov1" title="1">result, err := stmt.ExecContext(ctx, labelID, pq.Array(lowerUsernames))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateUserLabel").Inc()
                logger.Error("failed to update user label", zap.Error(err))
                return err
        }</span>

        <span class="cov1" title="1">rowsAffeted, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateUserLabel").Inc()
                logger.Error("failed to get affected rows", zap.Error(err))
                return err
        }</span>

        <span class="cov1" title="1">if rowsAffeted != int64(len(usernames)) </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateUserLabel").Inc()
                logger.Error("not all users were updated", zap.Int64("expected", int64(len(usernames))), zap.Int64("actual", rowsAffeted))
                return userErrors.NewNotFoundError("not all users were updated")
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UpdateUserLabel").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) CheckLabelNameUnique(ctx context.Context, name string) (bool, error) <span class="cov1" title="1">{
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Checking label name uniqueness", zap.String("name", name))

        stmt, err := r.db.PrepareContext(ctx, CheckIsLabelNameUniqueQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("CheckLabelNameUnique").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return false, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">var exists bool
        err = stmt.QueryRowContext(ctx, name).Scan(&amp;exists)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov1" title="1">return exists, nil</span>
}

func (r *userPostgresRepository) UpdateLabel(ctx context.Context, newName string, labelID int64) error <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Updating label", zap.Int64("labelID", labelID), zap.String("newName", newName))

        stmt, err := r.db.PrepareContext(ctx, UpdateLabelNameQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateLabel").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">_, err = stmt.ExecContext(ctx, newName, labelID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UpdateLabel").Inc()
                logger.Error("failed to update label", zap.Error(err))
                return err
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UpdateLabel").Observe(duration)
        return nil</span>
}

func (r *userPostgresRepository) GetLabelById(ctx context.Context, labelID int64) (string, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting label by ID", zap.Int64("labelID", labelID))

        stmt, err := r.db.PrepareContext(ctx, GetLabelByIdQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetLabelById").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return "", err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">row := stmt.QueryRowContext(ctx, labelID)
        var labelName string
        err = row.Scan(&amp;labelName)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetLabelById").Inc()
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        logger.Error("label not found", zap.Error(err))
                        return "", err
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get label by ID", zap.Error(err))
                return "", err</span>
        }

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetLabelById").Observe(duration)
        return labelName, nil</span>
}

func (r *userPostgresRepository) GetUsersByLabelID(ctx context.Context, labelID int64) ([]string, error) <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Getting users by label ID", zap.Int64("labelID", labelID))

        stmt, err := r.db.PrepareContext(ctx, GetUsersByLabelIDQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetUsersByLabelID").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">rows, err := stmt.QueryContext(ctx, labelID)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetUsersByLabelID").Inc()
                logger.Error("failed to get users by label ID", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing rows:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">var users []string
        for rows.Next() </span><span class="cov2" title="2">{
                var username string
                err = rows.Scan(&amp;username)
                if err != nil </span><span class="cov0" title="0">{
                        r.metrics.DatabaseErrors.WithLabelValues("GetUsersByLabelID").Inc()
                        logger.Error("failed to scan row", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov2" title="2">users = append(users, username)</span>
        }

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetUsersByLabelID").Observe(duration)
        return users, nil</span>
}

func (r *userPostgresRepository) RemoveUsersFromLabel(ctx context.Context, labelID int64, usernames []string) error <span class="cov1" title="1">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        logger.Info("Removing users from label", zap.Int64("labelID", labelID), zap.Strings("usernames", usernames))

        stmt, err := r.db.PrepareContext(ctx, RemoveLabelQuery)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("RemoveUsersFromLabel").Inc()
                logger.Error("failed to prepare statement", zap.Error(err))
                return err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing statement:", zap.Error(err))
                }</span>
        }()

        <span class="cov1" title="1">lowerUsernames := make([]string, len(usernames))
        for i, username := range usernames </span><span class="cov2" title="2">{
                lowerUsernames[i] = strings.ToLower(username)
        }</span>

        <span class="cov1" title="1">result, err := stmt.ExecContext(ctx, labelID, pq.Array(lowerUsernames))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("RemoveUsersFromLabel").Inc()
                logger.Error("failed to remove users from label", zap.Error(err))
                return err
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("RemoveUsersFromLabel").Inc()
                logger.Error("failed to get affected rows", zap.Error(err))
                return err
        }</span>

        <span class="cov1" title="1">if rowsAffected != int64(len(usernames)) </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("RemoveUsersFromLabel").Inc()
                logger.Error("not all users were removed from label", zap.Int64("expected", int64(len(usernames))), zap.Int64("actual", rowsAffected))
                return userErrors.NewNotFoundError("not all users were removed from label")
        }</span>

        <span class="cov1" title="1">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("RemoveUsersFromLabel").Observe(duration)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package repository

import (
        "bytes"
        "context"
        "fmt"
        "time"

        "image"

        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
        loggerPkg "github.com/go-park-mail-ru/2025_1_Return_Zero/internal/pkg/helpers/logger"
        metrics "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/metrics"
        "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/domain"
        userErrors "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model/errors"
        "go.uber.org/zap"
)

type userS3Repository struct {
        s3         *s3.S3
        uploader   *s3manager.Uploader
        bucketName string
        metrics    *metrics.Metrics
}

func NewS3Repository(s3 *s3.S3, bucketName string, metrics *metrics.Metrics) domain.S3Repository <span class="cov0" title="0">{
        uploader := s3manager.NewUploaderWithClient(s3)
        return &amp;userS3Repository{
                s3:         s3,
                bucketName: bucketName,
                uploader:   uploader,
                metrics:    metrics,
        }
}</span>

func (r *userS3Repository) GetAvatarURL(ctx context.Context, fileKey string) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        if fileKey == "" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("GetAvatarURL").Inc()
                logger.Error("fileKey is empty")
                return "", userErrors.NewEmptyS3KeyError("fileKey is empty")
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("GetAvatarURL").Observe(duration)
        return fmt.Sprintf(
                "https://%s.fra1.digitaloceanspaces.com/avatars%s",
                r.bucketName,
                fileKey,
        ), nil</span>
}

func (r *userS3Repository) UploadUserAvatar(ctx context.Context, username string, file []byte) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        logger := loggerPkg.LoggerFromContext(ctx)
        date := time.Now()
        dateString := date.Format("20060102150405")

        _, format, err := image.Decode(bytes.NewReader(file))
        logger.Info("format", zap.String("format", format))
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadUserAvatar").Inc()
                logger.Error("unsupported or invalid image format", zap.Error(err))
                return "", userErrors.NewUnsupportedImageFormatError("unsupported or invalid image format")
        }</span>

        <span class="cov0" title="0">if format != "jpeg" &amp;&amp; format != "png" &amp;&amp; format != "gif" </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadUserAvatar").Inc()
                logger.Error("unsupported image format", zap.String("format", format))
                return "", userErrors.NewUnsupportedImageFormatError("unsupported or invalid image format")
        }</span>

        // webpBuf := new(bytes.Buffer)
        // if err := webp.Encode(webpBuf, img, &amp;webp.Options{Lossless: true}); err != nil {
        //         logger.Error("failed to encode webp", zap.Error(err))
        //         return "", userAvatarFile.ErrFailedToEncodeWebp
        // }

        <span class="cov0" title="0">fileKey := fmt.Sprintf("/%s-%s.%s", username, dateString, format)
        s3Key := fmt.Sprintf("avatars%s", fileKey)

        _, err = r.uploader.UploadWithContext(ctx, &amp;s3manager.UploadInput{
                Bucket:      aws.String(r.bucketName),
                Key:         aws.String(s3Key),
                Body:        bytes.NewReader(file),
                ContentType: aws.String("image/" + format),
                ACL:         aws.String("public-read"),
        })

        if err != nil </span><span class="cov0" title="0">{
                r.metrics.DatabaseErrors.WithLabelValues("UploadUserAvatar").Inc()
                logger.Error("upload failed", zap.Error(err))
                return "", userErrors.NewFailedToUploadAvatarError("failed to upload avatar")
        }</span>
        <span class="cov0" title="0">duration := time.Since(start).Seconds()
        r.metrics.DatabaseDuration.WithLabelValues("UploadUserAvatar").Observe(duration)

        return fileKey, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package usecase

import (
        "context"

        domain "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/internal/domain"
        model "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model/usecase"
)

func NewUserUsecase(userRepository domain.Repository, s3Repository domain.S3Repository) domain.Usecase <span class="cov10" title="11">{
        return &amp;userUsecase{
                userRepo: userRepository,
                s3Repo:   s3Repository,
        }
}</span>

type userUsecase struct {
        userRepo domain.Repository
        s3Repo   domain.S3Repository
}

func (u *userUsecase) CreateUser(ctx context.Context, registerData *usecaseModel.RegisterData) (*usecaseModel.UserFront, error) <span class="cov3" title="2">{
        repoData := model.RegisterDataFromUsecaseToRepository(registerData)
        userRepoData, err := u.userRepo.CreateUser(ctx, repoData)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.UserFromRepositoryToUsecase(userRepoData), nil</span>
}

func (u *userUsecase) LoginUser(ctx context.Context, loginData *usecaseModel.LoginData) (*usecaseModel.UserFront, error) <span class="cov3" title="2">{
        repoData := model.LoginDataFromUsecaseToRepository(loginData)
        userRepoData, err := u.userRepo.LoginUser(ctx, repoData)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.UserFromRepositoryToUsecase(userRepoData), nil</span>
}

func (u *userUsecase) UploadAvatar(ctx context.Context, avatarUrl string, id int64) error <span class="cov1" title="1">{
        return u.userRepo.UploadAvatar(ctx, avatarUrl, id)
}</span>

func (u *userUsecase) DeleteUser(ctx context.Context, deleteData *usecaseModel.UserDelete) error <span class="cov1" title="1">{
        repoData := model.UserDeleteFromUsecaseToRepository(deleteData)
        return u.userRepo.DeleteUser(ctx, repoData)
}</span>

func (u *userUsecase) ChangeUserData(ctx context.Context, username string, changeData *usecaseModel.ChangeUserData) error <span class="cov1" title="1">{
        userData := model.ChangeUserDataFromUsecaseToRepository(changeData)
        return u.userRepo.ChangeUserData(ctx, username, userData)
}</span>

func (u *userUsecase) ChangeUserPrivacySettings(ctx context.Context, username string, privacySettings *usecaseModel.PrivacySettings) error <span class="cov0" title="0">{
        repoData := model.PrivacySettingsFromUsecaseToRepository(privacySettings)
        return u.userRepo.ChangeUserPrivacySettings(ctx, username, repoData)
}</span>

func (u *userUsecase) GetFullUserData(ctx context.Context, username string) (*usecaseModel.UserFullData, error) <span class="cov1" title="1">{
        userRepoData, err := u.userRepo.GetFullUserData(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.UserFullDataFromRepositoryToUsecase(userRepoData), nil</span>
}

func (u *userUsecase) GetUserByID(ctx context.Context, id int64) (*usecaseModel.UserFront, error) <span class="cov1" title="1">{
        userRepoData, err := u.userRepo.GetUserByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.UserFromRepositoryToUsecase(userRepoData), nil</span>
}

func (u *userUsecase) GetIDByUsername(ctx context.Context, username string) (int64, error) <span class="cov1" title="1">{
        id, err := u.userRepo.GetIDByUsername(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov1" title="1">return id, nil</span>
}

func (u *userUsecase) GetUserPrivacySettings(ctx context.Context, id int64) (*usecaseModel.PrivacySettings, error) <span class="cov1" title="1">{
        privacySettingsRepoData, err := u.userRepo.GetUserPrivacy(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return model.PrivacyFromRepositoryToUsecase(privacySettingsRepoData), nil</span>
}

func (u *userUsecase) GetAvatarURL(ctx context.Context, fileKey string) (string, error) <span class="cov0" title="0">{
        avatarURL, err := u.s3Repo.GetAvatarURL(ctx, fileKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return avatarURL, nil</span>
}

func (u *userUsecase) UploadUserAvatar(ctx context.Context, username string, file []byte) (string, error) <span class="cov0" title="0">{
        avatarURL, err := u.s3Repo.UploadUserAvatar(ctx, username, file)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return avatarURL, nil</span>
}

func (u *userUsecase) GetLabelIDByUserID(ctx context.Context, userID int64) (int64, error) <span class="cov0" title="0">{
        labelID, err := u.userRepo.GetLabelIDByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return labelID, nil</span>
}

func (u *userUsecase) CheckUsersByUsernames(ctx context.Context, usernames []string) error <span class="cov0" title="0">{
        err := u.userRepo.CheckUsersByUsernames(ctx, usernames)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *userUsecase) UpdateUsersLabelID(ctx context.Context, labelID int64, usernames []string) error <span class="cov0" title="0">{
        err := u.userRepo.UpdateUsersLabel(ctx, labelID, usernames)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (u *userUsecase) GetUsersByLabelID(ctx context.Context, labelID int64) ([]string, error) <span class="cov0" title="0">{
        users, err := u.userRepo.GetUsersByLabelID(ctx, labelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

func (u *userUsecase) RemoveUsersFromLabel(ctx context.Context, labelID int64, usernames []string) error <span class="cov0" title="0">{
        err := u.userRepo.RemoveUsersFromLabel(ctx, labelID, usernames)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package model

import (
        protoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/gen/user"
        repoModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model/repository"
        usecaseModel "github.com/go-park-mail-ru/2025_1_Return_Zero/microservices/user/model/usecase"
)

func RegisterDataFromUsecaseToRepository(data *usecaseModel.RegisterData) *repoModel.RegisterData <span class="cov1" title="1">{
        return &amp;repoModel.RegisterData{
                Username: data.Username,
                Email:    data.Email,
                Password: data.Password,
        }
}</span>

func UserFromRepositoryToUsecase(data *repoModel.User) *usecaseModel.UserFront <span class="cov1" title="1">{
        return &amp;usecaseModel.UserFront{
                Username:  data.Username,
                Email:     data.Email,
                Thumbnail: data.Thumbnail,
                Id:        data.ID,
                LabelId:   data.LabelId,
        }
}</span>

func LoginDataFromUsecaseToRepository(data *usecaseModel.LoginData) *repoModel.LoginData <span class="cov1" title="1">{
        return &amp;repoModel.LoginData{
                Username: data.Username,
                Email:    data.Email,
                Password: data.Password,
        }
}</span>

func UserDeleteFromUsecaseToRepository(data *usecaseModel.UserDelete) *repoModel.UserDelete <span class="cov1" title="1">{
        return &amp;repoModel.UserDelete{
                Username: data.Username,
                Email:    data.Email,
                Password: data.Password,
        }
}</span>

func ChangeUserDataFromUsecaseToRepository(data *usecaseModel.ChangeUserData) *repoModel.ChangeUserData <span class="cov1" title="1">{
        return &amp;repoModel.ChangeUserData{
                Password:    data.Password,
                NewUsername: data.NewUsername,
                NewEmail:    data.NewEmail,
                NewPassword: data.NewPassword,
        }
}</span>

func PrivacySettingsFromUsecaseToRepository(data *usecaseModel.PrivacySettings) *repoModel.PrivacySettings <span class="cov1" title="1">{
        return &amp;repoModel.PrivacySettings{
                IsPublicPlaylists:       data.IsPublicPlaylists,
                IsPublicMinutesListened: data.IsPublicMinutesListened,
                IsPublicFavoriteArtists: data.IsPublicFavoriteArtists,
                IsPublicTracksListened:  data.IsPublicTracksListened,
                IsPublicFavoriteTracks:  data.IsPublicFavoriteTracks,
                IsPublicArtistsListened: data.IsPublicArtistsListened,
        }
}</span>

func PrivacyFromRepositoryToUsecase(data *repoModel.PrivacySettings) *usecaseModel.PrivacySettings <span class="cov10" title="3">{
        return &amp;usecaseModel.PrivacySettings{
                IsPublicPlaylists:       data.IsPublicPlaylists,
                IsPublicMinutesListened: data.IsPublicMinutesListened,
                IsPublicFavoriteArtists: data.IsPublicFavoriteArtists,
                IsPublicTracksListened:  data.IsPublicTracksListened,
                IsPublicFavoriteTracks:  data.IsPublicFavoriteTracks,
                IsPublicArtistsListened: data.IsPublicArtistsListened,
        }
}</span>

func UserFullDataFromRepositoryToUsecase(data *repoModel.UserFullData) *usecaseModel.UserFullData <span class="cov1" title="1">{
        privacyUsecase := PrivacyFromRepositoryToUsecase(data.Privacy)
        return &amp;usecaseModel.UserFullData{
                Username:  data.Username,
                Thumbnail: data.Thumbnail,
                Email:     data.Email,
                Privacy:   privacyUsecase,
        }
}</span>

func RegisterDataFromProtoToUsecase(data *protoModel.RegisterData) *usecaseModel.RegisterData <span class="cov1" title="1">{
        return &amp;usecaseModel.RegisterData{
                Username: data.Username,
                Email:    data.Email,
                Password: data.Password,
        }
}</span>

func UserFrontFromUsecaseToProto(data *usecaseModel.UserFront) *protoModel.UserFront <span class="cov1" title="1">{
        return &amp;protoModel.UserFront{
                Username: data.Username,
                Email:    data.Email,
                Avatar:   data.Thumbnail,
                Id:       data.Id,
                LabelId:  data.LabelId,
        }
}</span>

func LoginDataFromProtoToUsecase(data *protoModel.LoginData) *usecaseModel.LoginData <span class="cov1" title="1">{
        return &amp;usecaseModel.LoginData{
                Username: data.Username,
                Email:    data.Email,
                Password: data.Password,
        }
}</span>

func UserDeleteFromProtoToUsecase(data *protoModel.UserDelete) *usecaseModel.UserDelete <span class="cov1" title="1">{
        return &amp;usecaseModel.UserDelete{
                Username: data.Username,
                Email:    data.Email,
                Password: data.Password,
        }
}</span>

func ChangeUserDataFromProtoToUsecase(data *protoModel.ChangeUserDataMessage) *usecaseModel.ChangeUserData <span class="cov1" title="1">{
        return &amp;usecaseModel.ChangeUserData{
                Password:    data.Password,
                NewUsername: data.NewUsername,
                NewEmail:    data.NewEmail,
                NewPassword: data.NewPassword,
        }
}</span>

func PrivacySettingsFromProtoToUsecase(data *protoModel.PrivacySettings) *usecaseModel.PrivacySettings <span class="cov1" title="1">{
        return &amp;usecaseModel.PrivacySettings{
                IsPublicPlaylists:       data.IsPublicPlaylists,
                IsPublicMinutesListened: data.IsPublicMinutesListened,
                IsPublicFavoriteArtists: data.IsPublicFavoriteArtists,
                IsPublicTracksListened:  data.IsPublicTracksListened,
                IsPublicFavoriteTracks:  data.IsPublicFavoriteTracks,
                IsPublicArtistsListened: data.IsPublicArtistsListened,
        }
}</span>

func PrivacySettingsFromUsecaseToProto(data *usecaseModel.PrivacySettings) *protoModel.PrivacySettings <span class="cov6" title="2">{
        return &amp;protoModel.PrivacySettings{
                IsPublicPlaylists:       data.IsPublicPlaylists,
                IsPublicMinutesListened: data.IsPublicMinutesListened,
                IsPublicFavoriteArtists: data.IsPublicFavoriteArtists,
                IsPublicTracksListened:  data.IsPublicTracksListened,
                IsPublicFavoriteTracks:  data.IsPublicFavoriteTracks,
                IsPublicArtistsListened: data.IsPublicArtistsListened,
        }
}</span>

func UserFullDataFromUsecaseToProto(data *usecaseModel.UserFullData) *protoModel.UserFullData <span class="cov1" title="1">{
        privacyProto := PrivacySettingsFromUsecaseToProto(data.Privacy)
        return &amp;protoModel.UserFullData{
                Username: data.Username,
                Avatar:   data.Thumbnail,
                Email:    data.Email,
                Privacy:  privacyProto,
        }
}</span>

func UserIDFromUsecaseToProto(id int64) *protoModel.UserID <span class="cov1" title="1">{
        return &amp;protoModel.UserID{
                Id: id,
        }
}</span>

func AvatarUrlFromUsecaseToProto(url string) *protoModel.AvatarUrl <span class="cov1" title="1">{
        return &amp;protoModel.AvatarUrl{
                Url: url,
        }
}</span>

func FileKeyFromUsecaseToProto(fileKey string) *protoModel.FileKey <span class="cov1" title="1">{
        return &amp;protoModel.FileKey{
                FileKey: fileKey,
        }

}</span>

func LabelIDFromUsecaseToProto(id int64) *protoModel.LabelID <span class="cov0" title="0">{
        return &amp;protoModel.LabelID{
                Id: id,
        }
}</span>

func LabelFromUsecaseToProto(label *usecaseModel.Label) *protoModel.Label <span class="cov0" title="0">{
        return &amp;protoModel.Label{
                Id:        label.ID,
                Name:      label.Name,
                Usernames: label.Members,
        }
}</span>

func UserToFrontFromRepositoryToUsecase(user *repoModel.User) *usecaseModel.UserFront <span class="cov0" title="0">{
        return &amp;usecaseModel.UserFront{
                Username:  user.Username,
                Email:     user.Email,
                Thumbnail: user.Thumbnail,
                Id:        user.ID,
        }
}</span>

func UsersToFrontFromRepositoryToUsecase(users []*repoModel.User) []*usecaseModel.UserFront <span class="cov0" title="0">{
        userFronts := make([]*usecaseModel.UserFront, len(users))
        for i, user := range users </span><span class="cov0" title="0">{
                userFronts[i] = UserToFrontFromRepositoryToUsecase(user)
        }</span>
        <span class="cov0" title="0">return userFronts</span>
}

func UserToFrontFromUsecaseToProto(user *usecaseModel.UserFront) *protoModel.UserFront <span class="cov0" title="0">{
        return &amp;protoModel.UserFront{
                Username: user.Username,
                Email:    user.Email,
                Avatar:   user.Thumbnail,
                Id:       user.Id,
        }
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package errors

import (
        "fmt"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type UserError struct {
        Code    codes.Code
        Message string
}

func (e *UserError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func (e *UserError) GRPCStatus() *status.Status <span class="cov0" title="0">{
        return status.New(e.Code, e.Message)
}</span>

func NewNotFoundError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;UserError{
                Code:    codes.NotFound,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewUserExistError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;UserError{
                Code:    codes.AlreadyExists,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewCreateSaltError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;UserError{
                Code:    codes.Internal,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewWrongPasswordError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;UserError{
                Code:    codes.Unauthenticated,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewPasswordRequierdError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;UserError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewEmptyS3KeyError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;UserError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewUnsupportedImageFormatError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;UserError{
                Code:    codes.InvalidArgument,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewFailedToUploadAvatarError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;UserError{
                Code:    codes.Internal,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

func NewLabelExistError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;UserError{
                Code:    codes.AlreadyExists,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

var (
        ErrUserNotFound           = NewNotFoundError("user not found")
        ErrUserExist              = NewUserExistError("user already exist")
        ErrCreateSalt             = NewCreateSaltError("failed to create salt")
        ErrWrongPassword          = NewWrongPasswordError("wrong password")
        ErrPasswordRequierd       = NewPasswordRequierdError("password required")
        ErrEmptyS3Key             = NewEmptyS3KeyError("s3 key is empty")
        ErrUnsupportedImageFormat = NewUnsupportedImageFormatError("unsupported image format")
        ErrFailedToUploadAvatar   = NewFailedToUploadAvatarError("failed to upload avatar")
        ErrLabelExist             = NewLabelExistError("label already exist")
)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
