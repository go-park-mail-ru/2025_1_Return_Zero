# Домашнее задание №3
## Замеряемая сущность
Для замеров производительности была выбрана сущность плейлиста, так как это основная сущность которую может создавать и просматривать юзер сервиса. Остальные он в основном только просматривает.

## Утилита для замеров
Для замеров производительности используется утилита `wrk`. Перед замерами на сервер отправляется запрос для авторизации и получении `session_id` пользователя для получения возможности создавать и просматривать свои плейлисты. Запрос на создание отправляется в виде multipart/form-data, так как опционально пользователь может прикреплять изображение к плейлисту при создании.

В этой утилите можно указать количество потоков и количество соединений, которые будут использоваться для замеров. 
```bash
Usage: wrk <options> <url>                            
  Options:                                            
    -c, --connections <N>  Connections to keep open   
    -d, --duration    <T>  Duration of test           
    -t, --threads     <N>  Number of threads to use   
                                                      
    -s, --script      <S>  Load Lua script file       
    -H, --header      <H>  Add header to request      
        --latency          Print latency statistics   
        --timeout     <T>  Socket/request timeout     
    -v, --version          Print version details      
                                                      
  Numeric arguments may include a SI unit (1k, 1M, 1G)
  Time arguments may include a time unit (2s, 2m, 2h)
```

Было выбрано 100 потоков и 100 соединений, так как этого достаточно для замеров производительности. Время запросов для создания ограничивается 30 минутами, а время на получения плейлистов 20 минутами.

В хедере передается `session_id` для того чтобы сервер мог определить пользователя и его права.


Дополнительно передается скрипт на lua, который производит создание случайных имен для плейлистов и ограничивает для каждого потока количество запросов на 1000, так чтобы в итоге было создано 100000 плейлистов. При получение в скрипте на lua указывается метод запроса и метод

## Нагрузочное тестирование создания плейлистов
```
Running 30m test @ https://returnzero.ru/api/v1/playlists
  100 threads and 100 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    84.81ms  172.99ms   2.00s    98.12%
    Req/Sec     6.29      7.59    70.00     83.88%
  100000 requests in 30.00m, 24.50MB read
  Socket errors: connect 0, read 0, write 0, timeout 239
Requests/sec:     55.56
Transfer/sec:     13.94KB
```

Используется fill_db.sh

## Нагрузочное тестирование получения плейлистов
```
Running 20m test @ https://returnzero.ru/api/v1/playlists/me
  100 threads and 100 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    69.97ms  145.40ms   1.99s    96.12%
    Req/Sec    11.98     17.71   121.00     88.14%
  26931 requests in 20.00m, 46.33GB read
  Socket errors: connect 0, read 2032, write 0, timeout 530
  Non-2xx or 3xx responses: 240
Requests/sec:     22.44
Transfer/sec:     39.54MB
```

Используется fill_db.sh

## Анализ результатов

Утилита `wrk` выводит следующие данные:
- Количество потоков и соединений
- Среднее задержку по потоку `Latency Avg`
- Среднее количество запросов в секунду по потоку `Requests/sec Avg`
- Стандартное отклонение задержки по потоку `Latency Stdev`
- Стандартное отклонение количества запросов в секунду по потоку `Requests/sec Stdev`
- Максимальную задержку по потоку `Latency Max`
- Максимальное количество запросов в секунду по потоку `Requests/sec Max`
- Процент запросов, в пределах стандартного отклонения задержки`Latency Stdev%`
- Процент запросов, в пределах стандартного отклонения количества запросов в секунду`Requests/sec Stdev%`

Также отображается RPS и пропускная способность в секунду.

### Создание плейлистов

```
RPS: 55.56
Средняя задержка: 84.81ms
```

Данные результаты являются относительно неплохими Задержка не превышает 100мс, что является приемлемым для сервиса.

### Получение плейлистов

```
RPS: 22.44
Средняя задержка: 69.97ms
```

В данном случае низкие RPS обуславливается тем, что пользователь создал 100000 плейлистов и получается получить их всех, таким образом возникает узкое горлышко в виде количества передаваемых данных по сети. Это можно увидеть по тому, что было прочитано 46 ГБ за 26391 запросов В реальной ситуации у пользователя будет на несколько порядков меньше плейлистов. Если же мы хотим улучшить ситуацию, то можно добавить простую пагинацию, что в свою очередь уменьшит объем передаваемых данных.
Задержка остается в пределах 100мс, что является приемлемым для сервиса.

## Варианты оптимизации бд

Для получения плейлистов используется следующий запрос:
```
SELECT p.id, p.title, p.user_id, p.thumbnail_url
		FROM playlist p
		LEFT JOIN favorite_playlist fp ON p.id = fp.playlist_id
		WHERE p.user_id = $1 OR (fp.user_id = $1 AND p.is_public = true)
		ORDER BY 
			CASE WHEN p.user_id = $1 THEN p.created_at ELSE fp.created_at END DESC
```

Для оптимизации данного запроса можно добавить следующие индексы:
```sql
-- Индекс для сортировки по user_id и created_at
CREATE INDEX idx_playlist_user_created_at ON playlist(user_id, created_at DESC);

-- Индекс для фильтрации публичных плейлистов
CREATE INDEX idx_playlist_public ON playlist(is_public);

-- Композитный индекс для сортировки по user_id и playlist_id
CREATE INDEX idx_favorite_playlist_user_playlist ON favorite_playlist(user_id, playlist_id, created_at DESC);
```

Данные индексы в конкретной ситуации сильно не улучшат производительность, так как у запроса низкая селективность, так как все плейлисты создавались для одного пользователя.

Для оптимизации возможно также денормализация сущностей в бд: например сразу хранить username пользователя с user_id, но это нарушит целостность таблицы, что будет сложно поддерживать.

